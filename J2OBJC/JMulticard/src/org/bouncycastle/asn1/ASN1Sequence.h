//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/asn1/ASN1Sequence.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgBouncycastleAsn1ASN1Sequence")
#ifdef RESTRICT_OrgBouncycastleAsn1ASN1Sequence
#define INCLUDE_ALL_OrgBouncycastleAsn1ASN1Sequence 0
#else
#define INCLUDE_ALL_OrgBouncycastleAsn1ASN1Sequence 1
#endif
#undef RESTRICT_OrgBouncycastleAsn1ASN1Sequence

#if !defined (OrgBouncycastleAsn1ASN1Sequence_) && (INCLUDE_ALL_OrgBouncycastleAsn1ASN1Sequence || defined(INCLUDE_OrgBouncycastleAsn1ASN1Sequence))
#define OrgBouncycastleAsn1ASN1Sequence_

#define RESTRICT_OrgBouncycastleAsn1ASN1Primitive 1
#define INCLUDE_OrgBouncycastleAsn1ASN1Primitive 1
#include "org/bouncycastle/asn1/ASN1Primitive.h"

#define RESTRICT_OrgBouncycastleUtilIterable 1
#define INCLUDE_OrgBouncycastleUtilIterable 1
#include "org/bouncycastle/util/Iterable.h"

@class IOSObjectArray;
@class OrgBouncycastleAsn1ASN1BitString;
@class OrgBouncycastleAsn1ASN1EncodableVector;
@class OrgBouncycastleAsn1ASN1External;
@class OrgBouncycastleAsn1ASN1OctetString;
@class OrgBouncycastleAsn1ASN1Set;
@class OrgBouncycastleAsn1ASN1TaggedObject;
@class OrgBouncycastleAsn1ASN1UniversalType;
@protocol JavaUtilEnumeration;
@protocol JavaUtilFunctionConsumer;
@protocol JavaUtilIterator;
@protocol JavaUtilSpliterator;
@protocol OrgBouncycastleAsn1ASN1Encodable;
@protocol OrgBouncycastleAsn1ASN1SequenceParser;

/*!
 @brief ASN.1 <code>SEQUENCE</code> and <code>SEQUENCE OF</code> constructs.
 <p>
  DER form is always definite form length fields, while
  BER support uses indefinite form. 
 <hr>
  <p><b>X.690</b></p>
  <p><b>8: Basic encoding rules</b></p>
  <p><b>8.9 Encoding of a sequence value </b></p>
  8.9.1 The encoding of a sequence value shall be constructed. 
 <p>
  <b>8.9.2</b> The contents octets shall consist of the complete
  encoding of one data value from each of the types listed in
  the ASN.1 definition of the sequence type, in the order of
  their appearance in the definition, unless the type was referenced
  with the keyword <b>OPTIONAL</b> or the keyword <b>DEFAULT</b>.
  </p><p>
  <b>8.9.3</b> The encoding of a data value may, but need not,
  be present for a type which was referenced with the keyword 
 <b>OPTIONAL</b> or the keyword <b>DEFAULT</b>.
  If present, it shall appear in the encoding at the point
  corresponding to the appearance of the type in the ASN.1 definition. 
 </p><p>
  <b>8.10 Encoding of a sequence-of value </b>
  </p><p>
  <b>8.10.1</b> The encoding of a sequence-of value shall be constructed. 
 <p>
  <b>8.10.2</b> The contents octets shall consist of zero,
  one or more complete encodings of data values from the type listed in
  the ASN.1 definition. 
 <p>
  <b>8.10.3</b> The order of the encodings of the data values shall be
  the same as the order of the data values in the sequence-of value to
  be encoded. 
 </p>
  <p><b>9: Canonical encoding rules</b></p>
  <p><b>9.1 Length forms</b></p>
  If the encoding is constructed, it shall employ the indefinite-length form.
  If the encoding is primitive, it shall include the fewest length octets necessary.
  [Contrast with 8.1.3.2 b).] 
 <p><b>11: Restrictions on BER employed by both CER and DER</b></p>
  <p><b>11.5 Set and sequence components with default value</b></p>
  <p>
  The encoding of a set value or sequence value shall not include
  an encoding for any component value which is equal to
  its default value. 
 </p>
 */
@interface OrgBouncycastleAsn1ASN1Sequence : OrgBouncycastleAsn1ASN1Primitive < OrgBouncycastleUtilIterable > {
 @public
  IOSObjectArray *elements_;
}

#pragma mark Public

/*!
 @brief Return an ASN1 SEQUENCE from a tagged object.There is a special
  case here, if an object appears to have been explicitly tagged on
  reading but we were expecting it to be implicitly tagged in the
  normal course of events it indicates that we lost the surrounding
  sequence - so we need to add it back (this will happen if the tagged
  object is a sequence that contains other sequences).
 If you are
  dealing with implicitly tagged sequences you really <b>should</b>
  be using this method.
 @param taggedObject the tagged object.
 @param explicit_ true if the object is meant to be explicitly tagged,           false otherwise.
 @throw IllegalArgumentExceptionif the tagged object cannot
           be converted.
 @return an ASN1Sequence instance.
 */
+ (OrgBouncycastleAsn1ASN1Sequence *)getInstanceWithOrgBouncycastleAsn1ASN1TaggedObject:(OrgBouncycastleAsn1ASN1TaggedObject *)taggedObject
                                                                            withBoolean:(jboolean)explicit_;

/*!
 @brief Return an ASN1Sequence from the given object.
 @param obj the object we want converted.
 @throw IllegalArgumentExceptionif the object cannot be converted.
 @return an ASN1Sequence instance, or null.
 */
+ (OrgBouncycastleAsn1ASN1Sequence *)getInstanceWithId:(id)obj;

/*!
 @brief Return the object at the sequence position indicated by index.
 @param index the sequence number (starting at zero) of the object
 @return the object at the sequence position indicated by index.
 */
- (id<OrgBouncycastleAsn1ASN1Encodable>)getObjectAtWithInt:(jint)index;

- (id<JavaUtilEnumeration>)getObjects;

- (NSUInteger)hash;

- (id<JavaUtilIterator>)iterator;

- (id<OrgBouncycastleAsn1ASN1SequenceParser>)parser;

/*!
 @brief Return the number of objects in this sequence.
 @return the number of objects in this sequence.
 */
- (jint)size;

- (IOSObjectArray *)toArray;

- (NSString *)description;

#pragma mark Protected

/*!
 @brief Create an empty SEQUENCE
 */
- (instancetype)init;

/*!
 @brief Create a SEQUENCE containing one object.
 @param element the object to be put in the SEQUENCE.
 */
- (instancetype)initWithOrgBouncycastleAsn1ASN1Encodable:(id<OrgBouncycastleAsn1ASN1Encodable>)element;

/*!
 @brief Create a SEQUENCE containing an array of objects.
 @param elements the array of objects to be put in the SEQUENCE.
 */
- (instancetype)initWithOrgBouncycastleAsn1ASN1EncodableArray:(IOSObjectArray *)elements;

/*!
 @brief Create a SEQUENCE containing a vector of objects.
 @param elementVector the vector of objects to be put in the SEQUENCE.
 */
- (instancetype)initWithOrgBouncycastleAsn1ASN1EncodableVector:(OrgBouncycastleAsn1ASN1EncodableVector *)elementVector;

#pragma mark Package-Private

- (instancetype)initWithOrgBouncycastleAsn1ASN1EncodableArray:(IOSObjectArray *)elements
                                                  withBoolean:(jboolean)clone;

- (jboolean)asn1EqualsWithOrgBouncycastleAsn1ASN1Primitive:(OrgBouncycastleAsn1ASN1Primitive *)other;

- (jboolean)encodeConstructed;

- (IOSObjectArray *)getConstructedBitStrings;

- (IOSObjectArray *)getConstructedOctetStrings;

- (IOSObjectArray *)toArrayInternal;

- (OrgBouncycastleAsn1ASN1BitString *)toASN1BitString;

- (OrgBouncycastleAsn1ASN1External *)toASN1External;

- (OrgBouncycastleAsn1ASN1OctetString *)toASN1OctetString;

- (OrgBouncycastleAsn1ASN1Set *)toASN1Set;

/*!
 @brief Change current SEQUENCE object to be encoded as <code>DERSequence</code>.
 This is part of Distinguished Encoding Rules form serialization.
 */
- (OrgBouncycastleAsn1ASN1Primitive *)toDERObject;

/*!
 @brief Change current SEQUENCE object to be encoded as <code>DLSequence</code>.
 This is part of Direct Length form serialization.
 */
- (OrgBouncycastleAsn1ASN1Primitive *)toDLObject;

@end

J2OBJC_STATIC_INIT(OrgBouncycastleAsn1ASN1Sequence)

J2OBJC_FIELD_SETTER(OrgBouncycastleAsn1ASN1Sequence, elements_, IOSObjectArray *)

inline OrgBouncycastleAsn1ASN1UniversalType *OrgBouncycastleAsn1ASN1Sequence_get_TYPE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT OrgBouncycastleAsn1ASN1UniversalType *OrgBouncycastleAsn1ASN1Sequence_TYPE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgBouncycastleAsn1ASN1Sequence, TYPE, OrgBouncycastleAsn1ASN1UniversalType *)

FOUNDATION_EXPORT OrgBouncycastleAsn1ASN1Sequence *OrgBouncycastleAsn1ASN1Sequence_getInstanceWithId_(id obj);

FOUNDATION_EXPORT OrgBouncycastleAsn1ASN1Sequence *OrgBouncycastleAsn1ASN1Sequence_getInstanceWithOrgBouncycastleAsn1ASN1TaggedObject_withBoolean_(OrgBouncycastleAsn1ASN1TaggedObject *taggedObject, jboolean explicit_);

FOUNDATION_EXPORT void OrgBouncycastleAsn1ASN1Sequence_init(OrgBouncycastleAsn1ASN1Sequence *self);

FOUNDATION_EXPORT void OrgBouncycastleAsn1ASN1Sequence_initWithOrgBouncycastleAsn1ASN1Encodable_(OrgBouncycastleAsn1ASN1Sequence *self, id<OrgBouncycastleAsn1ASN1Encodable> element);

FOUNDATION_EXPORT void OrgBouncycastleAsn1ASN1Sequence_initWithOrgBouncycastleAsn1ASN1EncodableVector_(OrgBouncycastleAsn1ASN1Sequence *self, OrgBouncycastleAsn1ASN1EncodableVector *elementVector);

FOUNDATION_EXPORT void OrgBouncycastleAsn1ASN1Sequence_initWithOrgBouncycastleAsn1ASN1EncodableArray_(OrgBouncycastleAsn1ASN1Sequence *self, IOSObjectArray *elements);

FOUNDATION_EXPORT void OrgBouncycastleAsn1ASN1Sequence_initWithOrgBouncycastleAsn1ASN1EncodableArray_withBoolean_(OrgBouncycastleAsn1ASN1Sequence *self, IOSObjectArray *elements, jboolean clone);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastleAsn1ASN1Sequence)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgBouncycastleAsn1ASN1Sequence")
