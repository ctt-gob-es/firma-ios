//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/math/Primes.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgBouncycastleMathPrimes")
#ifdef RESTRICT_OrgBouncycastleMathPrimes
#define INCLUDE_ALL_OrgBouncycastleMathPrimes 0
#else
#define INCLUDE_ALL_OrgBouncycastleMathPrimes 1
#endif
#undef RESTRICT_OrgBouncycastleMathPrimes

#if !defined (OrgBouncycastleMathPrimes_) && (INCLUDE_ALL_OrgBouncycastleMathPrimes || defined(INCLUDE_OrgBouncycastleMathPrimes))
#define OrgBouncycastleMathPrimes_

@class IOSByteArray;
@class JavaMathBigInteger;
@class JavaSecuritySecureRandom;
@class OrgBouncycastleMathPrimes_MROutput;
@class OrgBouncycastleMathPrimes_STOutput;
@protocol OrgBouncycastleCryptoDigest;

/*!
 @brief Utility methods for generating primes and testing for primality.
 */
@interface OrgBouncycastleMathPrimes : NSObject

#pragma mark Public

- (instancetype)init;

/*!
 @brief FIPS 186-4 C.3.2 Enhanced Miller-Rabin Probabilistic Primality Test
  Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases.This is an
  alternative to <code>isMRProbablePrime(BigInteger, SecureRandom, int)</code> that provides more
  information about a composite candidate, which may be useful when generating or validating
  RSA moduli.
 @param candidate the 
 <code>BigInteger</code>  instance to test for primality.
 @param random the source of randomness to use to choose bases.
 @param iterations the number of randomly-chosen bases to perform the test for.
 @return an <code>MROutput</code> instance that can be further queried for details.
 */
+ (OrgBouncycastleMathPrimes_MROutput *)enhancedMRProbablePrimeTestWithJavaMathBigInteger:(JavaMathBigInteger *)candidate
                                                             withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random
                                                                                  withInt:(jint)iterations;

/*!
 @brief FIPS 186-4 C.6 Shawe-Taylor Random_Prime Routine
  Construct a provable prime number using a hash function.
 @param hash_ the 
 <code>Digest</code>  instance to use (as "Hash()"). Cannot be null.
 @param length the length (in bits) of the prime to be generated. Must be at least 2.
 @param inputSeed the seed to be used for the generation of the requested prime. Cannot be null or
              empty.
 @return an <code>STOutput</code> instance containing the requested prime.
 */
+ (OrgBouncycastleMathPrimes_STOutput *)generateSTRandomPrimeWithOrgBouncycastleCryptoDigest:(id<OrgBouncycastleCryptoDigest>)hash_
                                                                                     withInt:(jint)length
                                                                               withByteArray:(IOSByteArray *)inputSeed;

/*!
 @brief A fast check for small divisors, up to some implementation-specific limit.
 @param candidate the 
 <code>BigInteger</code>  instance to test for division by small factors.
 @return <code>true</code> if the candidate is found to have any small factors,
          <code>false</code> otherwise.
 */
+ (jboolean)hasAnySmallFactorsWithJavaMathBigInteger:(JavaMathBigInteger *)candidate;

/*!
 @brief FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test
  Run several iterations of the Miller-Rabin algorithm with randomly-chosen bases.
 @param candidate the 
 <code>BigInteger</code>  instance to test for primality.
 @param random the source of randomness to use to choose bases.
 @param iterations the number of randomly-chosen bases to perform the test for.
 @return <code>false</code> if any witness to compositeness is found amongst the chosen bases
          (so <code>candidate</code> is definitely NOT prime), or else <code>true</code>
          (indicating primality with some probability dependent on the number of iterations
          that were performed).
 */
+ (jboolean)isMRProbablePrimeWithJavaMathBigInteger:(JavaMathBigInteger *)candidate
                       withJavaSecuritySecureRandom:(JavaSecuritySecureRandom *)random
                                            withInt:(jint)iterations;

/*!
 @brief FIPS 186-4 C.3.1 Miller-Rabin Probabilistic Primality Test (to a fixed base).
 Run a single iteration of the Miller-Rabin algorithm against the specified base.
 @param candidate the 
 <code>BigInteger</code>  instance to test for primality.
 @param base the base value to use for this iteration.
 @return <code>false</code> if the specified base is a witness to compositeness (so
          <code>candidate</code> is definitely NOT prime), or else <code>true</code>.
 */
+ (jboolean)isMRProbablePrimeToBaseWithJavaMathBigInteger:(JavaMathBigInteger *)candidate
                                   withJavaMathBigInteger:(JavaMathBigInteger *)base;

@end

J2OBJC_STATIC_INIT(OrgBouncycastleMathPrimes)

inline jint OrgBouncycastleMathPrimes_get_SMALL_FACTOR_LIMIT(void);
#define OrgBouncycastleMathPrimes_SMALL_FACTOR_LIMIT 211
J2OBJC_STATIC_FIELD_CONSTANT(OrgBouncycastleMathPrimes, SMALL_FACTOR_LIMIT, jint)

FOUNDATION_EXPORT void OrgBouncycastleMathPrimes_init(OrgBouncycastleMathPrimes *self);

FOUNDATION_EXPORT OrgBouncycastleMathPrimes_STOutput *OrgBouncycastleMathPrimes_generateSTRandomPrimeWithOrgBouncycastleCryptoDigest_withInt_withByteArray_(id<OrgBouncycastleCryptoDigest> hash_, jint length, IOSByteArray *inputSeed);

FOUNDATION_EXPORT OrgBouncycastleMathPrimes_MROutput *OrgBouncycastleMathPrimes_enhancedMRProbablePrimeTestWithJavaMathBigInteger_withJavaSecuritySecureRandom_withInt_(JavaMathBigInteger *candidate, JavaSecuritySecureRandom *random, jint iterations);

FOUNDATION_EXPORT jboolean OrgBouncycastleMathPrimes_hasAnySmallFactorsWithJavaMathBigInteger_(JavaMathBigInteger *candidate);

FOUNDATION_EXPORT jboolean OrgBouncycastleMathPrimes_isMRProbablePrimeWithJavaMathBigInteger_withJavaSecuritySecureRandom_withInt_(JavaMathBigInteger *candidate, JavaSecuritySecureRandom *random, jint iterations);

FOUNDATION_EXPORT jboolean OrgBouncycastleMathPrimes_isMRProbablePrimeToBaseWithJavaMathBigInteger_withJavaMathBigInteger_(JavaMathBigInteger *candidate, JavaMathBigInteger *base);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastleMathPrimes)

#endif

#if !defined (OrgBouncycastleMathPrimes_MROutput_) && (INCLUDE_ALL_OrgBouncycastleMathPrimes || defined(INCLUDE_OrgBouncycastleMathPrimes_MROutput))
#define OrgBouncycastleMathPrimes_MROutput_

@class JavaMathBigInteger;

/*!
 @brief Used to return the output from the 
 Enhanced
  Miller-Rabin Probabilistic Primality Test
 */
@interface OrgBouncycastleMathPrimes_MROutput : NSObject

#pragma mark Public

- (JavaMathBigInteger *)getFactor;

- (jboolean)isNotPrimePower;

- (jboolean)isProvablyComposite;

#pragma mark Package-Private

+ (OrgBouncycastleMathPrimes_MROutput *)probablyPrime;

+ (OrgBouncycastleMathPrimes_MROutput *)provablyCompositeNotPrimePower;

+ (OrgBouncycastleMathPrimes_MROutput *)provablyCompositeWithFactorWithJavaMathBigInteger:(JavaMathBigInteger *)factor;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgBouncycastleMathPrimes_MROutput)

FOUNDATION_EXPORT OrgBouncycastleMathPrimes_MROutput *OrgBouncycastleMathPrimes_MROutput_probablyPrime(void);

FOUNDATION_EXPORT OrgBouncycastleMathPrimes_MROutput *OrgBouncycastleMathPrimes_MROutput_provablyCompositeWithFactorWithJavaMathBigInteger_(JavaMathBigInteger *factor);

FOUNDATION_EXPORT OrgBouncycastleMathPrimes_MROutput *OrgBouncycastleMathPrimes_MROutput_provablyCompositeNotPrimePower(void);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastleMathPrimes_MROutput)

#endif

#if !defined (OrgBouncycastleMathPrimes_STOutput_) && (INCLUDE_ALL_OrgBouncycastleMathPrimes || defined(INCLUDE_OrgBouncycastleMathPrimes_STOutput))
#define OrgBouncycastleMathPrimes_STOutput_

@class IOSByteArray;
@class JavaMathBigInteger;

/*!
 @brief Used to return the output from the 
 Shawe-Taylor Random_Prime
  Routine
 */
@interface OrgBouncycastleMathPrimes_STOutput : NSObject

#pragma mark Public

- (JavaMathBigInteger *)getPrime;

- (jint)getPrimeGenCounter;

- (IOSByteArray *)getPrimeSeed;

#pragma mark Package-Private

- (instancetype)initWithJavaMathBigInteger:(JavaMathBigInteger *)prime
                             withByteArray:(IOSByteArray *)primeSeed
                                   withInt:(jint)primeGenCounter;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgBouncycastleMathPrimes_STOutput)

FOUNDATION_EXPORT void OrgBouncycastleMathPrimes_STOutput_initWithJavaMathBigInteger_withByteArray_withInt_(OrgBouncycastleMathPrimes_STOutput *self, JavaMathBigInteger *prime, IOSByteArray *primeSeed, jint primeGenCounter);

FOUNDATION_EXPORT OrgBouncycastleMathPrimes_STOutput *new_OrgBouncycastleMathPrimes_STOutput_initWithJavaMathBigInteger_withByteArray_withInt_(JavaMathBigInteger *prime, IOSByteArray *primeSeed, jint primeGenCounter) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgBouncycastleMathPrimes_STOutput *create_OrgBouncycastleMathPrimes_STOutput_initWithJavaMathBigInteger_withByteArray_withInt_(JavaMathBigInteger *prime, IOSByteArray *primeSeed, jint primeGenCounter);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastleMathPrimes_STOutput)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgBouncycastleMathPrimes")
