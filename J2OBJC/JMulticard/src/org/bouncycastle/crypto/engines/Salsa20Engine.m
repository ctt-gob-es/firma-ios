//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/crypto/engines/Salsa20Engine.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Deprecated.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/annotation/Annotation.h"
#include "org/bouncycastle/crypto/CipherParameters.h"
#include "org/bouncycastle/crypto/DataLengthException.h"
#include "org/bouncycastle/crypto/MaxBytesExceededException.h"
#include "org/bouncycastle/crypto/OutputLengthException.h"
#include "org/bouncycastle/crypto/engines/Salsa20Engine.h"
#include "org/bouncycastle/crypto/params/KeyParameter.h"
#include "org/bouncycastle/crypto/params/ParametersWithIV.h"
#include "org/bouncycastle/util/Integers.h"
#include "org/bouncycastle/util/Pack.h"
#include "org/bouncycastle/util/Strings.h"

#if !__has_feature(objc_arc)
#error "org/bouncycastle/crypto/engines/Salsa20Engine must be compiled with ARC (-fobjc-arc)"
#endif

@interface OrgBouncycastleCryptoEnginesSalsa20Engine () {
 @public
  jint index_;
  IOSByteArray *keyStream_;
  jboolean initialised_;
  jint cW0_;
  jint cW1_;
  jint cW2_;
}

- (void)resetLimitCounter;

- (jboolean)limitExceeded;

- (jboolean)limitExceededWithInt:(jint)len;

@end

J2OBJC_FIELD_SETTER(OrgBouncycastleCryptoEnginesSalsa20Engine, keyStream_, IOSByteArray *)

/*!
 @brief Constants
 */
inline jint OrgBouncycastleCryptoEnginesSalsa20Engine_get_STATE_SIZE(void);
#define OrgBouncycastleCryptoEnginesSalsa20Engine_STATE_SIZE 16
J2OBJC_STATIC_FIELD_CONSTANT(OrgBouncycastleCryptoEnginesSalsa20Engine, STATE_SIZE, jint)

inline IOSIntArray *OrgBouncycastleCryptoEnginesSalsa20Engine_get_TAU_SIGMA(void);
static IOSIntArray *OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgBouncycastleCryptoEnginesSalsa20Engine, TAU_SIGMA, IOSIntArray *)

__attribute__((unused)) static void OrgBouncycastleCryptoEnginesSalsa20Engine_resetLimitCounter(OrgBouncycastleCryptoEnginesSalsa20Engine *self);

__attribute__((unused)) static jboolean OrgBouncycastleCryptoEnginesSalsa20Engine_limitExceeded(OrgBouncycastleCryptoEnginesSalsa20Engine *self);

__attribute__((unused)) static jboolean OrgBouncycastleCryptoEnginesSalsa20Engine_limitExceededWithInt_(OrgBouncycastleCryptoEnginesSalsa20Engine *self, jint len);

__attribute__((unused)) static IOSObjectArray *OrgBouncycastleCryptoEnginesSalsa20Engine__Annotations$0(void);

__attribute__((unused)) static IOSObjectArray *OrgBouncycastleCryptoEnginesSalsa20Engine__Annotations$1(void);

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/crypto/engines/Salsa20Engine.java"

J2OBJC_INITIALIZED_DEFN(OrgBouncycastleCryptoEnginesSalsa20Engine)

IOSByteArray *OrgBouncycastleCryptoEnginesSalsa20Engine_sigma;
IOSByteArray *OrgBouncycastleCryptoEnginesSalsa20Engine_tau;


#line 17
@implementation OrgBouncycastleCryptoEnginesSalsa20Engine


#line 27
- (void)packTauOrSigmaWithInt:(jint)keyLength
                 withIntArray:(IOSIntArray *)state
                      withInt:(jint)stateOffset {
  
#line 29
  jint tsOff = JreIntDiv((keyLength - 16), 4);
  *IOSIntArray_GetRef(nil_chk(state), stateOffset) = IOSIntArray_Get(nil_chk(OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA), tsOff);
  *IOSIntArray_GetRef(state, stateOffset + 1) = IOSIntArray_Get(OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA, tsOff + 1);
  *IOSIntArray_GetRef(state, stateOffset + 2) = IOSIntArray_Get(OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA, tsOff + 2);
  *IOSIntArray_GetRef(state, stateOffset + 3) = IOSIntArray_Get(OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA, tsOff + 3);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 62
- (instancetype)init {
  OrgBouncycastleCryptoEnginesSalsa20Engine_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 71
- (instancetype)initWithInt:(jint)rounds {
  OrgBouncycastleCryptoEnginesSalsa20Engine_initWithInt_(self, rounds);
  return self;
}


#line 89
- (void)init__WithBoolean:(jboolean)forEncryption
withOrgBouncycastleCryptoCipherParameters:(id<OrgBouncycastleCryptoCipherParameters>)params {
  
#line 100
  if (!([params isKindOfClass:[OrgBouncycastleCryptoParamsParametersWithIV class]])) {
    
#line 102
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", [self getAlgorithmName], @" Init parameters must include an IV"));
  }
  
#line 105
  OrgBouncycastleCryptoParamsParametersWithIV *ivParams = (OrgBouncycastleCryptoParamsParametersWithIV *) cast_chk(params, [OrgBouncycastleCryptoParamsParametersWithIV class]);
  
#line 107
  IOSByteArray *iv = [((OrgBouncycastleCryptoParamsParametersWithIV *) nil_chk(ivParams)) getIV];
  if (iv == nil || iv->size_ != [self getNonceSize]) {
    
#line 110
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$I$", [self getAlgorithmName], @" requires exactly ", [self getNonceSize], @" bytes of IV"));
  }
  
#line 114
  id<OrgBouncycastleCryptoCipherParameters> keyParam = [ivParams getParameters];
  if (keyParam == nil) {
    
#line 117
    if (!initialised_) {
      
#line 119
      @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", [self getAlgorithmName], @" KeyParameter can not be null for first initialisation"));
    }
    
#line 122
    [self setKeyWithByteArray:nil withByteArray:iv];
  }
  else if ([keyParam isKindOfClass:[OrgBouncycastleCryptoParamsKeyParameter class]]) {
    
#line 126
    [self setKeyWithByteArray:[((OrgBouncycastleCryptoParamsKeyParameter *) keyParam) getKey] withByteArray:iv];
  }
  else {
    
#line 130
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", [self getAlgorithmName], @" Init parameters must contain a KeyParameter (or null for re-init)"));
  }
  
#line 133
  [self reset];
  
#line 135
  initialised_ = true;
}


#line 138
- (jint)getNonceSize {
  
#line 140
  return 8;
}


#line 143
- (NSString *)getAlgorithmName {
  
#line 146
  JavaLangStringBuilder *name = new_JavaLangStringBuilder_initWithNSString_(@"Salsa20");
  if (rounds_ != OrgBouncycastleCryptoEnginesSalsa20Engine_DEFAULT_ROUNDS) {
    
#line 149
    (void) [((JavaLangStringBuilder *) nil_chk([name appendWithNSString:@"/"])) appendWithInt:rounds_];
  }
  return [name description];
}


#line 154
- (jbyte)returnByteWithByte:(jbyte)inArg {
  
#line 157
  if (OrgBouncycastleCryptoEnginesSalsa20Engine_limitExceeded(self)) {
    
#line 159
    @throw new_OrgBouncycastleCryptoMaxBytesExceededException_initWithNSString_(@"2^70 byte limit per IV; Change IV");
  }
  
#line 162
  jbyte out = (jbyte) (IOSByteArray_Get(nil_chk(keyStream_), index_) ^ inArg);
  index_ = (index_ + 1) & 63;
  
#line 165
  if (index_ == 0) {
    
#line 167
    [self advanceCounter];
    [self generateKeyStreamWithByteArray:keyStream_];
  }
  
#line 171
  return out;
}


#line 174
- (void)advanceCounterWithLong:(jlong)diff {
  
#line 176
  jint hi = (jint) (JreURShift64(diff, 32));
  jint lo = (jint) diff;
  
#line 179
  if (hi > 0) {
    
#line 181
    *IOSIntArray_GetRef(nil_chk(engineState_), 9) += hi;
  }
  
#line 184
  jint oldState = IOSIntArray_Get(nil_chk(engineState_), 8);
  
#line 186
  *IOSIntArray_GetRef(engineState_, 8) += lo;
  
#line 188
  if (oldState != 0 && IOSIntArray_Get(engineState_, 8) < oldState) {
    
#line 190
    (*IOSIntArray_GetRef(engineState_, 9))++;
  }
}


#line 194
- (void)advanceCounter {
  
#line 196
  if (++(*IOSIntArray_GetRef(nil_chk(engineState_), 8)) == 0) {
    
#line 198
    ++(*IOSIntArray_GetRef(engineState_, 9));
  }
}


#line 202
- (void)retreatCounterWithLong:(jlong)diff {
  
#line 204
  jint hi = (jint) (JreURShift64(diff, 32));
  jint lo = (jint) diff;
  
#line 207
  if (hi != 0) {
    
#line 209
    if ((IOSIntArray_Get(nil_chk(engineState_), 9) & (jlong) 0xffffffffLL) >= (hi & (jlong) 0xffffffffLL)) {
      
#line 211
      *IOSIntArray_GetRef(engineState_, 9) -= hi;
    }
    else {
      
#line 215
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"attempt to reduce counter past zero.");
    }
  }
  
#line 219
  if ((IOSIntArray_Get(nil_chk(engineState_), 8) & (jlong) 0xffffffffLL) >= (lo & (jlong) 0xffffffffLL)) {
  }
  else if (IOSIntArray_Get(engineState_, 9) != 0) {
    
#line 223
    --(*IOSIntArray_GetRef(engineState_, 9));
  }
  else {
    
#line 227
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"attempt to reduce counter past zero.");
  }
  *IOSIntArray_GetRef(engineState_, 8) -= lo;
}


#line 232
- (void)retreatCounter {
  
#line 234
  if (IOSIntArray_Get(nil_chk(engineState_), 8) == 0 && IOSIntArray_Get(engineState_, 9) == 0) {
    
#line 236
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"attempt to reduce counter past zero.");
  }
  
#line 239
  if (--(*IOSIntArray_GetRef(engineState_, 8)) == -1) {
    
#line 241
    --(*IOSIntArray_GetRef(engineState_, 9));
  }
}


#line 245
- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff {
  
#line 253
  if (!initialised_) {
    
#line 255
    @throw new_JavaLangIllegalStateException_initWithNSString_(JreStrcat("$$", [self getAlgorithmName], @" not initialised"));
  }
  
#line 258
  if (inOff + len > ((IOSByteArray *) nil_chk(inArg))->size_) {
    
#line 260
    @throw new_OrgBouncycastleCryptoDataLengthException_initWithNSString_(@"input buffer too short");
  }
  
#line 263
  if (outOff + len > ((IOSByteArray *) nil_chk(outArg))->size_) {
    
#line 265
    @throw new_OrgBouncycastleCryptoOutputLengthException_initWithNSString_(@"output buffer too short");
  }
  
#line 268
  if (OrgBouncycastleCryptoEnginesSalsa20Engine_limitExceededWithInt_(self, len)) {
    
#line 270
    @throw new_OrgBouncycastleCryptoMaxBytesExceededException_initWithNSString_(@"2^70 byte limit per IV would be exceeded; Change IV");
  }
  
#line 273
  for (jint i = 0; i < len; i++) {
    
#line 275
    *IOSByteArray_GetRef(outArg, i + outOff) = (jbyte) (IOSByteArray_Get(nil_chk(keyStream_), index_) ^ IOSByteArray_Get(inArg, i + inOff));
    index_ = (index_ + 1) & 63;
    
#line 278
    if (index_ == 0) {
      
#line 280
      [self advanceCounter];
      [self generateKeyStreamWithByteArray:keyStream_];
    }
  }
  
#line 285
  return len;
}


#line 288
- (jlong)skipWithLong:(jlong)numberOfBytes {
  
#line 291
  if (numberOfBytes >= 0) {
    
#line 293
    jlong remaining = numberOfBytes;
    
#line 295
    if (remaining >= 64) {
      
#line 297
      jlong count = JreLongDiv(remaining, 64);
      
#line 299
      [self advanceCounterWithLong:count];
      
#line 301
      remaining -= count * 64;
    }
    
#line 304
    jint oldIndex = index_;
    
#line 306
    index_ = (index_ + (jint) remaining) & 63;
    
#line 308
    if (index_ < oldIndex) {
      
#line 310
      [self advanceCounter];
    }
  }
  else {
    
#line 315
    jlong remaining = -numberOfBytes;
    
#line 317
    if (remaining >= 64) {
      
#line 319
      jlong count = JreLongDiv(remaining, 64);
      
#line 321
      [self retreatCounterWithLong:count];
      
#line 323
      remaining -= count * 64;
    }
    
#line 326
    for (jlong i = 0; i < remaining; i++) {
      
#line 328
      if (index_ == 0) {
        
#line 330
        [self retreatCounter];
      }
      
#line 333
      index_ = (index_ - 1) & 63;
    }
  }
  
#line 337
  [self generateKeyStreamWithByteArray:keyStream_];
  
#line 339
  return numberOfBytes;
}


#line 342
- (jlong)seekToWithLong:(jlong)position {
  
#line 345
  [self reset];
  
#line 347
  return [self skipWithLong:position];
}


#line 350
- (jlong)getPosition {
  
#line 353
  return [self getCounter] * 64 + index_;
}

- (void)reset {
  
#line 359
  index_ = 0;
  OrgBouncycastleCryptoEnginesSalsa20Engine_resetLimitCounter(self);
  [self resetCounter];
  
#line 363
  [self generateKeyStreamWithByteArray:keyStream_];
}


#line 366
- (jlong)getCounter {
  
#line 368
  return (JreLShift64((jlong) IOSIntArray_Get(nil_chk(engineState_), 9), 32)) | (IOSIntArray_Get(engineState_, 8) & (jlong) 0xffffffffLL);
}


#line 371
- (void)resetCounter {
  
#line 373
  *IOSIntArray_GetRef(nil_chk(engineState_), 8) = *IOSIntArray_GetRef(engineState_, 9) = 0;
}


#line 376
- (void)setKeyWithByteArray:(IOSByteArray *)keyBytes
              withByteArray:(IOSByteArray *)ivBytes {
  if (keyBytes != nil) {
    
#line 380
    if (keyBytes->size_ != 16 && keyBytes->size_ != 32) {
      
#line 382
      @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", [self getAlgorithmName], @" requires 128 bit or 256 bit key"));
    }
    
#line 385
    jint tsOff = JreIntDiv((keyBytes->size_ - 16), 4);
    *IOSIntArray_GetRef(nil_chk(engineState_), 0) = IOSIntArray_Get(nil_chk(OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA), tsOff);
    *IOSIntArray_GetRef(engineState_, 5) = IOSIntArray_Get(OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA, tsOff + 1);
    *IOSIntArray_GetRef(engineState_, 10) = IOSIntArray_Get(OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA, tsOff + 2);
    *IOSIntArray_GetRef(engineState_, 15) = IOSIntArray_Get(OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA, tsOff + 3);
    
#line 392
    OrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_withIntArray_withInt_withInt_(keyBytes, 0, engineState_, 1, 4);
    OrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_withIntArray_withInt_withInt_(keyBytes, keyBytes->size_ - 16, engineState_, 11, 4);
  }
  
#line 397
  OrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_withIntArray_withInt_withInt_(ivBytes, 0, engineState_, 6, 2);
}


#line 400
- (void)generateKeyStreamWithByteArray:(IOSByteArray *)output {
  
#line 402
  OrgBouncycastleCryptoEnginesSalsa20Engine_salsaCoreWithInt_withIntArray_withIntArray_(rounds_, engineState_, x_);
  OrgBouncycastleUtilPack_intToLittleEndianWithIntArray_withByteArray_withInt_(x_, output, 0);
}


#line 411
+ (void)salsaCoreWithInt:(jint)rounds
            withIntArray:(IOSIntArray *)input
            withIntArray:(IOSIntArray *)x {
  OrgBouncycastleCryptoEnginesSalsa20Engine_salsaCoreWithInt_withIntArray_withIntArray_(rounds, input, x);
}


#line 494
- (void)resetLimitCounter {
  OrgBouncycastleCryptoEnginesSalsa20Engine_resetLimitCounter(self);
}


#line 501
- (jboolean)limitExceeded {
  return OrgBouncycastleCryptoEnginesSalsa20Engine_limitExceeded(self);
}


#line 514
- (jboolean)limitExceededWithInt:(jint)len {
  return OrgBouncycastleCryptoEnginesSalsa20Engine_limitExceededWithInt_(self, len);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x4, 0, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "B", 0x1, 5, 6, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 7, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 9, 8, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 12, 8, -1, -1, -1, -1 },
    { NULL, "J", 0x1, 13, 8, -1, -1, -1, -1 },
    { NULL, "J", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "J", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 14, 15, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 16, 17, -1, -1, -1, -1 },
    { NULL, "V", 0x9, 18, 19, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 20, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(packTauOrSigmaWithInt:withIntArray:withInt:);
  methods[1].selector = @selector(init);
  methods[2].selector = @selector(initWithInt:);
  methods[3].selector = @selector(init__WithBoolean:withOrgBouncycastleCryptoCipherParameters:);
  methods[4].selector = @selector(getNonceSize);
  methods[5].selector = @selector(getAlgorithmName);
  methods[6].selector = @selector(returnByteWithByte:);
  methods[7].selector = @selector(advanceCounterWithLong:);
  methods[8].selector = @selector(advanceCounter);
  methods[9].selector = @selector(retreatCounterWithLong:);
  methods[10].selector = @selector(retreatCounter);
  methods[11].selector = @selector(processBytesWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[12].selector = @selector(skipWithLong:);
  methods[13].selector = @selector(seekToWithLong:);
  methods[14].selector = @selector(getPosition);
  methods[15].selector = @selector(reset);
  methods[16].selector = @selector(getCounter);
  methods[17].selector = @selector(resetCounter);
  methods[18].selector = @selector(setKeyWithByteArray:withByteArray:);
  methods[19].selector = @selector(generateKeyStreamWithByteArray:);
  methods[20].selector = @selector(salsaCoreWithInt:withIntArray:withIntArray:);
  methods[21].selector = @selector(resetLimitCounter);
  methods[22].selector = @selector(limitExceeded);
  methods[23].selector = @selector(limitExceededWithInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "DEFAULT_ROUNDS", "I", .constantValue.asInt = OrgBouncycastleCryptoEnginesSalsa20Engine_DEFAULT_ROUNDS, 0x19, -1, -1, -1, -1 },
    { "STATE_SIZE", "I", .constantValue.asInt = OrgBouncycastleCryptoEnginesSalsa20Engine_STATE_SIZE, 0x1a, -1, -1, -1, -1 },
    { "TAU_SIGMA", "[I", .constantValue.asLong = 0, 0x1a, -1, 21, -1, -1 },
    { "sigma", "[B", .constantValue.asLong = 0, 0x1c, -1, 22, -1, 23 },
    { "tau", "[B", .constantValue.asLong = 0, 0x1c, -1, 24, -1, 25 },
    { "rounds_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "index_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "engineState_", "[I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "x_", "[I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "keyStream_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "initialised_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "cW0_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "cW1_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "cW2_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "packTauOrSigma", "I[II", "I", "init", "ZLOrgBouncycastleCryptoCipherParameters;", "returnByte", "B", "advanceCounter", "J", "retreatCounter", "processBytes", "[BII[BI", "skip", "seekTo", "setKey", "[B[B", "generateKeyStream", "[B", "salsaCore", "I[I[I", "limitExceeded", &OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA, &OrgBouncycastleCryptoEnginesSalsa20Engine_sigma, (void *)&OrgBouncycastleCryptoEnginesSalsa20Engine__Annotations$0, &OrgBouncycastleCryptoEnginesSalsa20Engine_tau, (void *)&OrgBouncycastleCryptoEnginesSalsa20Engine__Annotations$1 };
  static const J2ObjcClassInfo _OrgBouncycastleCryptoEnginesSalsa20Engine = { "Salsa20Engine", "org.bouncycastle.crypto.engines", ptrTable, methods, fields, 7, 0x1, 24, 14, -1, -1, -1, -1, -1 };
  return &_OrgBouncycastleCryptoEnginesSalsa20Engine;
}

+ (void)initialize {
  if (self == [OrgBouncycastleCryptoEnginesSalsa20Engine class]) {
    OrgBouncycastleCryptoEnginesSalsa20Engine_TAU_SIGMA = OrgBouncycastleUtilPack_littleEndianToIntWithByteArray_withInt_withInt_(OrgBouncycastleUtilStrings_toByteArrayWithNSString_(
#line 25
    @"expand 16-byte kexpand 32-byte k"), 0, 8);
    OrgBouncycastleCryptoEnginesSalsa20Engine_sigma = OrgBouncycastleUtilStrings_toByteArrayWithNSString_(
#line 39
    @"expand 32-byte k");
    OrgBouncycastleCryptoEnginesSalsa20Engine_tau = OrgBouncycastleUtilStrings_toByteArrayWithNSString_(
#line 40
    @"expand 16-byte k");
    J2OBJC_SET_INITIALIZED(OrgBouncycastleCryptoEnginesSalsa20Engine)
  }
}

@end


#line 62
void OrgBouncycastleCryptoEnginesSalsa20Engine_init(OrgBouncycastleCryptoEnginesSalsa20Engine *self) {
  OrgBouncycastleCryptoEnginesSalsa20Engine_initWithInt_(self, OrgBouncycastleCryptoEnginesSalsa20Engine_DEFAULT_ROUNDS);
}


#line 62
OrgBouncycastleCryptoEnginesSalsa20Engine *new_OrgBouncycastleCryptoEnginesSalsa20Engine_init() {
  J2OBJC_NEW_IMPL(OrgBouncycastleCryptoEnginesSalsa20Engine, init)
}


#line 62
OrgBouncycastleCryptoEnginesSalsa20Engine *create_OrgBouncycastleCryptoEnginesSalsa20Engine_init() {
  J2OBJC_CREATE_IMPL(OrgBouncycastleCryptoEnginesSalsa20Engine, init)
}


#line 71
void OrgBouncycastleCryptoEnginesSalsa20Engine_initWithInt_(OrgBouncycastleCryptoEnginesSalsa20Engine *self, jint rounds) {
  NSObject_init(self);
  self->index_ =
#line 48
  0;
  self->engineState_ = [IOSIntArray newArrayWithLength:OrgBouncycastleCryptoEnginesSalsa20Engine_STATE_SIZE];
  self->x_ = [IOSIntArray newArrayWithLength:OrgBouncycastleCryptoEnginesSalsa20Engine_STATE_SIZE];
  self->keyStream_ = [IOSByteArray newArrayWithLength:OrgBouncycastleCryptoEnginesSalsa20Engine_STATE_SIZE * 4];
  self->initialised_ = false;
  
#line 73
  if (rounds <= 0 || (rounds & 1) != 0) {
    
#line 75
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"'rounds' must be a positive, even number");
  }
  
#line 78
  self->rounds_ = rounds;
}


#line 71
OrgBouncycastleCryptoEnginesSalsa20Engine *new_OrgBouncycastleCryptoEnginesSalsa20Engine_initWithInt_(jint rounds) {
  J2OBJC_NEW_IMPL(OrgBouncycastleCryptoEnginesSalsa20Engine, initWithInt_, rounds)
}


#line 71
OrgBouncycastleCryptoEnginesSalsa20Engine *create_OrgBouncycastleCryptoEnginesSalsa20Engine_initWithInt_(jint rounds) {
  J2OBJC_CREATE_IMPL(OrgBouncycastleCryptoEnginesSalsa20Engine, initWithInt_, rounds)
}


#line 411
void OrgBouncycastleCryptoEnginesSalsa20Engine_salsaCoreWithInt_withIntArray_withIntArray_(jint rounds, IOSIntArray *input, IOSIntArray *x) {
  OrgBouncycastleCryptoEnginesSalsa20Engine_initialize();
  if ((((IOSIntArray *) nil_chk(input))->size_ != 16) || (((IOSIntArray *) nil_chk(x))->size_ != 16)) {
    
#line 415
    @throw new_JavaLangIllegalArgumentException_init();
  }
  if (JreIntMod(rounds, 2) != 0) {
    
#line 419
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Number of rounds must be even");
  }
  
#line 422
  jint x00 = IOSIntArray_Get(input, 0);
  jint x01 = IOSIntArray_Get(input, 1);
  jint x02 = IOSIntArray_Get(input, 2);
  jint x03 = IOSIntArray_Get(input, 3);
  jint x04 = IOSIntArray_Get(input, 4);
  jint x05 = IOSIntArray_Get(input, 5);
  jint x06 = IOSIntArray_Get(input, 6);
  jint x07 = IOSIntArray_Get(input, 7);
  jint x08 = IOSIntArray_Get(input, 8);
  jint x09 = IOSIntArray_Get(input, 9);
  jint x10 = IOSIntArray_Get(input, 10);
  jint x11 = IOSIntArray_Get(input, 11);
  jint x12 = IOSIntArray_Get(input, 12);
  jint x13 = IOSIntArray_Get(input, 13);
  jint x14 = IOSIntArray_Get(input, 14);
  jint x15 = IOSIntArray_Get(input, 15);
  
#line 439
  for (jint i = rounds; i > 0; i -= 2) {
    
#line 441
    x04 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x00 + x12, 7);
    x08 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x04 + x00, 9);
    x12 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x08 + x04, 13);
    x00 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x12 + x08, 18);
    x09 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x05 + x01, 7);
    x13 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x09 + x05, 9);
    x01 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x13 + x09, 13);
    x05 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x01 + x13, 18);
    x14 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x10 + x06, 7);
    x02 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x14 + x10, 9);
    x06 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x02 + x14, 13);
    x10 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x06 + x02, 18);
    x03 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x15 + x11, 7);
    x07 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x03 + x15, 9);
    x11 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x07 + x03, 13);
    x15 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x11 + x07, 18);
    
#line 458
    x01 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x00 + x03, 7);
    x02 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x01 + x00, 9);
    x03 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x02 + x01, 13);
    x00 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x03 + x02, 18);
    x06 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x05 + x04, 7);
    x07 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x06 + x05, 9);
    x04 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x07 + x06, 13);
    x05 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x04 + x07, 18);
    x11 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x10 + x09, 7);
    x08 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x11 + x10, 9);
    x09 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x08 + x11, 13);
    x10 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x09 + x08, 18);
    x12 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x15 + x14, 7);
    x13 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x12 + x15, 9);
    x14 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x13 + x12, 13);
    x15 ^= OrgBouncycastleUtilIntegers_rotateLeftWithInt_withInt_(x14 + x13, 18);
  }
  
#line 476
  *IOSIntArray_GetRef(nil_chk(x), 0) = x00 + IOSIntArray_Get(input, 0);
  *IOSIntArray_GetRef(x, 1) = x01 + IOSIntArray_Get(input, 1);
  *IOSIntArray_GetRef(x, 2) = x02 + IOSIntArray_Get(input, 2);
  *IOSIntArray_GetRef(x, 3) = x03 + IOSIntArray_Get(input, 3);
  *IOSIntArray_GetRef(x, 4) = x04 + IOSIntArray_Get(input, 4);
  *IOSIntArray_GetRef(x, 5) = x05 + IOSIntArray_Get(input, 5);
  *IOSIntArray_GetRef(x, 6) = x06 + IOSIntArray_Get(input, 6);
  *IOSIntArray_GetRef(x, 7) = x07 + IOSIntArray_Get(input, 7);
  *IOSIntArray_GetRef(x, 8) = x08 + IOSIntArray_Get(input, 8);
  *IOSIntArray_GetRef(x, 9) = x09 + IOSIntArray_Get(input, 9);
  *IOSIntArray_GetRef(x, 10) = x10 + IOSIntArray_Get(input, 10);
  *IOSIntArray_GetRef(x, 11) = x11 + IOSIntArray_Get(input, 11);
  *IOSIntArray_GetRef(x, 12) = x12 + IOSIntArray_Get(input, 12);
  *IOSIntArray_GetRef(x, 13) = x13 + IOSIntArray_Get(input, 13);
  *IOSIntArray_GetRef(x, 14) = x14 + IOSIntArray_Get(input, 14);
  *IOSIntArray_GetRef(x, 15) = x15 + IOSIntArray_Get(input, 15);
}


#line 494
void OrgBouncycastleCryptoEnginesSalsa20Engine_resetLimitCounter(OrgBouncycastleCryptoEnginesSalsa20Engine *self) {
  
#line 496
  self->cW0_ = 0;
  self->cW1_ = 0;
  self->cW2_ = 0;
}


#line 501
jboolean OrgBouncycastleCryptoEnginesSalsa20Engine_limitExceeded(OrgBouncycastleCryptoEnginesSalsa20Engine *self) {
  
#line 503
  if ((++self->cW0_ == 0) && (++self->cW1_ == 0)) {
    
#line 505
    return (++self->cW2_ & (jint) 0x20) != 0;
  }
  
#line 508
  return false;
}

jboolean OrgBouncycastleCryptoEnginesSalsa20Engine_limitExceededWithInt_(OrgBouncycastleCryptoEnginesSalsa20Engine *self, jint len) {
  
#line 516
  self->cW0_ += len;
  if ((self->cW0_ < len && self->cW0_ >= 0) && (++self->cW1_ == 0)) {
    
#line 519
    return (++self->cW2_ & (jint) 0x20) != 0;
  }
  
#line 522
  return false;
}

IOSObjectArray *OrgBouncycastleCryptoEnginesSalsa20Engine__Annotations$0() {
  return [IOSObjectArray newArrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

IOSObjectArray *OrgBouncycastleCryptoEnginesSalsa20Engine__Annotations$1() {
  return [IOSObjectArray newArrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgBouncycastleCryptoEnginesSalsa20Engine)
