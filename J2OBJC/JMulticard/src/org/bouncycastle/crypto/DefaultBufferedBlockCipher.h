//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/crypto/DefaultBufferedBlockCipher.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgBouncycastleCryptoDefaultBufferedBlockCipher")
#ifdef RESTRICT_OrgBouncycastleCryptoDefaultBufferedBlockCipher
#define INCLUDE_ALL_OrgBouncycastleCryptoDefaultBufferedBlockCipher 0
#else
#define INCLUDE_ALL_OrgBouncycastleCryptoDefaultBufferedBlockCipher 1
#endif
#undef RESTRICT_OrgBouncycastleCryptoDefaultBufferedBlockCipher

#if !defined (OrgBouncycastleCryptoDefaultBufferedBlockCipher_) && (INCLUDE_ALL_OrgBouncycastleCryptoDefaultBufferedBlockCipher || defined(INCLUDE_OrgBouncycastleCryptoDefaultBufferedBlockCipher))
#define OrgBouncycastleCryptoDefaultBufferedBlockCipher_

#define RESTRICT_OrgBouncycastleCryptoBufferedBlockCipher 1
#define INCLUDE_OrgBouncycastleCryptoBufferedBlockCipher 1
#include "org/bouncycastle/crypto/BufferedBlockCipher.h"

@class IOSByteArray;
@protocol OrgBouncycastleCryptoBlockCipher;
@protocol OrgBouncycastleCryptoCipherParameters;
@protocol OrgBouncycastleCryptoMultiBlockCipher;

/*!
 @brief A wrapper class that allows block ciphers to be used to process data in
  a piecemeal fashion.The BufferedBlockCipher outputs a block only when the
  buffer is full and more data is being added, or on a doFinal.
 <p>
  Note: in the case where the underlying cipher is either a CFB cipher or an
  OFB one the last block may not be a multiple of the block size. Use this class
  for construction rather than BufferedBlockCipher as BufferedBlockCipher will eventually
  turn into an interface.
 */
@interface OrgBouncycastleCryptoDefaultBufferedBlockCipher : OrgBouncycastleCryptoBufferedBlockCipher {
 @public
  IOSByteArray *buf_DefaultBufferedBlockCipher_;
  jint bufOff_DefaultBufferedBlockCipher_;
  jboolean forEncryption_DefaultBufferedBlockCipher_;
  id<OrgBouncycastleCryptoBlockCipher> cipher_DefaultBufferedBlockCipher_;
  id<OrgBouncycastleCryptoMultiBlockCipher> mbCipher_;
  jboolean partialBlockOkay_DefaultBufferedBlockCipher_;
  jboolean pgpCFB_DefaultBufferedBlockCipher_;
}

#pragma mark Public

/*!
 @brief Create a buffered block cipher without padding.
 @param cipher the underlying block cipher this buffering object wraps.
 */
- (instancetype)initWithOrgBouncycastleCryptoBlockCipher:(id<OrgBouncycastleCryptoBlockCipher>)cipher;

/*!
 @brief Process the last block in the buffer.
 @param outArg the array the block currently being held is copied into.
 @param outOff the offset at which the copying starts.
 @return the number of output bytes copied to out.
 @throw DataLengthExceptionif there is insufficient space in out for
  the output, or the input is not block size aligned and should be.
 @throw IllegalStateExceptionif the underlying cipher is not
  initialised.
 @throw InvalidCipherTextExceptionif padding is expected and not found.
 @throw DataLengthExceptionif the input is not block size
  aligned.
 */
- (jint)doFinalWithByteArray:(IOSByteArray *)outArg
                     withInt:(jint)outOff;

/*!
 @brief return the blocksize for the underlying cipher.
 @return the blocksize for the underlying cipher.
 */
- (jint)getBlockSize;

/*!
 @brief return the size of the output buffer required for an update plus a
  doFinal with an input of 'length' bytes.
 @param length the length of the input.
 @return the space required to accommodate a call to update and doFinal
  with 'length' bytes of input.
 */
- (jint)getOutputSizeWithInt:(jint)length;

/*!
 @brief return the cipher this object wraps.
 @return the cipher this object wraps.
 */
- (id<OrgBouncycastleCryptoBlockCipher>)getUnderlyingCipher;

/*!
 @brief return the size of the output buffer required for an update 
  an input of len bytes.
 @param len the length of the input.
 @return the space required to accommodate a call to update
  with len bytes of input.
 */
- (jint)getUpdateOutputSizeWithInt:(jint)len;

/*!
 @brief initialise the cipher.
 @param forEncryption if true the cipher is initialised for   encryption, if false for decryption.
 @param params the key and other data required by the cipher.
 @throw IllegalArgumentExceptionif the params argument is
  inappropriate.
 */
- (void)init__WithBoolean:(jboolean)forEncryption
withOrgBouncycastleCryptoCipherParameters:(id<OrgBouncycastleCryptoCipherParameters>)params OBJC_METHOD_FAMILY_NONE;

/*!
 @brief process a single byte, producing an output block if necessary.
 @param inArg the input byte.
 @param outArg the space for any output that might be produced.
 @param outOff the offset from which the output will be copied.
 @return the number of output bytes copied to out.
 @throw DataLengthExceptionif there isn't enough space in out.
 @throw IllegalStateExceptionif the cipher isn't initialised.
 */
- (jint)processByteWithByte:(jbyte)inArg
              withByteArray:(IOSByteArray *)outArg
                    withInt:(jint)outOff;

/*!
 @brief process an array of bytes, producing output if necessary.
 @param inArg the input byte array.
 @param inOff the offset at which the input data starts.
 @param len the number of bytes to be copied out of the input array.
 @param outArg the space for any output that might be produced.
 @param outOff the offset from which the output will be copied.
 @return the number of output bytes copied to out.
 @throw DataLengthExceptionif there isn't enough space in out.
 @throw IllegalStateExceptionif the cipher isn't initialised.
 */
- (jint)processBytesWithByteArray:(IOSByteArray *)inArg
                          withInt:(jint)inOff
                          withInt:(jint)len
                    withByteArray:(IOSByteArray *)outArg
                          withInt:(jint)outOff;

/*!
 @brief Reset the buffer and cipher.After resetting the object is in the same
  state as it was after the last init (if there was one).
 */
- (void)reset;

#pragma mark Protected

/*!
 @brief constructor for subclasses
 */
- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgBouncycastleCryptoDefaultBufferedBlockCipher)

J2OBJC_FIELD_SETTER(OrgBouncycastleCryptoDefaultBufferedBlockCipher, buf_DefaultBufferedBlockCipher_, IOSByteArray *)
J2OBJC_FIELD_SETTER(OrgBouncycastleCryptoDefaultBufferedBlockCipher, cipher_DefaultBufferedBlockCipher_, id<OrgBouncycastleCryptoBlockCipher>)
J2OBJC_FIELD_SETTER(OrgBouncycastleCryptoDefaultBufferedBlockCipher, mbCipher_, id<OrgBouncycastleCryptoMultiBlockCipher>)

FOUNDATION_EXPORT void OrgBouncycastleCryptoDefaultBufferedBlockCipher_init(OrgBouncycastleCryptoDefaultBufferedBlockCipher *self);

FOUNDATION_EXPORT OrgBouncycastleCryptoDefaultBufferedBlockCipher *new_OrgBouncycastleCryptoDefaultBufferedBlockCipher_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgBouncycastleCryptoDefaultBufferedBlockCipher *create_OrgBouncycastleCryptoDefaultBufferedBlockCipher_init(void);

FOUNDATION_EXPORT void OrgBouncycastleCryptoDefaultBufferedBlockCipher_initWithOrgBouncycastleCryptoBlockCipher_(OrgBouncycastleCryptoDefaultBufferedBlockCipher *self, id<OrgBouncycastleCryptoBlockCipher> cipher);

FOUNDATION_EXPORT OrgBouncycastleCryptoDefaultBufferedBlockCipher *new_OrgBouncycastleCryptoDefaultBufferedBlockCipher_initWithOrgBouncycastleCryptoBlockCipher_(id<OrgBouncycastleCryptoBlockCipher> cipher) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgBouncycastleCryptoDefaultBufferedBlockCipher *create_OrgBouncycastleCryptoDefaultBufferedBlockCipher_initWithOrgBouncycastleCryptoBlockCipher_(id<OrgBouncycastleCryptoBlockCipher> cipher);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastleCryptoDefaultBufferedBlockCipher)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgBouncycastleCryptoDefaultBufferedBlockCipher")
