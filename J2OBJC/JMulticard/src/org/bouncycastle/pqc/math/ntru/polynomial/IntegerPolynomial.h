//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/org/bouncycastle/pqc/math/ntru/polynomial/IntegerPolynomial.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial")
#ifdef RESTRICT_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial
#define INCLUDE_ALL_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial 0
#else
#define INCLUDE_ALL_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial 1
#endif
#undef RESTRICT_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial

#if !defined (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_) && (INCLUDE_ALL_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial || defined(INCLUDE_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial))
#define OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_

#define RESTRICT_OrgBouncycastlePqcMathNtruPolynomialPolynomial 1
#define INCLUDE_OrgBouncycastlePqcMathNtruPolynomialPolynomial 1
#include "org/bouncycastle/pqc/math/ntru/polynomial/Polynomial.h"

@class IOSByteArray;
@class IOSIntArray;
@class JavaIoInputStream;
@class OrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial;
@class OrgBouncycastlePqcMathNtruPolynomialModularResultant;
@class OrgBouncycastlePqcMathNtruPolynomialResultant;

/*!
 @brief A polynomial with <code>int</code> coefficients.
 <br>
  Some methods (like <code>add</code>) change the polynomial, others (like <code>mult</code>) do
  not but return the result as a new polynomial.
 */
@interface OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial : NSObject < OrgBouncycastlePqcMathNtruPolynomialPolynomial > {
 @public
  IOSIntArray *coeffs_;
}

#pragma mark Public

/*!
 @brief Constructs a <code>IntegerPolynomial</code> from a <code>BigIntPolynomial</code>.The two polynomials are independent of each other.
 @param p the original polynomial
 */
- (instancetype)initWithOrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial:(OrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial *)p;

/*!
 @brief Constructs a new polynomial with <code>N</code> coefficients initialized to 0.
 @param N the number of coefficients
 */
- (instancetype)initWithInt:(jint)N;

/*!
 @brief Constructs a new polynomial with a given set of coefficients.
 @param coeffs the coefficients
 */
- (instancetype)initWithIntArray:(IOSIntArray *)coeffs;

/*!
 @brief Adds another polynomial which can have a different number of coefficients.
 @param b another polynomial
 */
- (void)addWithOrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial:(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)b;

/*!
 @brief Adds another polynomial which can have a different number of coefficients,
  and takes the coefficient values mod <code>modulus</code>.
 @param b another polynomial
 */
- (void)addWithOrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial:(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)b
                                                             withInt:(jint)modulus;

/*!
 @brief Shifts the values of all coefficients to the interval <code>[-q/2, q/2]</code>.
 @param q a modulus
 */
- (void)center0WithInt:(jint)q;

/*!
 @brief Computes the centered euclidean norm of the polynomial.
 @param q a modulus
 @return the centered norm
 */
- (jlong)centeredNormSqWithInt:(jint)q;

- (void)clear;

- (id)java_clone;

/*!
 @brief Counts the number of coefficients equal to an integer
 @param value an integer
 @return the number of coefficients equal to <code>value</code>
 */
- (jint)countWithInt:(jint)value;

/*!
 @brief Divides each coefficient by <code>k</code> and rounds to the nearest integer.Does not return a new polynomial but modifies this polynomial.
 @param k the divisor
 */
- (void)divWithInt:(jint)k;

/*!
 @brief Adds <code>modulus</code> until all coefficients are above 0.
 @param modulus a modulus
 */
- (void)ensurePositiveWithInt:(jint)modulus;

- (jboolean)isEqual:(id)obj;

/*!
 @brief Tests if <code>p(x) = 1</code>.
 @return true iff all coefficients are equal to zero, except for the lowest coefficient which must equal 1
 */
- (jboolean)equalsOne;

/*!
 @brief Returns a polynomial with N coefficients between <code>0</code> and <code>q-1</code>.
 <br>
  <code>q</code> must be a power of 2.<br>
  Ignores any excess bytes.
 @param data an encoded ternary polynomial
 @param N number of coefficients
 @param q
 @return the decoded polynomial
 */
+ (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)fromBinaryWithByteArray:(IOSByteArray *)data
                                                                           withInt:(jint)N
                                                                           withInt:(jint)q;

/*!
 @brief Returns a polynomial with N coefficients between <code>0</code> and <code>q-1</code>.
 <br>
  <code>q</code> must be a power of 2.<br>
  Ignores any excess bytes.
 @param is an encoded ternary polynomial
 @param N number of coefficients
 @param q
 @return the decoded polynomial
 */
+ (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)fromBinaryWithJavaIoInputStream:(JavaIoInputStream *)is
                                                                                   withInt:(jint)N
                                                                                   withInt:(jint)q;

/*!
 @brief Decodes a byte array to a polynomial with <code>N</code> ternary coefficients<br>
  Ignores any excess bytes.
 @param data an encoded ternary polynomial
 @param N number of coefficients
 @return the decoded polynomial
 */
+ (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)fromBinary3SvesWithByteArray:(IOSByteArray *)data
                                                                                withInt:(jint)N;

/*!
 @brief Converts a byte array produced by <code>toBinary3Tight()</code> to a polynomial.
 @param b a byte array
 @param N number of coefficients
 @return the decoded polynomial
 */
+ (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)fromBinary3TightWithByteArray:(IOSByteArray *)b
                                                                                 withInt:(jint)N;

/*!
 @brief Reads data produced by <code>toBinary3Tight()</code> from an input stream and converts it to a polynomial.
 @param is an input stream
 @param N number of coefficients
 @return the decoded polynomial
 */
+ (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)fromBinary3TightWithJavaIoInputStream:(JavaIoInputStream *)is
                                                                                         withInt:(jint)N;

/*!
 @brief Computes the inverse mod 3.
 Returns <code>null</code> if the polynomial is not invertible.
 @return a new polynomial
 */
- (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)invertF3;

/*!
 @brief Computes the inverse mod <code>q; q</code> must be a power of 2.
 <br>
  Returns <code>null</code> if the polynomial is not invertible.
 @param q the modulus
 @return a new polynomial
 */
- (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)invertFqWithInt:(jint)q;

/*!
 @brief Takes each coefficient modulo <code>modulus</code>.
 */
- (void)modWithInt:(jint)modulus;

/*!
 @brief Takes each coefficient modulo 3 such that all coefficients are ternary.
 */
- (void)mod3;

/*!
 @brief Ensures all coefficients are between 0 and <code>modulus-1</code>
 @param modulus a modulus
 */
- (void)modPositiveWithInt:(jint)modulus;

- (OrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial *)multWithOrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial:(OrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial *)poly2;

/*!
 @brief Multiplies each coefficient by a <code>int</code>.Does not return a new polynomial but modifies this polynomial.
 @param factor
 */
- (void)multWithInt:(jint)factor;

/*!
 @brief Multiplies the polynomial with another, taking the indices mod N
 */
- (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)multWithOrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial:(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)poly2;

/*!
 @brief Multiplies the polynomial with another, taking the values mod modulus and the indices mod N
 */
- (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)multWithOrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial:(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)poly2
                                                                                                                 withInt:(jint)modulus;

/*!
 @brief Multiplies each coefficient by a 2 and applies a modulus.Does not return a new polynomial but modifies this polynomial.
 @param modulus a modulus
 */
- (void)mult3WithInt:(jint)modulus;

/*!
 @brief Resultant of this polynomial with <code>x^n-1</code> using a probabilistic algorithm.
 <p>
  Unlike EESS, this implementation does not compute all resultants modulo primes
  such that their product exceeds the maximum possible resultant, but rather stops
  when <code>NUM_EQUAL_RESULTANTS</code> consecutive modular resultants are equal.<br>
  This means the return value may be incorrect. Experiments show this happens in
  about 1 out of 100 cases when <code>N=439</code> and <code>NUM_EQUAL_RESULTANTS=2</code>,
  so the likelyhood of leaving the loop too early is <code>(1/100)^(NUM_EQUAL_RESULTANTS-1)</code>.
  <p>
  Because of the above, callers must verify the output and try a different polynomial if necessary.
 @return <code>(rho, res)</code> satisfying <code>res = rho*this + t*(x^n-1)</code> for some integer <code>t</code>.
 */
- (OrgBouncycastlePqcMathNtruPolynomialResultant *)resultant;

/*!
 @brief Resultant of this polynomial with <code>x^n-1 mod p</code>.
 @return <code>(rho, res)</code> satisfying <code>res = rho*this + t*(x^n-1) mod p</code> for some integer <code>t</code>.
 */
- (OrgBouncycastlePqcMathNtruPolynomialModularResultant *)resultantWithInt:(jint)p;

/*!
 @brief Multithreaded version of <code>resultant()</code>.
 @return <code>(rho, res)</code> satisfying <code>res = rho*this + t*(x^n-1)</code> for some integer <code>t</code>.
 */
- (OrgBouncycastlePqcMathNtruPolynomialResultant *)resultantMultiThread;

/*!
 @brief Multiplication by <code>X</code> in <code>Z[X]/Z[X^n-1]</code>.
 */
- (void)rotate1;

/*!
 @brief Subtracts another polynomial which can have a different number of coefficients.
 @param b another polynomial
 */
- (void)subWithOrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial:(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)b;

/*!
 @brief Subtracts another polynomial which can have a different number of coefficients,
  and takes the coefficient values mod <code>modulus</code>.
 @param b another polynomial
 */
- (void)subWithOrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial:(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)b
                                                             withInt:(jint)modulus;

/*!
 @brief Returns the sum of all coefficients, i.e.evaluates the polynomial at 0.
 @return the sum of all coefficients
 */
- (jint)sumCoeffs;

/*!
 @brief Encodes a polynomial whose coefficients are between 0 and q, to binary.q must be a power of 2.
 @param q
 @return the encoded polynomial
 */
- (IOSByteArray *)toBinaryWithInt:(jint)q;

/*!
 @brief Encodes a polynomial with ternary coefficients to binary.
 <code>coeffs[2*i]</code> and <code>coeffs[2*i+1]</code> must not both equal -1 for any integer <code>i</code>,
  so this method is only safe to use with polynomials produced by <code>fromBinary3Sves()</code>.
 @return the encoded polynomial
 */
- (IOSByteArray *)toBinary3Sves;

/*!
 @brief Converts a polynomial with ternary coefficients to binary.
 @return the encoded polynomial
 */
- (IOSByteArray *)toBinary3Tight;

- (OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *)toIntegerPolynomial;

#pragma mark Package-Private

/*!
 @brief Returns the degree of the polynomial
 @return the degree
 */
- (jint)degree;

/*!
 @brief Reduces all coefficients to the interval [-modulus/2, modulus/2)
 */
- (void)modCenterWithInt:(jint)modulus;

/*!
 @brief Shifts all coefficients so the largest gap is centered around <code>-q/2</code>.
 @param q a modulus
 */
- (void)shiftGapWithInt:(jint)q;

/*!
 @brief Subtracts a <code>int</code> from each coefficient.Does not return a new polynomial but modifies this polynomial.
 @param b
 */
- (void)subWithInt:(jint)b;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial)

J2OBJC_FIELD_SETTER(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial, coeffs_, IOSIntArray *)

FOUNDATION_EXPORT void OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithInt_(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *self, jint N);

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *new_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithInt_(jint N) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *create_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithInt_(jint N);

FOUNDATION_EXPORT void OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithIntArray_(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *self, IOSIntArray *coeffs);

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *new_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithIntArray_(IOSIntArray *coeffs) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *create_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithIntArray_(IOSIntArray *coeffs);

FOUNDATION_EXPORT void OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithOrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial_(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *self, OrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial *p);

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *new_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithOrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial_(OrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial *p) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *create_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_initWithOrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial_(OrgBouncycastlePqcMathNtruPolynomialBigIntPolynomial *p);

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_fromBinary3SvesWithByteArray_withInt_(IOSByteArray *data, jint N);

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_fromBinary3TightWithByteArray_withInt_(IOSByteArray *b, jint N);

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_fromBinary3TightWithJavaIoInputStream_withInt_(JavaIoInputStream *is, jint N);

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_fromBinaryWithByteArray_withInt_withInt_(IOSByteArray *data, jint N, jint q);

FOUNDATION_EXPORT OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial *OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial_fromBinaryWithJavaIoInputStream_withInt_withInt_(JavaIoInputStream *is, jint N, jint q);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgBouncycastlePqcMathNtruPolynomialIntegerPolynomial")
