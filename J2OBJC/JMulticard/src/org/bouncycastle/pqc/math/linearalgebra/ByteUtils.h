//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/pqc/math/linearalgebra/ByteUtils.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgBouncycastlePqcMathLinearalgebraByteUtils")
#ifdef RESTRICT_OrgBouncycastlePqcMathLinearalgebraByteUtils
#define INCLUDE_ALL_OrgBouncycastlePqcMathLinearalgebraByteUtils 0
#else
#define INCLUDE_ALL_OrgBouncycastlePqcMathLinearalgebraByteUtils 1
#endif
#undef RESTRICT_OrgBouncycastlePqcMathLinearalgebraByteUtils

#if !defined (OrgBouncycastlePqcMathLinearalgebraByteUtils_) && (INCLUDE_ALL_OrgBouncycastlePqcMathLinearalgebraByteUtils || defined(INCLUDE_OrgBouncycastlePqcMathLinearalgebraByteUtils))
#define OrgBouncycastlePqcMathLinearalgebraByteUtils_

@class IOSByteArray;
@class IOSCharArray;
@class IOSObjectArray;

/*!
 @brief This class is a utility class for manipulating byte arrays.
 */
@interface OrgBouncycastlePqcMathLinearalgebraByteUtils : NSObject

#pragma mark Public

/*!
 @brief Return a clone of the given byte array (performs null check beforehand).
 @param array the array to clone
 @return the clone of the given array, or <tt>null</tt> if the array is
          <tt>null</tt>
 */
+ (IOSByteArray *)cloneWithByteArray:(IOSByteArray *)array;

/*!
 @brief Concatenate two byte arrays.No null checks are performed.
 @param x1 the first array
 @param x2 the second array
 @return (x2||x1) (little-endian order, i.e. x1 is at lower memory
          addresses)
 */
+ (IOSByteArray *)concatenateWithByteArray:(IOSByteArray *)x1
                             withByteArray:(IOSByteArray *)x2;

/*!
 @brief Convert a 2-dimensional byte array into a 1-dimensional byte array by
  concatenating all entries.
 @param array a 2-dimensional byte array
 @return the concatenated input array
 */
+ (IOSByteArray *)concatenateWithByteArray2:(IOSObjectArray *)array;

/*!
 @brief Computes a hashcode based on the contents of a one-dimensional byte array
  rather than its identity.
 @param array the array to compute the hashcode of
 @return the hashcode
 */
+ (jint)deepHashCodeWithByteArray:(IOSByteArray *)array;

/*!
 @brief Computes a hashcode based on the contents of a two-dimensional byte array
  rather than its identity.
 @param array the array to compute the hashcode of
 @return the hashcode
 */
+ (jint)deepHashCodeWithByteArray2:(IOSObjectArray *)array;

/*!
 @brief Computes a hashcode based on the contents of a three-dimensional byte
  array rather than its identity.
 @param array the array to compute the hashcode of
 @return the hashcode
 */
+ (jint)deepHashCodeWithByteArray3:(IOSObjectArray *)array;

/*!
 @brief Compare two byte arrays (perform null checks beforehand).
 @param left the first byte array
 @param right the second byte array
 @return the result of the comparison
 */
+ (jboolean)equalsWithByteArray:(IOSByteArray *)left
                  withByteArray:(IOSByteArray *)right;

/*!
 @brief Compare two two-dimensional byte arrays.No null checks are performed.
 @param left the first byte array
 @param right the second byte array
 @return the result of the comparison
 */
+ (jboolean)equalsWithByteArray2:(IOSObjectArray *)left
                  withByteArray2:(IOSObjectArray *)right;

/*!
 @brief Compare two three-dimensional byte arrays.No null checks are performed.
 @param left the first byte array
 @param right the second byte array
 @return the result of the comparison
 */
+ (jboolean)equalsWithByteArray3:(IOSObjectArray *)left
                  withByteArray3:(IOSObjectArray *)right;

/*!
 @brief Convert a string containing hexadecimal characters to a byte-array.
 @param s a hex string
 @return a byte array with the corresponding value
 */
+ (IOSByteArray *)fromHexStringWithNSString:(NSString *)s;

/*!
 @brief Split a byte array <tt>input</tt> into two arrays at <tt>index</tt>,
  i.e.the first array will have the lower <tt>index</tt> bytes, the
  second one the higher <tt>input.length - index</tt> bytes.
 @param input the byte array to be split
 @param index the index where the byte array is split
 @return the splitted input array as an array of two byte arrays
 @throw ArrayIndexOutOfBoundsExceptionif <tt>index</tt> is out of bounds
 */
+ (IOSObjectArray *)splitWithByteArray:(IOSByteArray *)input
                               withInt:(jint)index;

/*!
 @brief Generate a subarray of a given byte array.
 @param input the input byte array
 @param start the start index
 @return a subarray of <tt>input</tt>, ranging from <tt>start</tt> to
          the end of the array
 */
+ (IOSByteArray *)subArrayWithByteArray:(IOSByteArray *)input
                                withInt:(jint)start;

/*!
 @brief Generate a subarray of a given byte array.
 @param input the input byte array
 @param start the start index
 @param end the end index
 @return a subarray of <tt>input</tt>, ranging from <tt>start</tt>
          (inclusively) to <tt>end</tt> (exclusively)
 */
+ (IOSByteArray *)subArrayWithByteArray:(IOSByteArray *)input
                                withInt:(jint)start
                                withInt:(jint)end;

/*!
 @brief Convert a byte array to the corresponding bit string.
 @param input the byte array to be converted
 @return the corresponding bit string
 */
+ (NSString *)toBinaryStringWithByteArray:(IOSByteArray *)input;

/*!
 @brief Rewrite a byte array as a char array
 @param input -               the byte array
 @return char array
 */
+ (IOSCharArray *)toCharArrayWithByteArray:(IOSByteArray *)input;

/*!
 @brief Convert a byte array to the corresponding hexstring.
 @param input the byte array to be converted
 @return the corresponding hexstring
 */
+ (NSString *)toHexStringWithByteArray:(IOSByteArray *)input;

/*!
 @brief Convert a byte array to the corresponding hex string.
 @param input the byte array to be converted
 @param prefix the prefix to put at the beginning of the hex string
 @param seperator a separator string
 @return the corresponding hex string
 */
+ (NSString *)toHexStringWithByteArray:(IOSByteArray *)input
                          withNSString:(NSString *)prefix
                          withNSString:(NSString *)seperator;

/*!
 @brief Compute the bitwise XOR of two arrays of bytes.The arrays have to be of
  same length.
 No length checking is performed.
 @param x1 the first array
 @param x2 the second array
 @return x1 XOR x2
 */
+ (IOSByteArray *)xor__WithByteArray:(IOSByteArray *)x1
                       withByteArray:(IOSByteArray *)x2;

@end

J2OBJC_STATIC_INIT(OrgBouncycastlePqcMathLinearalgebraByteUtils)

FOUNDATION_EXPORT jboolean OrgBouncycastlePqcMathLinearalgebraByteUtils_equalsWithByteArray_withByteArray_(IOSByteArray *left, IOSByteArray *right);

FOUNDATION_EXPORT jboolean OrgBouncycastlePqcMathLinearalgebraByteUtils_equalsWithByteArray2_withByteArray2_(IOSObjectArray *left, IOSObjectArray *right);

FOUNDATION_EXPORT jboolean OrgBouncycastlePqcMathLinearalgebraByteUtils_equalsWithByteArray3_withByteArray3_(IOSObjectArray *left, IOSObjectArray *right);

FOUNDATION_EXPORT jint OrgBouncycastlePqcMathLinearalgebraByteUtils_deepHashCodeWithByteArray_(IOSByteArray *array);

FOUNDATION_EXPORT jint OrgBouncycastlePqcMathLinearalgebraByteUtils_deepHashCodeWithByteArray2_(IOSObjectArray *array);

FOUNDATION_EXPORT jint OrgBouncycastlePqcMathLinearalgebraByteUtils_deepHashCodeWithByteArray3_(IOSObjectArray *array);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_cloneWithByteArray_(IOSByteArray *array);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_fromHexStringWithNSString_(NSString *s);

FOUNDATION_EXPORT NSString *OrgBouncycastlePqcMathLinearalgebraByteUtils_toHexStringWithByteArray_(IOSByteArray *input);

FOUNDATION_EXPORT NSString *OrgBouncycastlePqcMathLinearalgebraByteUtils_toHexStringWithByteArray_withNSString_withNSString_(IOSByteArray *input, NSString *prefix, NSString *seperator);

FOUNDATION_EXPORT NSString *OrgBouncycastlePqcMathLinearalgebraByteUtils_toBinaryStringWithByteArray_(IOSByteArray *input);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_xor__WithByteArray_withByteArray_(IOSByteArray *x1, IOSByteArray *x2);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_concatenateWithByteArray_withByteArray_(IOSByteArray *x1, IOSByteArray *x2);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_concatenateWithByteArray2_(IOSObjectArray *array);

FOUNDATION_EXPORT IOSObjectArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_splitWithByteArray_withInt_(IOSByteArray *input, jint index);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_subArrayWithByteArray_withInt_withInt_(IOSByteArray *input, jint start, jint end);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_subArrayWithByteArray_withInt_(IOSByteArray *input, jint start);

FOUNDATION_EXPORT IOSCharArray *OrgBouncycastlePqcMathLinearalgebraByteUtils_toCharArrayWithByteArray_(IOSByteArray *input);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastlePqcMathLinearalgebraByteUtils)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgBouncycastlePqcMathLinearalgebraByteUtils")
