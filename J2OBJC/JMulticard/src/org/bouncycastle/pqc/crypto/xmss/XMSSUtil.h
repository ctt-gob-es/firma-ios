//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/pqc/crypto/xmss/XMSSUtil.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgBouncycastlePqcCryptoXmssXMSSUtil")
#ifdef RESTRICT_OrgBouncycastlePqcCryptoXmssXMSSUtil
#define INCLUDE_ALL_OrgBouncycastlePqcCryptoXmssXMSSUtil 0
#else
#define INCLUDE_ALL_OrgBouncycastlePqcCryptoXmssXMSSUtil 1
#endif
#undef RESTRICT_OrgBouncycastlePqcCryptoXmssXMSSUtil

#if !defined (OrgBouncycastlePqcCryptoXmssXMSSUtil_) && (INCLUDE_ALL_OrgBouncycastlePqcCryptoXmssXMSSUtil || defined(INCLUDE_OrgBouncycastlePqcCryptoXmssXMSSUtil))
#define OrgBouncycastlePqcCryptoXmssXMSSUtil_

@class IOSByteArray;
@class IOSClass;
@class IOSObjectArray;
@protocol OrgBouncycastleCryptoDigest;

/*!
 @brief Utils for XMSS implementation.
 */
@interface OrgBouncycastlePqcCryptoXmssXMSSUtil : NSObject

#pragma mark Public

- (instancetype)init;

/*!
 @brief Compares two 2d-byte arrays.
 @param a 2d-byte array 1.
 @param b 2d-byte array 2.
 @return true if all values in 2d-byte array are equal false else.
 */
+ (jboolean)areEqualWithByteArray2:(IOSObjectArray *)a
                    withByteArray2:(IOSObjectArray *)b;

+ (jlong)bytesToXBigEndianWithByteArray:(IOSByteArray *)inArg
                                withInt:(jint)offset
                                withInt:(jint)size;

+ (jint)calculateTauWithInt:(jint)index
                    withInt:(jint)height;

/*!
 @brief Clone a byte array.
 @param inArg byte array.
 @return Copy of byte array.
 */
+ (IOSByteArray *)cloneArrayWithByteArray:(IOSByteArray *)inArg;

/*!
 @brief Clone a 2d byte array.
 @param inArg 2d byte array.
 @return Copy of 2d byte array.
 */
+ (IOSObjectArray *)cloneArrayWithByteArray2:(IOSObjectArray *)inArg;

/*!
 @brief Copy src byte array to dst byte array at offset.
 @param dst Destination.
 @param src Source.
 @param offset Destination offset.
 */
+ (void)copyBytesAtOffsetWithByteArray:(IOSByteArray *)dst
                         withByteArray:(IOSByteArray *)src
                               withInt:(jint)offset OBJC_METHOD_FAMILY_NONE;

+ (id)deserializeWithByteArray:(IOSByteArray *)data
                  withIOSClass:(IOSClass *)clazz;

/*!
 @brief Dump content of 2d byte array.
 @param x byte array.
 */
+ (void)dumpByteArrayWithByteArray2:(IOSObjectArray *)x;

/*!
 @brief Copy length bytes at position offset from src.
 @param src Source byte array.
 @param offset Offset in source byte array.
 @param length Length of bytes to copy.
 @return New byte array.
 */
+ (IOSByteArray *)extractBytesAtOffsetWithByteArray:(IOSByteArray *)src
                                            withInt:(jint)offset
                                            withInt:(jint)length;

/*!
 @brief Determine digest size of digest.
 @param digest Digest.
 @return Digest size.
 */
+ (jint)getDigestSizeWithOrgBouncycastleCryptoDigest:(id<OrgBouncycastleCryptoDigest>)digest;

+ (jint)getLeafIndexWithLong:(jlong)index
                     withInt:(jint)xmssTreeHeight;

+ (jlong)getTreeIndexWithLong:(jlong)index
                      withInt:(jint)xmssTreeHeight;

/*!
 @brief Checks whether 2d byte array has null pointers.
 @param inArg 2d byte array.
 @return true if at least one null pointer is found false else.
 */
+ (jboolean)hasNullPointerWithByteArray2:(IOSObjectArray *)inArg;

/*!
 @brief Check whether an index is valid or not.
 @param height Height of binary tree.
 @param index Index to validate.
 @return true if index is valid false else.
 */
+ (jboolean)isIndexValidWithInt:(jint)height
                       withLong:(jlong)index;

+ (jboolean)isNewAuthenticationPathNeededWithLong:(jlong)globalIndex
                                          withInt:(jint)xmssHeight
                                          withInt:(jint)layer;

+ (jboolean)isNewBDSInitNeededWithLong:(jlong)globalIndex
                               withInt:(jint)xmssHeight
                               withInt:(jint)layer;

/*!
 @brief Calculates the logarithm base 2 for a given Integer.
 @param n Number.
 @return Logarithm to base 2 of <code>n</code>.
 */
+ (jint)log2WithInt:(jint)n;

+ (void)longToBigEndianWithLong:(jlong)value
                  withByteArray:(IOSByteArray *)inArg
                        withInt:(jint)offset;

+ (IOSByteArray *)serializeWithId:(id)obj;

/*!
 @brief Convert int/long to n-byte array.
 @param value int/long value.
 @param sizeInByte Size of byte array in byte.
 @return int/long as big-endian byte array of size <code>sizeInByte</code>.
 */
+ (IOSByteArray *)toBytesBigEndianWithLong:(jlong)value
                                   withInt:(jint)sizeInByte;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgBouncycastlePqcCryptoXmssXMSSUtil)

FOUNDATION_EXPORT void OrgBouncycastlePqcCryptoXmssXMSSUtil_init(OrgBouncycastlePqcCryptoXmssXMSSUtil *self);

FOUNDATION_EXPORT OrgBouncycastlePqcCryptoXmssXMSSUtil *new_OrgBouncycastlePqcCryptoXmssXMSSUtil_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgBouncycastlePqcCryptoXmssXMSSUtil *create_OrgBouncycastlePqcCryptoXmssXMSSUtil_init(void);

FOUNDATION_EXPORT jint OrgBouncycastlePqcCryptoXmssXMSSUtil_log2WithInt_(jint n);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcCryptoXmssXMSSUtil_toBytesBigEndianWithLong_withInt_(jlong value, jint sizeInByte);

FOUNDATION_EXPORT void OrgBouncycastlePqcCryptoXmssXMSSUtil_longToBigEndianWithLong_withByteArray_withInt_(jlong value, IOSByteArray *inArg, jint offset);

FOUNDATION_EXPORT jlong OrgBouncycastlePqcCryptoXmssXMSSUtil_bytesToXBigEndianWithByteArray_withInt_withInt_(IOSByteArray *inArg, jint offset, jint size);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcCryptoXmssXMSSUtil_cloneArrayWithByteArray_(IOSByteArray *inArg);

FOUNDATION_EXPORT IOSObjectArray *OrgBouncycastlePqcCryptoXmssXMSSUtil_cloneArrayWithByteArray2_(IOSObjectArray *inArg);

FOUNDATION_EXPORT jboolean OrgBouncycastlePqcCryptoXmssXMSSUtil_areEqualWithByteArray2_withByteArray2_(IOSObjectArray *a, IOSObjectArray *b);

FOUNDATION_EXPORT void OrgBouncycastlePqcCryptoXmssXMSSUtil_dumpByteArrayWithByteArray2_(IOSObjectArray *x);

FOUNDATION_EXPORT jboolean OrgBouncycastlePqcCryptoXmssXMSSUtil_hasNullPointerWithByteArray2_(IOSObjectArray *inArg);

FOUNDATION_EXPORT void OrgBouncycastlePqcCryptoXmssXMSSUtil_copyBytesAtOffsetWithByteArray_withByteArray_withInt_(IOSByteArray *dst, IOSByteArray *src, jint offset);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcCryptoXmssXMSSUtil_extractBytesAtOffsetWithByteArray_withInt_withInt_(IOSByteArray *src, jint offset, jint length);

FOUNDATION_EXPORT jboolean OrgBouncycastlePqcCryptoXmssXMSSUtil_isIndexValidWithInt_withLong_(jint height, jlong index);

FOUNDATION_EXPORT jint OrgBouncycastlePqcCryptoXmssXMSSUtil_getDigestSizeWithOrgBouncycastleCryptoDigest_(id<OrgBouncycastleCryptoDigest> digest);

FOUNDATION_EXPORT jlong OrgBouncycastlePqcCryptoXmssXMSSUtil_getTreeIndexWithLong_withInt_(jlong index, jint xmssTreeHeight);

FOUNDATION_EXPORT jint OrgBouncycastlePqcCryptoXmssXMSSUtil_getLeafIndexWithLong_withInt_(jlong index, jint xmssTreeHeight);

FOUNDATION_EXPORT IOSByteArray *OrgBouncycastlePqcCryptoXmssXMSSUtil_serializeWithId_(id obj);

FOUNDATION_EXPORT id OrgBouncycastlePqcCryptoXmssXMSSUtil_deserializeWithByteArray_withIOSClass_(IOSByteArray *data, IOSClass *clazz);

FOUNDATION_EXPORT jint OrgBouncycastlePqcCryptoXmssXMSSUtil_calculateTauWithInt_withInt_(jint index, jint height);

FOUNDATION_EXPORT jboolean OrgBouncycastlePqcCryptoXmssXMSSUtil_isNewBDSInitNeededWithLong_withInt_withInt_(jlong globalIndex, jint xmssHeight, jint layer);

FOUNDATION_EXPORT jboolean OrgBouncycastlePqcCryptoXmssXMSSUtil_isNewAuthenticationPathNeededWithLong_withInt_withInt_(jlong globalIndex, jint xmssHeight, jint layer);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastlePqcCryptoXmssXMSSUtil)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgBouncycastlePqcCryptoXmssXMSSUtil")
