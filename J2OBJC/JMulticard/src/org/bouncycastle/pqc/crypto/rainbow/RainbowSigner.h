//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/pqc/crypto/rainbow/RainbowSigner.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_OrgBouncycastlePqcCryptoRainbowRainbowSigner")
#ifdef RESTRICT_OrgBouncycastlePqcCryptoRainbowRainbowSigner
#define INCLUDE_ALL_OrgBouncycastlePqcCryptoRainbowRainbowSigner 0
#else
#define INCLUDE_ALL_OrgBouncycastlePqcCryptoRainbowRainbowSigner 1
#endif
#undef RESTRICT_OrgBouncycastlePqcCryptoRainbowRainbowSigner

#if !defined (OrgBouncycastlePqcCryptoRainbowRainbowSigner_) && (INCLUDE_ALL_OrgBouncycastlePqcCryptoRainbowRainbowSigner || defined(INCLUDE_OrgBouncycastlePqcCryptoRainbowRainbowSigner))
#define OrgBouncycastlePqcCryptoRainbowRainbowSigner_

#define RESTRICT_OrgBouncycastlePqcCryptoMessageSigner 1
#define INCLUDE_OrgBouncycastlePqcCryptoMessageSigner 1
#include "org/bouncycastle/pqc/crypto/MessageSigner.h"

@class IOSByteArray;
@class OrgBouncycastlePqcCryptoRainbowRainbowKeyParameters;
@protocol OrgBouncycastleCryptoCipherParameters;

/*!
 @brief It implements the sign and verify functions for the Rainbow Signature Scheme.
 Here the message, which has to be signed, is updated. The use of
  different hash functions is possible. 
 <p>
  Detailed information about the signature and the verify-method is to be found
  in the paper of Jintai Ding, Dieter Schmidt: Rainbow, a New Multivariable
  Polynomial Signature Scheme. ACNS 2005: 164-175
  (https://dx.doi.org/10.1007/11496137_12)
 */
@interface OrgBouncycastlePqcCryptoRainbowRainbowSigner : NSObject < OrgBouncycastlePqcCryptoMessageSigner > {
 @public
  jint signableDocumentLength_;
  OrgBouncycastlePqcCryptoRainbowRainbowKeyParameters *key_;
}

#pragma mark Public

- (instancetype)init;

/*!
 @brief This function signs the message that has been updated, making use of the
  private key.
 <p>
  For computing the signature, L1 and L2 are needed, as well as LES should
  be solved for each layer in order to find the Oil-variables in the layer. 
 <p>
  The Vinegar-variables of the first layer are random generated.
 @param message the message
 @return the signature of the message.
 */
- (IOSByteArray *)generateSignatureWithByteArray:(IOSByteArray *)message;

- (void)init__WithBoolean:(jboolean)forSigning
withOrgBouncycastleCryptoCipherParameters:(id<OrgBouncycastleCryptoCipherParameters>)param OBJC_METHOD_FAMILY_NONE;

/*!
 @brief This function verifies the signature of the message that has been
  updated, with the aid of the public key.
 @param message the message
 @param signature the signature of the message
 @return true if the signature has been verified, false otherwise.
 */
- (jboolean)verifySignatureWithByteArray:(IOSByteArray *)message
                           withByteArray:(IOSByteArray *)signature;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgBouncycastlePqcCryptoRainbowRainbowSigner)

J2OBJC_FIELD_SETTER(OrgBouncycastlePqcCryptoRainbowRainbowSigner, key_, OrgBouncycastlePqcCryptoRainbowRainbowKeyParameters *)

FOUNDATION_EXPORT void OrgBouncycastlePqcCryptoRainbowRainbowSigner_init(OrgBouncycastlePqcCryptoRainbowRainbowSigner *self);

FOUNDATION_EXPORT OrgBouncycastlePqcCryptoRainbowRainbowSigner *new_OrgBouncycastlePqcCryptoRainbowRainbowSigner_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgBouncycastlePqcCryptoRainbowRainbowSigner *create_OrgBouncycastlePqcCryptoRainbowRainbowSigner_init(void);

J2OBJC_TYPE_LITERAL_HEADER(OrgBouncycastlePqcCryptoRainbowRainbowSigner)

#endif

#pragma pop_macro("INCLUDE_ALL_OrgBouncycastlePqcCryptoRainbowRainbowSigner")
