//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/pqc/crypto/rainbow/util/ComputeInField.java
//

#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/RuntimeException.h"
#include "org/bouncycastle/pqc/crypto/rainbow/util/ComputeInField.h"
#include "org/bouncycastle/pqc/crypto/rainbow/util/GF2Field.h"

#if !__has_feature(objc_arc)
#error "org/bouncycastle/pqc/crypto/rainbow/util/ComputeInField must be compiled with ARC (-fobjc-arc)"
#endif

@interface OrgBouncycastlePqcCryptoRainbowUtilComputeInField () {
 @public
  IOSObjectArray *A_;
}

/*!
 @brief Elimination under the diagonal.
 This function changes a matrix so that it contains only zeros under the
  diagonal(Ai,i) using only Gauss-Elimination operations. 
 <p>
  It is used in solveEquaton as well as in the function for
  finding an inverse of a matrix: <code></code>inverse. Both of them use the
  Gauss-Elimination Method. 
 </p><p>
  The result is stored in the global matrix A 
 </p>
 @param usedForInverse This parameter shows if the function is used by the                        solveEquation-function or by the inverse-function and according
                         to this creates matrices of different sizes.
 @throw RuntimeExceptionin case a multiplicative inverse of 0 is needed
 */
- (void)computeZerosUnderWithBoolean:(jboolean)usedForInverse;

/*!
 @brief Elimination above the diagonal.
 This function changes a matrix so that it contains only zeros above the
  diagonal(Ai,i) using only Gauss-Elimination operations. 
 <p>
  It is used in the inverse-function
  The result is stored in the global matrix A 
 </p>
 @throw RuntimeExceptionin case a multiplicative inverse of 0 is needed
 */
- (void)computeZerosAbove;

/*!
 @brief This function uses backward substitution to find x
  of the linear equation system (LES) B*x = b,
  where A a triangle-matrix is (contains only zeros under the diagonal)
  and b is a vector
 <p>
  If the multiplicative inverse of 0 is needed, an exception is thrown.
 In this case is the LES not solvable 
 </p>
 @throw RuntimeExceptionin case a multiplicative inverse of 0 is needed
 */
- (void)substitute;

@end

J2OBJC_FIELD_SETTER(OrgBouncycastlePqcCryptoRainbowUtilComputeInField, A_, IOSObjectArray *)

__attribute__((unused)) static void OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosUnderWithBoolean_(OrgBouncycastlePqcCryptoRainbowUtilComputeInField *self, jboolean usedForInverse);

__attribute__((unused)) static void OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosAbove(OrgBouncycastlePqcCryptoRainbowUtilComputeInField *self);

__attribute__((unused)) static void OrgBouncycastlePqcCryptoRainbowUtilComputeInField_substitute(OrgBouncycastlePqcCryptoRainbowUtilComputeInField *self);

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/pqc/crypto/rainbow/util/ComputeInField.java"


#line 12
@implementation OrgBouncycastlePqcCryptoRainbowUtilComputeInField

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 21
- (instancetype)init {
  OrgBouncycastlePqcCryptoRainbowUtilComputeInField_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 38
- (IOSShortArray *)solveEquationWithShortArray2:(IOSObjectArray *)B
                                 withShortArray:(IOSShortArray *)b {
  if (((IOSObjectArray *) nil_chk(B))->size_ != ((IOSShortArray *) nil_chk(b))->size_) {
    
#line 42
    return nil;
  }
  
#line 45
  @try {
    
#line 54
    A_ = [IOSShortArray newArrayWithDimensions:2 lengths:(jint[]){ B->size_, B->size_ + 1 }];
    
#line 56
    x_ = [IOSShortArray newArrayWithLength:B->size_];
    
#line 59
    for (jint i = 0; i < B->size_; i++) {
      
#line 61
      for (jint j = 0; j < ((IOSShortArray *) nil_chk(IOSObjectArray_Get(B, 0)))->size_; j++) {
        
#line 63
        *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(A_, i)), j) = IOSShortArray_Get(nil_chk(IOSObjectArray_Get(B, i)), j);
      }
    }
    
#line 70
    for (jint i = 0; i < b->size_; i++) {
      
#line 72
      *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(A_), i)), b->size_) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_addElemWithShort_withShort_(IOSShortArray_Get(b, i), IOSShortArray_Get(nil_chk(IOSObjectArray_Get(A_, i)), b->size_));
    }
    
#line 76
    OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosUnderWithBoolean_(self, false);
    OrgBouncycastlePqcCryptoRainbowUtilComputeInField_substitute(self);
    
#line 79
    return x_;
  }
  @catch (
#line 82
  JavaLangRuntimeException *rte) {
    
#line 84
    return nil;
  }
}


#line 99
- (IOSObjectArray *)inverseWithShortArray2:(IOSObjectArray *)coef {
  
#line 101
  @try {
    
#line 104
    jshort factor;
    IOSObjectArray *inverse;
    A_ = [IOSShortArray newArrayWithDimensions:2 lengths:(jint[]){ ((IOSObjectArray *) nil_chk(coef))->size_, 2 * coef->size_ }];
    if (coef->size_ != ((IOSShortArray *) nil_chk(IOSObjectArray_Get(coef, 0)))->size_) {
      
#line 109
      @throw new_JavaLangRuntimeException_initWithNSString_(
#line 110
      @"The matrix is not invertible. Please choose another one!");
    }
    
#line 114
    for (jint i = 0; i < coef->size_; i++) {
      
#line 116
      for (jint j = 0; j < coef->size_; j++) {
        
#line 119
        *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(A_, i)), j) = IOSShortArray_Get(nil_chk(IOSObjectArray_Get(coef, i)), j);
      }
      
#line 122
      for (jint j = coef->size_; j < 2 * coef->size_; j++) {
        
#line 124
        *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(A_, i)), j) = 0;
      }
      *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(A_, i)), i + A_->size_) = 1;
    }
    
#line 131
    OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosUnderWithBoolean_(self, true);
    
#line 134
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(A_))->size_; i++) {
      
#line 136
      factor = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_invElemWithShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(A_, i)), i));
      for (jint j = i; j < 2 * ((IOSObjectArray *) nil_chk(A_))->size_; j++) {
        
#line 139
        *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(A_, i)), j) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(A_, i)), j), factor);
      }
    }
    
#line 144
    OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosAbove(self);
    
#line 147
    inverse = [IOSShortArray newArrayWithDimensions:2 lengths:(jint[]){ ((IOSObjectArray *) nil_chk(A_))->size_, A_->size_ }];
    for (jint i = 0; i < A_->size_; i++) {
      
#line 150
      for (jint j = A_->size_; j < 2 * A_->size_; j++) {
        
#line 152
        *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(inverse, i)), j - A_->size_) = IOSShortArray_Get(nil_chk(IOSObjectArray_Get(A_, i)), j);
      }
    }
    return inverse;
  }
  @catch (
#line 158
  JavaLangRuntimeException *rte) {
    
#line 161
    return nil;
  }
}


#line 182
- (void)computeZerosUnderWithBoolean:(jboolean)usedForInverse {
  OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosUnderWithBoolean_(self, usedForInverse);
}


#line 240
- (void)computeZerosAbove {
  OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosAbove(self);
}


#line 280
- (void)substitute {
  OrgBouncycastlePqcCryptoRainbowUtilComputeInField_substitute(self);
}


#line 325
- (IOSObjectArray *)multiplyMatrixWithShortArray2:(IOSObjectArray *)M1
                                  withShortArray2:(IOSObjectArray *)M2 {
  
#line 329
  if (((IOSShortArray *) nil_chk(IOSObjectArray_Get(nil_chk(M1), 0)))->size_ != ((IOSObjectArray *) nil_chk(M2))->size_) {
    
#line 331
    @throw new_JavaLangRuntimeException_initWithNSString_(@"Multiplication is not possible!");
  }
  jshort tmp = 0;
  A_ = [IOSShortArray newArrayWithDimensions:2 lengths:(jint[]){ M1->size_, ((IOSShortArray *) nil_chk(IOSObjectArray_Get(M2, 0)))->size_ }];
  for (jint i = 0; i < M1->size_; i++) {
    
#line 337
    for (jint j = 0; j < M2->size_; j++) {
      
#line 339
      for (jint k = 0; k < ((IOSShortArray *) nil_chk(IOSObjectArray_Get(M2, 0)))->size_; k++) {
        
#line 341
        tmp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(M1, i)), j), IOSShortArray_Get(nil_chk(IOSObjectArray_Get(M2, j)), k));
        *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(A_), i)), k) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_addElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(A_, i)), k), tmp);
      }
    }
  }
  return A_;
}


#line 360
- (IOSShortArray *)multiplyMatrixWithShortArray2:(IOSObjectArray *)M1
                                  withShortArray:(IOSShortArray *)m {
  
#line 363
  if (((IOSShortArray *) nil_chk(IOSObjectArray_Get(nil_chk(M1), 0)))->size_ != ((IOSShortArray *) nil_chk(m))->size_) {
    
#line 365
    @throw new_JavaLangRuntimeException_initWithNSString_(@"Multiplication is not possible!");
  }
  jshort tmp = 0;
  IOSShortArray *B = [IOSShortArray newArrayWithLength:M1->size_];
  for (jint i = 0; i < M1->size_; i++) {
    
#line 371
    for (jint j = 0; j < m->size_; j++) {
      
#line 373
      tmp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(M1, i)), j), IOSShortArray_Get(m, j));
      *IOSShortArray_GetRef(B, i) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_addElemWithShort_withShort_(IOSShortArray_Get(B, i), tmp);
    }
  }
  return B;
}


#line 389
- (IOSShortArray *)addVectWithShortArray:(IOSShortArray *)vector1
                          withShortArray:(IOSShortArray *)vector2 {
  if (((IOSShortArray *) nil_chk(vector1))->size_ != ((IOSShortArray *) nil_chk(vector2))->size_) {
    
#line 393
    @throw new_JavaLangRuntimeException_initWithNSString_(@"Multiplication is not possible!");
  }
  IOSShortArray *rslt = [IOSShortArray newArrayWithLength:vector1->size_];
  for (jint n = 0; n < rslt->size_; n++) {
    
#line 398
    *IOSShortArray_GetRef(rslt, n) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_addElemWithShort_withShort_(IOSShortArray_Get(vector1, n), IOSShortArray_Get(vector2, n));
  }
  return rslt;
}


#line 412
- (IOSObjectArray *)multVectsWithShortArray:(IOSShortArray *)vector1
                             withShortArray:(IOSShortArray *)vector2 {
  if (((IOSShortArray *) nil_chk(vector1))->size_ != ((IOSShortArray *) nil_chk(vector2))->size_) {
    
#line 416
    @throw new_JavaLangRuntimeException_initWithNSString_(@"Multiplication is not possible!");
  }
  IOSObjectArray *rslt = [IOSShortArray newArrayWithDimensions:2 lengths:(jint[]){ vector1->size_, vector2->size_ }];
  for (jint i = 0; i < vector1->size_; i++) {
    
#line 421
    for (jint j = 0; j < vector2->size_; j++) {
      
#line 423
      *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(rslt, i)), j) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(IOSShortArray_Get(vector1, i), IOSShortArray_Get(vector2, j));
    }
  }
  return rslt;
}


#line 436
- (IOSShortArray *)multVectWithShort:(jshort)scalar
                      withShortArray:(IOSShortArray *)vector {
  IOSShortArray *rslt = [IOSShortArray newArrayWithLength:((IOSShortArray *) nil_chk(vector))->size_];
  for (jint n = 0; n < rslt->size_; n++) {
    
#line 441
    *IOSShortArray_GetRef(rslt, n) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(scalar, IOSShortArray_Get(vector, n));
  }
  return rslt;
}


#line 453
- (IOSObjectArray *)multMatrixWithShort:(jshort)scalar
                        withShortArray2:(IOSObjectArray *)matrix {
  IOSObjectArray *rslt = [IOSShortArray newArrayWithDimensions:2 lengths:(jint[]){ ((IOSObjectArray *) nil_chk(matrix))->size_, ((IOSShortArray *) nil_chk(IOSObjectArray_Get(matrix, 0)))->size_ }];
  for (jint i = 0; i < matrix->size_; i++) {
    
#line 458
    for (jint j = 0; j < ((IOSShortArray *) nil_chk(IOSObjectArray_Get(matrix, 0)))->size_; j++) {
      
#line 460
      *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(rslt, i)), j) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(scalar, IOSShortArray_Get(nil_chk(IOSObjectArray_Get(matrix, i)), j));
    }
  }
  return rslt;
}


#line 475
- (IOSObjectArray *)addSquareMatrixWithShortArray2:(IOSObjectArray *)matrix1
                                   withShortArray2:(IOSObjectArray *)matrix2 {
  if (((IOSObjectArray *) nil_chk(matrix1))->size_ != ((IOSObjectArray *) nil_chk(matrix2))->size_ || ((IOSShortArray *) nil_chk(IOSObjectArray_Get(matrix1, 0)))->size_ != ((IOSShortArray *) nil_chk(IOSObjectArray_Get(matrix2, 0)))->size_) {
    
#line 479
    @throw new_JavaLangRuntimeException_initWithNSString_(@"Addition is not possible!");
  }
  
#line 482
  IOSObjectArray *rslt = [IOSShortArray newArrayWithDimensions:2 lengths:(jint[]){ matrix1->size_, matrix1->size_ }];
  for (jint i = 0; i < matrix1->size_; i++) {
    
#line 485
    for (jint j = 0; j < matrix2->size_; j++) {
      
#line 487
      *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(rslt, i)), j) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_addElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(matrix1, i)), j), IOSShortArray_Get(nil_chk(IOSObjectArray_Get(matrix2, i)), j));
    }
  }
  return rslt;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[S", 0x1, 0, 1, -1, -1, -1, -1 },
    { NULL, "[[S", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 4, 5, 6, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 6, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 7, -1, -1, -1 },
    { NULL, "[[S", 0x1, 8, 9, 6, -1, -1, -1 },
    { NULL, "[S", 0x1, 8, 1, 6, -1, -1, -1 },
    { NULL, "[S", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "[[S", 0x1, 12, 11, -1, -1, -1, -1 },
    { NULL, "[S", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "[[S", 0x1, 15, 16, -1, -1, -1, -1 },
    { NULL, "[[S", 0x1, 17, 9, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(solveEquationWithShortArray2:withShortArray:);
  methods[2].selector = @selector(inverseWithShortArray2:);
  methods[3].selector = @selector(computeZerosUnderWithBoolean:);
  methods[4].selector = @selector(computeZerosAbove);
  methods[5].selector = @selector(substitute);
  methods[6].selector = @selector(multiplyMatrixWithShortArray2:withShortArray2:);
  methods[7].selector = @selector(multiplyMatrixWithShortArray2:withShortArray:);
  methods[8].selector = @selector(addVectWithShortArray:withShortArray:);
  methods[9].selector = @selector(multVectsWithShortArray:withShortArray:);
  methods[10].selector = @selector(multVectWithShort:withShortArray:);
  methods[11].selector = @selector(multMatrixWithShort:withShortArray2:);
  methods[12].selector = @selector(addSquareMatrixWithShortArray2:withShortArray2:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "A_", "[[S", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "x_", "[S", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "solveEquation", "[[S[S", "inverse", "[[S", "computeZerosUnder", "Z", "LJavaLangRuntimeException;", "LJavaLangIllegalStateException;", "multiplyMatrix", "[[S[[S", "addVect", "[S[S", "multVects", "multVect", "S[S", "multMatrix", "S[[S", "addSquareMatrix" };
  static const J2ObjcClassInfo _OrgBouncycastlePqcCryptoRainbowUtilComputeInField = { "ComputeInField", "org.bouncycastle.pqc.crypto.rainbow.util", ptrTable, methods, fields, 7, 0x1, 13, 2, -1, -1, -1, -1, -1 };
  return &_OrgBouncycastlePqcCryptoRainbowUtilComputeInField;
}

@end


#line 21
void OrgBouncycastlePqcCryptoRainbowUtilComputeInField_init(OrgBouncycastlePqcCryptoRainbowUtilComputeInField *self) {
  NSObject_init(self);
}


#line 21
OrgBouncycastlePqcCryptoRainbowUtilComputeInField *new_OrgBouncycastlePqcCryptoRainbowUtilComputeInField_init() {
  J2OBJC_NEW_IMPL(OrgBouncycastlePqcCryptoRainbowUtilComputeInField, init)
}


#line 21
OrgBouncycastlePqcCryptoRainbowUtilComputeInField *create_OrgBouncycastlePqcCryptoRainbowUtilComputeInField_init() {
  J2OBJC_CREATE_IMPL(OrgBouncycastlePqcCryptoRainbowUtilComputeInField, init)
}


#line 182
void OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosUnderWithBoolean_(OrgBouncycastlePqcCryptoRainbowUtilComputeInField *self, jboolean usedForInverse) {
  
#line 187
  jint length;
  jshort tmp = 0;
  
#line 191
  if (usedForInverse) {
    
#line 193
    length = 2 * ((IOSObjectArray *) nil_chk(self->A_))->size_;
  }
  else {
    
#line 198
    length = ((IOSObjectArray *) nil_chk(self->A_))->size_ + 1;
  }
  
#line 202
  for (jint k = 0; k < self->A_->size_ - 1; k++) {
    
#line 204
    for (jint i = k + 1; i < ((IOSObjectArray *) nil_chk(self->A_))->size_; i++) {
      
#line 206
      jshort factor1 = IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, i)), k);
      jshort factor2 = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_invElemWithShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, k)), k));
      
#line 211
      if (factor2 == 0) {
        
#line 213
        @throw new_JavaLangIllegalStateException_initWithNSString_(@"Matrix not invertible! We have to choose another one!");
      }
      
#line 216
      for (jint j = k; j < length; j++) {
        
#line 219
        tmp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->A_), k)), j), factor2);
        
#line 221
        tmp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(factor1, tmp);
        
#line 223
        *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(self->A_), i)), j) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_addElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, i)), j), tmp);
      }
    }
  }
}


#line 240
void OrgBouncycastlePqcCryptoRainbowUtilComputeInField_computeZerosAbove(OrgBouncycastlePqcCryptoRainbowUtilComputeInField *self) {
  
#line 243
  jshort tmp = 0;
  for (jint k = ((IOSObjectArray *) nil_chk(self->A_))->size_ - 1; k > 0; k--) {
    
#line 246
    for (jint i = k - 1; i >= 0; i--) {
      
#line 248
      jshort factor1 = IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, i)), k);
      jshort factor2 = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_invElemWithShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, k)), k));
      if (factor2 == 0) {
        
#line 252
        @throw new_JavaLangRuntimeException_initWithNSString_(@"The matrix is not invertible");
      }
      for (jint j = k; j < 2 * ((IOSObjectArray *) nil_chk(self->A_))->size_; j++) {
        
#line 257
        tmp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, k)), j), factor2);
        
#line 259
        tmp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(factor1, tmp);
        
#line 261
        *IOSShortArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(self->A_), i)), j) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_addElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, i)), j), tmp);
      }
    }
  }
}


#line 280
void OrgBouncycastlePqcCryptoRainbowUtilComputeInField_substitute(OrgBouncycastlePqcCryptoRainbowUtilComputeInField *self) {
  
#line 285
  jshort tmp;
  
#line 285
  jshort temp;
  
#line 287
  temp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_invElemWithShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, ((IOSObjectArray *) nil_chk(self->A_))->size_ - 1)), self->A_->size_ - 1));
  if (temp == 0) {
    
#line 290
    @throw new_JavaLangIllegalStateException_initWithNSString_(@"The equation system is not solvable");
  }
  
#line 294
  *IOSShortArray_GetRef(nil_chk(self->x_), ((IOSObjectArray *) nil_chk(self->A_))->size_ - 1) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(self->A_, self->A_->size_ - 1)), self->A_->size_), temp);
  for (jint i = ((IOSObjectArray *) nil_chk(self->A_))->size_ - 2; i >= 0; i--) {
    
#line 297
    tmp = IOSShortArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->A_), i)), self->A_->size_);
    for (jint j = self->A_->size_ - 1; j > i; j--) {
      
#line 300
      temp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->A_), i)), j), IOSShortArray_Get(nil_chk(self->x_), j));
      tmp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_addElemWithShort_withShort_(tmp, temp);
    }
    
#line 304
    temp = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_invElemWithShort_(IOSShortArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->A_), i)), i));
    if (temp == 0) {
      
#line 307
      @throw new_JavaLangIllegalStateException_initWithNSString_(@"Not solvable equation system");
    }
    *IOSShortArray_GetRef(nil_chk(self->x_), i) = OrgBouncycastlePqcCryptoRainbowUtilGF2Field_multElemWithShort_withShort_(tmp, temp);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgBouncycastlePqcCryptoRainbowUtilComputeInField)
