//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/util/encoders/HexEncoder.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "org/bouncycastle/util/encoders/HexEncoder.h"

#if !__has_feature(objc_arc)
#error "org/bouncycastle/util/encoders/HexEncoder must be compiled with ARC (-fobjc-arc)"
#endif

@interface OrgBouncycastleUtilEncodersHexEncoder ()

+ (jboolean)ignoreWithChar:(jchar)c;

@end

__attribute__((unused)) static jboolean OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_(jchar c);

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/util/encoders/HexEncoder.java"


#line 9
@implementation OrgBouncycastleUtilEncodersHexEncoder


#line 23
- (void)initialiseDecodingTable {
  
#line 25
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(decodingTable_))->size_; i++) {
    
#line 27
    *IOSByteArray_GetRef(decodingTable_, i) = (jbyte) (jint) 0xff;
  }
  
#line 30
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(encodingTable_))->size_; i++) {
    
#line 32
    *IOSByteArray_GetRef(decodingTable_, IOSByteArray_Get(encodingTable_, i)) = (jbyte) i;
  }
  
#line 35
  *IOSByteArray_GetRef(decodingTable_, 'A') = IOSByteArray_Get(decodingTable_, 'a');
  *IOSByteArray_GetRef(decodingTable_, 'B') = IOSByteArray_Get(decodingTable_, 'b');
  *IOSByteArray_GetRef(decodingTable_, 'C') = IOSByteArray_Get(decodingTable_, 'c');
  *IOSByteArray_GetRef(decodingTable_, 'D') = IOSByteArray_Get(decodingTable_, 'd');
  *IOSByteArray_GetRef(decodingTable_, 'E') = IOSByteArray_Get(decodingTable_, 'e');
  *IOSByteArray_GetRef(decodingTable_, 'F') = IOSByteArray_Get(decodingTable_, 'f');
}

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 43
- (instancetype)init {
  OrgBouncycastleUtilEncodersHexEncoder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 48
- (jint)encodeWithByteArray:(IOSByteArray *)inBuf
                    withInt:(jint)inOff
                    withInt:(jint)inLen
              withByteArray:(IOSByteArray *)outBuf
                    withInt:(jint)outOff {
  
#line 50
  jint inPos = inOff;
  jint inEnd = inOff + inLen;
  jint outPos = outOff;
  
#line 54
  while (inPos < inEnd) {
    
#line 56
    jint b = IOSByteArray_Get(nil_chk(inBuf), inPos++) & (jint) 0xFF;
    
#line 58
    *IOSByteArray_GetRef(nil_chk(outBuf), outPos++) = IOSByteArray_Get(nil_chk(encodingTable_), JreURShift32(b, 4));
    *IOSByteArray_GetRef(outBuf, outPos++) = IOSByteArray_Get(encodingTable_, b & (jint) 0xF);
  }
  
#line 62
  return outPos - outOff;
}


#line 65
- (jint)getEncodedLengthWithInt:(jint)inputLength {
  
#line 68
  return inputLength * 2;
}

- (jint)getMaxDecodedLengthWithInt:(jint)inputLength {
  
#line 74
  return JreIntDiv(inputLength, 2);
}


#line 82
- (jint)encodeWithByteArray:(IOSByteArray *)buf
                    withInt:(jint)off
                    withInt:(jint)len
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  if (len < 0) {
    
#line 88
    return 0;
  }
  
#line 91
  IOSByteArray *tmp = [IOSByteArray newArrayWithLength:72];
  jint remaining = len;
  while (remaining > 0) {
    
#line 95
    jint inLen = JavaLangMath_minWithInt_withInt_(36, remaining);
    jint outLen = [self encodeWithByteArray:buf withInt:off withInt:inLen withByteArray:tmp withInt:0];
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:tmp withInt:0 withInt:outLen];
    off += inLen;
    remaining -= inLen;
  }
  return len * 2;
}


#line 104
+ (jboolean)ignoreWithChar:(jchar)c {
  return OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_(c);
}


#line 116
- (jint)decodeWithByteArray:(IOSByteArray *)data
                    withInt:(jint)off
                    withInt:(jint)length
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  
#line 124
  jbyte b1;
  
#line 124
  jbyte b2;
  jint outLen = 0;
  IOSByteArray *buf = [IOSByteArray newArrayWithLength:36];
  jint bufOff = 0;
  
#line 129
  jint end = off + length;
  
#line 131
  while (end > off) {
    
#line 133
    if (!OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(nil_chk(data), end - 1))) {
      
#line 135
      break;
    }
    
#line 138
    end--;
  }
  
#line 141
  jint i = off;
  while (i < end) {
    
#line 144
    while (i < end && OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(nil_chk(data), i))) {
      
#line 146
      i++;
    }
    
#line 149
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), IOSByteArray_Get(nil_chk(data), i++));
    
#line 151
    while (i < end && OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_((jchar) IOSByteArray_Get(data, i))) {
      
#line 153
      i++;
    }
    
#line 156
    b2 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    
#line 158
    if ((b1 | b2) < 0) {
      
#line 160
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered in Hex data");
    }
    
#line 163
    *IOSByteArray_GetRef(buf, bufOff++) = (jbyte) ((JreLShift32(b1, 4)) | b2);
    
#line 165
    if (bufOff == buf->size_) {
      
#line 167
      [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:buf];
      bufOff = 0;
    }
    outLen++;
  }
  
#line 173
  if (bufOff > 0) {
    
#line 175
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:buf withInt:0 withInt:bufOff];
  }
  
#line 178
  return outLen;
}


#line 187
- (jint)decodeWithNSString:(NSString *)data
    withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  
#line 193
  jbyte b1;
  
#line 193
  jbyte b2;
  jint length = 0;
  IOSByteArray *buf = [IOSByteArray newArrayWithLength:36];
  jint bufOff = 0;
  
#line 198
  jint end = [((NSString *) nil_chk(data)) java_length];
  
#line 200
  while (end > 0) {
    
#line 202
    if (!OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:end - 1])) {
      
#line 204
      break;
    }
    
#line 207
    end--;
  }
  
#line 210
  jint i = 0;
  while (i < end) {
    
#line 213
    while (i < end && OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:i])) {
      
#line 215
      i++;
    }
    
#line 218
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), [data charAtWithInt:i++]);
    
#line 220
    while (i < end && OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_([data charAtWithInt:i])) {
      
#line 222
      i++;
    }
    
#line 225
    b2 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    
#line 227
    if ((b1 | b2) < 0) {
      
#line 229
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered in Hex string");
    }
    
#line 232
    *IOSByteArray_GetRef(buf, bufOff++) = (jbyte) ((JreLShift32(b1, 4)) | b2);
    
#line 234
    if (bufOff == buf->size_) {
      
#line 236
      [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:buf];
      bufOff = 0;
    }
    
#line 240
    length++;
  }
  
#line 243
  if (bufOff > 0) {
    
#line 245
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:buf withInt:0 withInt:bufOff];
  }
  
#line 248
  return length;
}


#line 251
- (IOSByteArray *)decodeStrictWithNSString:(NSString *)str
                                   withInt:(jint)off
                                   withInt:(jint)len {
  
#line 253
  if (nil == str) {
    
#line 255
    @throw new_JavaLangNullPointerException_initWithNSString_(@"'str' cannot be null");
  }
  if (off < 0 || len < 0 || off > ([str java_length] - len)) {
    
#line 259
    @throw new_JavaLangIndexOutOfBoundsException_initWithNSString_(@"invalid offset and/or length specified");
  }
  if (0 != (len & 1)) {
    
#line 263
    @throw new_JavaIoIOException_initWithNSString_(@"a hexadecimal encoding must have an even number of characters");
  }
  
#line 266
  jint resultLen = JreURShift32(len, 1);
  IOSByteArray *result = [IOSByteArray newArrayWithLength:resultLen];
  
#line 269
  jint strPos = off;
  for (jint i = 0; i < resultLen; ++i) {
    
#line 272
    jbyte b1 = IOSByteArray_Get(nil_chk(decodingTable_), [str charAtWithInt:strPos++]);
    jbyte b2 = IOSByteArray_Get(decodingTable_, [str charAtWithInt:strPos++]);
    
#line 275
    jint n = (JreLShift32(b1, 4)) | b2;
    if (n < 0) {
      
#line 278
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered in Hex string");
    }
    
#line 281
    *IOSByteArray_GetRef(result, i) = (jbyte) n;
  }
  return result;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "I", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 5, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 0, 6, 2, -1, -1, -1 },
    { NULL, "Z", 0xa, 7, 8, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 9, 6, 2, -1, -1, -1 },
    { NULL, "I", 0x1, 9, 10, 2, -1, -1, -1 },
    { NULL, "[B", 0x0, 11, 12, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initialiseDecodingTable);
  methods[1].selector = @selector(init);
  methods[2].selector = @selector(encodeWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[3].selector = @selector(getEncodedLengthWithInt:);
  methods[4].selector = @selector(getMaxDecodedLengthWithInt:);
  methods[5].selector = @selector(encodeWithByteArray:withInt:withInt:withJavaIoOutputStream:);
  methods[6].selector = @selector(ignoreWithChar:);
  methods[7].selector = @selector(decodeWithByteArray:withInt:withInt:withJavaIoOutputStream:);
  methods[8].selector = @selector(decodeWithNSString:withJavaIoOutputStream:);
  methods[9].selector = @selector(decodeStrictWithNSString:withInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "encodingTable_", "[B", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "decodingTable_", "[B", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "encode", "[BII[BI", "LJavaIoIOException;", "getEncodedLength", "I", "getMaxDecodedLength", "[BIILJavaIoOutputStream;", "ignore", "C", "decode", "LNSString;LJavaIoOutputStream;", "decodeStrict", "LNSString;II" };
  static const J2ObjcClassInfo _OrgBouncycastleUtilEncodersHexEncoder = { "HexEncoder", "org.bouncycastle.util.encoders", ptrTable, methods, fields, 7, 0x1, 10, 2, -1, -1, -1, -1, -1 };
  return &_OrgBouncycastleUtilEncodersHexEncoder;
}

@end


#line 43
void OrgBouncycastleUtilEncodersHexEncoder_init(OrgBouncycastleUtilEncodersHexEncoder *self) {
  NSObject_init(self);
  self->encodingTable_ = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 14
    (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6', (jbyte) '7',
#line 15
    (jbyte) '8', (jbyte) '9', (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f' } count:16];
    self->decodingTable_ = [IOSByteArray newArrayWithLength:
#line 21
    128];
    
#line 45
    [self initialiseDecodingTable];
  }


#line 43
OrgBouncycastleUtilEncodersHexEncoder *new_OrgBouncycastleUtilEncodersHexEncoder_init() {
  J2OBJC_NEW_IMPL(OrgBouncycastleUtilEncodersHexEncoder, init)
}


#line 43
OrgBouncycastleUtilEncodersHexEncoder *create_OrgBouncycastleUtilEncodersHexEncoder_init() {
  J2OBJC_CREATE_IMPL(OrgBouncycastleUtilEncodersHexEncoder, init)
}


#line 104
jboolean OrgBouncycastleUtilEncodersHexEncoder_ignoreWithChar_(jchar c) {
  OrgBouncycastleUtilEncodersHexEncoder_initialize();
  
#line 107
  return c == 0x000a || c == 0x000d || c == 0x0009 || c == ' ';
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgBouncycastleUtilEncodersHexEncoder)
