//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/util/encoders/Base64Encoder.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/io/OutputStream.h"
#include "java/lang/Math.h"
#include "org/bouncycastle/util/encoders/Base64Encoder.h"

#if !__has_feature(objc_arc)
#error "org/bouncycastle/util/encoders/Base64Encoder must be compiled with ARC (-fobjc-arc)"
#endif

@interface OrgBouncycastleUtilEncodersBase64Encoder ()

- (jboolean)ignoreWithChar:(jchar)c;

- (jint)nextIWithByteArray:(IOSByteArray *)data
                   withInt:(jint)i
                   withInt:(jint)finish;

- (jint)decodeLastBlockWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                     withChar:(jchar)c1
                                     withChar:(jchar)c2
                                     withChar:(jchar)c3
                                     withChar:(jchar)c4;

- (jint)nextIWithNSString:(NSString *)data
                  withInt:(jint)i
                  withInt:(jint)finish;

@end

__attribute__((unused)) static jboolean OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(OrgBouncycastleUtilEncodersBase64Encoder *self, jchar c);

__attribute__((unused)) static jint OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(OrgBouncycastleUtilEncodersBase64Encoder *self, IOSByteArray *data, jint i, jint finish);

__attribute__((unused)) static jint OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(OrgBouncycastleUtilEncodersBase64Encoder *self, JavaIoOutputStream *outArg, jchar c1, jchar c2, jchar c3, jchar c4);

__attribute__((unused)) static jint OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(OrgBouncycastleUtilEncodersBase64Encoder *self, NSString *data, jint i, jint finish);

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/org/bouncycastle/util/encoders/Base64Encoder.java"


#line 9
@implementation OrgBouncycastleUtilEncodersBase64Encoder


#line 35
- (void)initialiseDecodingTable {
  
#line 37
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(decodingTable_))->size_; i++) {
    
#line 39
    *IOSByteArray_GetRef(decodingTable_, i) = (jbyte) (jint) 0xff;
  }
  
#line 42
  for (jint i = 0; i < ((IOSByteArray *) nil_chk(encodingTable_))->size_; i++) {
    
#line 44
    *IOSByteArray_GetRef(decodingTable_, IOSByteArray_Get(encodingTable_, i)) = (jbyte) i;
  }
}

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 48
- (instancetype)init {
  OrgBouncycastleUtilEncodersBase64Encoder_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 53
- (jint)encodeWithByteArray:(IOSByteArray *)inBuf
                    withInt:(jint)inOff
                    withInt:(jint)inLen
              withByteArray:(IOSByteArray *)outBuf
                    withInt:(jint)outOff {
  
#line 55
  jint inPos = inOff;
  jint inEnd = inOff + inLen - 2;
  jint outPos = outOff;
  
#line 59
  while (inPos < inEnd) {
    
#line 61
    jint a1 = IOSByteArray_Get(nil_chk(inBuf), inPos++);
    jint a2 = IOSByteArray_Get(inBuf, inPos++) & (jint) 0xFF;
    jint a3 = IOSByteArray_Get(inBuf, inPos++) & (jint) 0xFF;
    
#line 65
    *IOSByteArray_GetRef(nil_chk(outBuf), outPos++) = IOSByteArray_Get(nil_chk(encodingTable_), (JreURShift32(a1, 2)) & (jint) 0x3F);
    *IOSByteArray_GetRef(outBuf, outPos++) = IOSByteArray_Get(encodingTable_, ((JreLShift32(a1, 4)) | (JreURShift32(a2, 4))) & (jint) 0x3F);
    *IOSByteArray_GetRef(outBuf, outPos++) = IOSByteArray_Get(encodingTable_, ((JreLShift32(a2, 2)) | (JreURShift32(a3, 6))) & (jint) 0x3F);
    *IOSByteArray_GetRef(outBuf, outPos++) = IOSByteArray_Get(encodingTable_, a3 & (jint) 0x3F);
  }
  
#line 71
  switch (inLen - (inPos - inOff)) {
    
#line 73
    case 1:
    {
      jint a1 = IOSByteArray_Get(nil_chk(inBuf), inPos++) & (jint) 0xFF;
      
#line 77
      *IOSByteArray_GetRef(nil_chk(outBuf), outPos++) = IOSByteArray_Get(nil_chk(encodingTable_), (JreURShift32(a1, 2)) & (jint) 0x3F);
      *IOSByteArray_GetRef(outBuf, outPos++) = IOSByteArray_Get(encodingTable_, (JreLShift32(a1, 4)) & (jint) 0x3F);
      *IOSByteArray_GetRef(outBuf, outPos++) = padding_;
      *IOSByteArray_GetRef(outBuf, outPos++) = padding_;
      break;
    }
    case 2:
    {
      jint a1 = IOSByteArray_Get(nil_chk(inBuf), inPos++) & (jint) 0xFF;
      jint a2 = IOSByteArray_Get(inBuf, inPos++) & (jint) 0xFF;
      
#line 88
      *IOSByteArray_GetRef(nil_chk(outBuf), outPos++) = IOSByteArray_Get(nil_chk(encodingTable_), (JreURShift32(a1, 2)) & (jint) 0x3F);
      *IOSByteArray_GetRef(outBuf, outPos++) = IOSByteArray_Get(encodingTable_, ((JreLShift32(a1, 4)) | (JreURShift32(a2, 4))) & (jint) 0x3F);
      *IOSByteArray_GetRef(outBuf, outPos++) = IOSByteArray_Get(encodingTable_, (JreLShift32(a2, 2)) & (jint) 0x3F);
      *IOSByteArray_GetRef(outBuf, outPos++) = padding_;
      break;
    }
  }
  
#line 96
  return outPos - outOff;
}


#line 99
- (jint)getEncodedLengthWithInt:(jint)inputLength {
  
#line 102
  return JreIntDiv((inputLength + 2), 3) * 4;
}

- (jint)getMaxDecodedLengthWithInt:(jint)inputLength {
  
#line 108
  return JreIntDiv(inputLength, 4) * 3;
}


#line 116
- (jint)encodeWithByteArray:(IOSByteArray *)buf
                    withInt:(jint)off
                    withInt:(jint)len
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  if (len < 0) {
    
#line 122
    return 0;
  }
  
#line 125
  IOSByteArray *tmp = [IOSByteArray newArrayWithLength:72];
  jint remaining = len;
  while (remaining > 0) {
    
#line 129
    jint inLen = JavaLangMath_minWithInt_withInt_(54, remaining);
    jint outLen = [self encodeWithByteArray:buf withInt:off withInt:inLen withByteArray:tmp withInt:0];
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:tmp withInt:0 withInt:outLen];
    off += inLen;
    remaining -= inLen;
  }
  return JreIntDiv((len + 2), 3) * 4;
}


#line 138
- (jboolean)ignoreWithChar:(jchar)c {
  return OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, c);
}


#line 150
- (jint)decodeWithByteArray:(IOSByteArray *)data
                    withInt:(jint)off
                    withInt:(jint)length
     withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  
#line 158
  jbyte b1;
  
#line 158
  jbyte b2;
  
#line 158
  jbyte b3;
  
#line 158
  jbyte b4;
  IOSByteArray *outBuffer = [IOSByteArray newArrayWithLength:54];
  jint bufOff = 0;
  jint outLen = 0;
  
#line 163
  jint end = off + length;
  
#line 165
  while (end > off) {
    
#line 167
    if (!OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, (jchar) IOSByteArray_Get(nil_chk(data), end - 1))) {
      
#line 169
      break;
    }
    
#line 172
    end--;
  }
  
#line 176
  if (end == 0) {
    
#line 178
    return 0;
  }
  
#line 181
  jint i = 0;
  jint finish = end;
  
#line 184
  while (finish > off && i != 4) {
    
#line 186
    if (!OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, (jchar) IOSByteArray_Get(nil_chk(data), finish - 1))) {
      
#line 188
      i++;
    }
    
#line 191
    finish--;
  }
  
#line 194
  i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, off, finish);
  
#line 196
  while (i < finish) {
    
#line 198
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), IOSByteArray_Get(nil_chk(data), i++));
    
#line 200
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
    
#line 202
    b2 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    
#line 204
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
    
#line 206
    b3 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    
#line 208
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
    
#line 210
    b4 = IOSByteArray_Get(decodingTable_, IOSByteArray_Get(data, i++));
    
#line 212
    if ((b1 | b2 | b3 | b4) < 0) {
      
#line 214
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered in base64 data");
    }
    
#line 217
    *IOSByteArray_GetRef(outBuffer, bufOff++) = (jbyte) ((JreLShift32(b1, 2)) | (JreRShift32(b2, 4)));
    *IOSByteArray_GetRef(outBuffer, bufOff++) = (jbyte) ((JreLShift32(b2, 4)) | (JreRShift32(b3, 2)));
    *IOSByteArray_GetRef(outBuffer, bufOff++) = (jbyte) ((JreLShift32(b3, 6)) | b4);
    
#line 221
    if (bufOff == outBuffer->size_) {
      
#line 223
      [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:outBuffer];
      bufOff = 0;
    }
    
#line 227
    outLen += 3;
    
#line 229
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
  }
  
#line 232
  if (bufOff > 0) {
    
#line 234
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:outBuffer withInt:0 withInt:bufOff];
  }
  
#line 237
  jint e0 = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, end);
  jint e1 = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, e0 + 1, end);
  jint e2 = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, e1 + 1, end);
  jint e3 = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, e2 + 1, end);
  
#line 242
  outLen += OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(self, outArg, (jchar) IOSByteArray_Get(nil_chk(data), e0), (jchar) IOSByteArray_Get(data, e1), (jchar) IOSByteArray_Get(data, e2), (jchar) IOSByteArray_Get(data, e3));
  
#line 244
  return outLen;
}


#line 247
- (jint)nextIWithByteArray:(IOSByteArray *)data
                   withInt:(jint)i
                   withInt:(jint)finish {
  return OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(self, data, i, finish);
}


#line 262
- (jint)decodeWithNSString:(NSString *)data
    withJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  
#line 268
  jbyte b1;
  
#line 268
  jbyte b2;
  
#line 268
  jbyte b3;
  
#line 268
  jbyte b4;
  IOSByteArray *outBuffer = [IOSByteArray newArrayWithLength:54];
  jint bufOff = 0;
  jint length = 0;
  
#line 273
  jint end = [((NSString *) nil_chk(data)) java_length];
  
#line 275
  while (end > 0) {
    
#line 277
    if (!OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, [data charAtWithInt:end - 1])) {
      
#line 279
      break;
    }
    
#line 282
    end--;
  }
  
#line 286
  if (end == 0) {
    
#line 288
    return 0;
  }
  
#line 291
  jint i = 0;
  jint finish = end;
  
#line 294
  while (finish > 0 && i != 4) {
    
#line 296
    if (!OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, [data charAtWithInt:finish - 1])) {
      
#line 298
      i++;
    }
    
#line 301
    finish--;
  }
  
#line 304
  i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, 0, finish);
  
#line 306
  while (i < finish) {
    
#line 308
    b1 = IOSByteArray_Get(nil_chk(decodingTable_), [data charAtWithInt:i++]);
    
#line 310
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
    
#line 312
    b2 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    
#line 314
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
    
#line 316
    b3 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    
#line 318
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
    
#line 320
    b4 = IOSByteArray_Get(decodingTable_, [data charAtWithInt:i++]);
    
#line 322
    if ((b1 | b2 | b3 | b4) < 0) {
      
#line 324
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered in base64 data");
    }
    
#line 327
    *IOSByteArray_GetRef(outBuffer, bufOff++) = (jbyte) ((JreLShift32(b1, 2)) | (JreRShift32(b2, 4)));
    *IOSByteArray_GetRef(outBuffer, bufOff++) = (jbyte) ((JreLShift32(b2, 4)) | (JreRShift32(b3, 2)));
    *IOSByteArray_GetRef(outBuffer, bufOff++) = (jbyte) ((JreLShift32(b3, 6)) | b4);
    
#line 331
    length += 3;
    if (bufOff == outBuffer->size_) {
      
#line 334
      [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:outBuffer];
      bufOff = 0;
    }
    
#line 338
    i = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
  }
  
#line 341
  if (bufOff > 0) {
    
#line 343
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithByteArray:outBuffer withInt:0 withInt:bufOff];
  }
  
#line 346
  jint e0 = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, end);
  jint e1 = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, e0 + 1, end);
  jint e2 = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, e1 + 1, end);
  jint e3 = OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, e2 + 1, end);
  
#line 351
  length += OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(self, outArg, [data charAtWithInt:e0], [data charAtWithInt:e1], [data charAtWithInt:e2], [data charAtWithInt:e3]);
  
#line 353
  return length;
}


#line 356
- (jint)decodeLastBlockWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                     withChar:(jchar)c1
                                     withChar:(jchar)c2
                                     withChar:(jchar)c3
                                     withChar:(jchar)c4 {
  return OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(self, outArg, c1, c2, c3, c4);
}


#line 416
- (jint)nextIWithNSString:(NSString *)data
                  withInt:(jint)i
                  withInt:(jint)finish {
  return OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(self, data, i, finish);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "V", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "I", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 5, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 0, 6, 2, -1, -1, -1 },
    { NULL, "Z", 0x2, 7, 8, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 9, 6, 2, -1, -1, -1 },
    { NULL, "I", 0x2, 10, 11, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 9, 12, 2, -1, -1, -1 },
    { NULL, "I", 0x2, 13, 14, 2, -1, -1, -1 },
    { NULL, "I", 0x2, 10, 15, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initialiseDecodingTable);
  methods[1].selector = @selector(init);
  methods[2].selector = @selector(encodeWithByteArray:withInt:withInt:withByteArray:withInt:);
  methods[3].selector = @selector(getEncodedLengthWithInt:);
  methods[4].selector = @selector(getMaxDecodedLengthWithInt:);
  methods[5].selector = @selector(encodeWithByteArray:withInt:withInt:withJavaIoOutputStream:);
  methods[6].selector = @selector(ignoreWithChar:);
  methods[7].selector = @selector(decodeWithByteArray:withInt:withInt:withJavaIoOutputStream:);
  methods[8].selector = @selector(nextIWithByteArray:withInt:withInt:);
  methods[9].selector = @selector(decodeWithNSString:withJavaIoOutputStream:);
  methods[10].selector = @selector(decodeLastBlockWithJavaIoOutputStream:withChar:withChar:withChar:withChar:);
  methods[11].selector = @selector(nextIWithNSString:withInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "encodingTable_", "[B", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
    { "padding_", "B", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "decodingTable_", "[B", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "encode", "[BII[BI", "LJavaIoIOException;", "getEncodedLength", "I", "getMaxDecodedLength", "[BIILJavaIoOutputStream;", "ignore", "C", "decode", "nextI", "[BII", "LNSString;LJavaIoOutputStream;", "decodeLastBlock", "LJavaIoOutputStream;CCCC", "LNSString;II" };
  static const J2ObjcClassInfo _OrgBouncycastleUtilEncodersBase64Encoder = { "Base64Encoder", "org.bouncycastle.util.encoders", ptrTable, methods, fields, 7, 0x1, 12, 3, -1, -1, -1, -1, -1 };
  return &_OrgBouncycastleUtilEncodersBase64Encoder;
}

@end


#line 48
void OrgBouncycastleUtilEncodersBase64Encoder_init(OrgBouncycastleUtilEncodersBase64Encoder *self) {
  NSObject_init(self);
  self->encodingTable_ = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 14
    (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G',
#line 15
    (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N',
#line 16
    (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U',
#line 17
    (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z',
#line 18
    (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g',
#line 19
    (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n',
#line 20
    (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u',
#line 21
    (jbyte) 'v',
#line 22
    (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z',
#line 23
    (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6',
#line 24
    (jbyte) '7', (jbyte) '8', (jbyte) '9',
#line 25
    (jbyte) '+', (jbyte) '/' } count:64];
    self->padding_ =
#line 28
    (jbyte) '=';
    self->decodingTable_ = [IOSByteArray newArrayWithLength:
#line 33
    128];
    
#line 50
    [self initialiseDecodingTable];
  }


#line 48
OrgBouncycastleUtilEncodersBase64Encoder *new_OrgBouncycastleUtilEncodersBase64Encoder_init() {
  J2OBJC_NEW_IMPL(OrgBouncycastleUtilEncodersBase64Encoder, init)
}


#line 48
OrgBouncycastleUtilEncodersBase64Encoder *create_OrgBouncycastleUtilEncodersBase64Encoder_init() {
  J2OBJC_CREATE_IMPL(OrgBouncycastleUtilEncodersBase64Encoder, init)
}


#line 138
jboolean OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(OrgBouncycastleUtilEncodersBase64Encoder *self, jchar c) {
  
#line 141
  return (c == 0x000a || c == 0x000d || c == 0x0009 || c == ' ');
}


#line 247
jint OrgBouncycastleUtilEncodersBase64Encoder_nextIWithByteArray_withInt_withInt_(OrgBouncycastleUtilEncodersBase64Encoder *self, IOSByteArray *data, jint i, jint finish) {
  
#line 249
  while ((i < finish) && OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, (jchar) IOSByteArray_Get(nil_chk(data), i))) {
    
#line 251
    i++;
  }
  return i;
}


#line 356
jint OrgBouncycastleUtilEncodersBase64Encoder_decodeLastBlockWithJavaIoOutputStream_withChar_withChar_withChar_withChar_(OrgBouncycastleUtilEncodersBase64Encoder *self, JavaIoOutputStream *outArg, jchar c1, jchar c2, jchar c3, jchar c4) {
  
#line 359
  jbyte b1;
  
#line 359
  jbyte b2;
  
#line 359
  jbyte b3;
  
#line 359
  jbyte b4;
  
#line 361
  if (c3 == self->padding_) {
    
#line 363
    if (c4 != self->padding_) {
      
#line 365
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered at end of base64 data");
    }
    
#line 368
    b1 = IOSByteArray_Get(nil_chk(self->decodingTable_), c1);
    b2 = IOSByteArray_Get(self->decodingTable_, c2);
    
#line 371
    if ((b1 | b2) < 0) {
      
#line 373
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered at end of base64 data");
    }
    
#line 376
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(JreLShift32(b1, 2)) | (JreRShift32(b2, 4))];
    
#line 378
    return 1;
  }
  else if (c4 == self->padding_) {
    
#line 382
    b1 = IOSByteArray_Get(nil_chk(self->decodingTable_), c1);
    b2 = IOSByteArray_Get(self->decodingTable_, c2);
    b3 = IOSByteArray_Get(self->decodingTable_, c3);
    
#line 386
    if ((b1 | b2 | b3) < 0) {
      
#line 388
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered at end of base64 data");
    }
    
#line 391
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(JreLShift32(b1, 2)) | (JreRShift32(b2, 4))];
    [outArg writeWithInt:(JreLShift32(b2, 4)) | (JreRShift32(b3, 2))];
    
#line 394
    return 2;
  }
  else {
    
#line 398
    b1 = IOSByteArray_Get(nil_chk(self->decodingTable_), c1);
    b2 = IOSByteArray_Get(self->decodingTable_, c2);
    b3 = IOSByteArray_Get(self->decodingTable_, c3);
    b4 = IOSByteArray_Get(self->decodingTable_, c4);
    
#line 403
    if ((b1 | b2 | b3 | b4) < 0) {
      
#line 405
      @throw new_JavaIoIOException_initWithNSString_(@"invalid characters encountered at end of base64 data");
    }
    
#line 408
    [((JavaIoOutputStream *) nil_chk(outArg)) writeWithInt:(JreLShift32(b1, 2)) | (JreRShift32(b2, 4))];
    [outArg writeWithInt:(JreLShift32(b2, 4)) | (JreRShift32(b3, 2))];
    [outArg writeWithInt:(JreLShift32(b3, 6)) | b4];
    
#line 412
    return 3;
  }
}


#line 416
jint OrgBouncycastleUtilEncodersBase64Encoder_nextIWithNSString_withInt_withInt_(OrgBouncycastleUtilEncodersBase64Encoder *self, NSString *data, jint i, jint finish) {
  
#line 418
  while ((i < finish) && OrgBouncycastleUtilEncodersBase64Encoder_ignoreWithChar_(self, [((NSString *) nil_chk(data)) charAtWithInt:i])) {
    
#line 420
    i++;
  }
  return i;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgBouncycastleUtilEncodersBase64Encoder)
