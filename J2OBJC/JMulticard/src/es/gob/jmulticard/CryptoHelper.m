//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/CryptoHelper.java
//

#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "es/gob/jmulticard/CryptoHelper.h"
#include "es/gob/jmulticard/DigestAlgorithm.h"
#include "es/gob/jmulticard/apdu/iso7816four/pace/PaceChat.h"
#include "es/gob/jmulticard/asn1/Tlv.h"
#include "es/gob/jmulticard/asn1/icao/CardAccess.h"
#include "es/gob/jmulticard/card/icao/WirelessInitializer.h"
#include "es/gob/jmulticard/connection/ApduConnection.h"
#include "es/gob/jmulticard/connection/pace/SecureMessaging.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/InputStream.h"
#include "java/lang/Enum.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "java/security/KeyPair.h"
#include "java/security/cert/Certificate.h"
#include "java/security/cert/CertificateFactory.h"
#include "java/security/cert/X509Certificate.h"
#include "java/security/interfaces/RSAKey.h"
#include "java/security/interfaces/RSAPublicKey.h"
#include "java/security/spec/AlgorithmParameterSpec.h"

#if !__has_feature(objc_arc)
#error "es/gob/jmulticard/CryptoHelper must be compiled with ARC (-fobjc-arc)"
#endif

inline jbyte EsGobJmulticardCryptoHelper_get_PKCS1_BLOCK_TYPE(void);
#define EsGobJmulticardCryptoHelper_PKCS1_BLOCK_TYPE 1
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardCryptoHelper, PKCS1_BLOCK_TYPE, jbyte)

inline jbyte EsGobJmulticardCryptoHelper_get_PKCS1_FILL(void);
#define EsGobJmulticardCryptoHelper_PKCS1_FILL -1
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardCryptoHelper, PKCS1_FILL, jbyte)

inline jbyte EsGobJmulticardCryptoHelper_get_PKCS1_DELIMIT(void);
#define EsGobJmulticardCryptoHelper_PKCS1_DELIMIT 0
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardCryptoHelper, PKCS1_DELIMIT, jbyte)

@interface EsGobJmulticardCryptoHelper_Padding () {
 @public
  NSString *algName_;
}

@end

J2OBJC_FIELD_SETTER(EsGobJmulticardCryptoHelper_Padding, algName_, NSString *)

__attribute__((unused)) static void EsGobJmulticardCryptoHelper_Padding_initWithNSString_withNSString_withInt_(EsGobJmulticardCryptoHelper_Padding *self, NSString *alg, NSString *__name, jint __ordinal);

__attribute__((unused)) static EsGobJmulticardCryptoHelper_Padding *new_EsGobJmulticardCryptoHelper_Padding_initWithNSString_withNSString_withInt_(NSString *alg, NSString *__name, jint __ordinal) NS_RETURNS_RETAINED;

__attribute__((unused)) static void EsGobJmulticardCryptoHelper_BlockMode_initWithNSString_withInt_(EsGobJmulticardCryptoHelper_BlockMode *self, NSString *__name, jint __ordinal);

__attribute__((unused)) static EsGobJmulticardCryptoHelper_BlockMode *new_EsGobJmulticardCryptoHelper_BlockMode_initWithNSString_withInt_(NSString *__name, jint __ordinal) NS_RETURNS_RETAINED;

@interface EsGobJmulticardCryptoHelper_EcCurve () {
 @public
  NSString *name_EcCurve_;
}

@end

J2OBJC_FIELD_SETTER(EsGobJmulticardCryptoHelper_EcCurve, name_EcCurve_, NSString *)

__attribute__((unused)) static void EsGobJmulticardCryptoHelper_EcCurve_initWithNSString_withNSString_withInt_(EsGobJmulticardCryptoHelper_EcCurve *self, NSString *n, NSString *__name, jint __ordinal);

__attribute__((unused)) static EsGobJmulticardCryptoHelper_EcCurve *new_EsGobJmulticardCryptoHelper_EcCurve_initWithNSString_withNSString_withInt_(NSString *n, NSString *__name, jint __ordinal) NS_RETURNS_RETAINED;

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/CryptoHelper.java"


#line 70
@implementation EsGobJmulticardCryptoHelper

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 70
- (instancetype)init {
  EsGobJmulticardCryptoHelper_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 130
+ (IOSByteArray *)addPkcs1PaddingForPrivateKeyOperationWithByteArray:(IOSByteArray *)inByteArray
                                                             withInt:(jint)keySize {
  return EsGobJmulticardCryptoHelper_addPkcs1PaddingForPrivateKeyOperationWithByteArray_withInt_(inByteArray, keySize);
}


#line 158
- (IOSByteArray *)digestWithEsGobJmulticardDigestAlgorithm:(EsGobJmulticardDigestAlgorithm *)algorithm
                                             withByteArray:(IOSByteArray *)data {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 169
- (IOSByteArray *)desedeEncryptWithByteArray:(IOSByteArray *)data
                               withByteArray:(IOSByteArray *)key {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 179
- (IOSByteArray *)desedeDecryptWithByteArray:(IOSByteArray *)data
                               withByteArray:(IOSByteArray *)key {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (IOSByteArray *)desEncryptWithByteArray:(IOSByteArray *)data
                            withByteArray:(IOSByteArray *)key {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (IOSByteArray *)desDecryptWithByteArray:(IOSByteArray *)data
                            withByteArray:(IOSByteArray *)key {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 204
- (IOSByteArray *)aesDecryptWithByteArray:(IOSByteArray *)data
                            withByteArray:(IOSByteArray *)iv
                            withByteArray:(IOSByteArray *)key
withEsGobJmulticardCryptoHelper_BlockMode:(EsGobJmulticardCryptoHelper_BlockMode *)blockMode
  withEsGobJmulticardCryptoHelper_Padding:(EsGobJmulticardCryptoHelper_Padding *)padding {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 219
- (IOSByteArray *)aesEncryptWithByteArray:(IOSByteArray *)data
                            withByteArray:(IOSByteArray *)iv
                            withByteArray:(IOSByteArray *)key
withEsGobJmulticardCryptoHelper_BlockMode:(EsGobJmulticardCryptoHelper_BlockMode *)blockMode
  withEsGobJmulticardCryptoHelper_Padding:(EsGobJmulticardCryptoHelper_Padding *)padding {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 230
- (IOSByteArray *)rsaDecryptWithByteArray:(IOSByteArray *)cipheredData
         withJavaSecurityInterfacesRSAKey:(id<JavaSecurityInterfacesRSAKey>)key {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (IOSByteArray *)rsaEncryptWithByteArray:(IOSByteArray *)data
         withJavaSecurityInterfacesRSAKey:(id<JavaSecurityInterfacesRSAKey>)key {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 243
- (IOSByteArray *)generateRandomBytesWithInt:(jint)numBytes {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 250
- (JavaSecurityKeyPair *)generateEcKeyPairWithEsGobJmulticardCryptoHelper_EcCurve:(EsGobJmulticardCryptoHelper_EcCurve *)curveName {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 259
- (IOSByteArray *)doAesCmacWithByteArray:(IOSByteArray *)data
                           withByteArray:(IOSByteArray *)key {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 267
- (id<JavaSecuritySpecAlgorithmParameterSpec>)getEcPointWithByteArray:(IOSByteArray *)nonceS
                                                        withByteArray:(IOSByteArray *)sharedSecretH
                              withEsGobJmulticardCryptoHelper_EcCurve:(EsGobJmulticardCryptoHelper_EcCurve *)curveName {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (IOSByteArray *)getCmsSignatureSignedContentWithByteArray:(IOSByteArray *)signedDataBytes {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 283
- (IOSObjectArray *)validateCmsSignatureWithByteArray:(IOSByteArray *)signedDataBytes {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 291
+ (JavaSecurityCertX509Certificate *)generateCertificateWithByteArray:(IOSByteArray *)encoded {
  return EsGobJmulticardCryptoHelper_generateCertificateWithByteArray_(encoded);
}


#line 300
+ (JavaSecurityCertX509Certificate *)generateCertificateWithJavaIoInputStream:(JavaIoInputStream *)is {
  return EsGobJmulticardCryptoHelper_generateCertificateWithJavaIoInputStream_(is);
}


#line 311
- (id<JavaSecurityInterfacesRSAPublicKey>)getRsaPublicKeyWithJavaSecurityCertX509Certificate:(JavaSecurityCertX509Certificate *)cert {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 318
- (EsGobJmulticardCryptoHelper_PaceChannelHelper *)getPaceChannelHelperWithEsGobJmulticardAsn1IcaoCardAccess:(EsGobJmulticardAsn1IcaoCardAccess *)cardAccess
                                                              withEsGobJmulticardApduIso7816fourPacePaceChat:(EsGobJmulticardApduIso7816fourPacePaceChat *)paceChat {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x19, 0, 1, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 3, 4, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 5, 6, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 7, 6, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 8, 6, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 9, 6, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 10, 11, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 12, 11, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 13, 14, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 15, 14, 2, -1, -1, -1 },
    { NULL, "[B", 0x401, 16, 17, 2, -1, -1, -1 },
    { NULL, "LJavaSecurityKeyPair;", 0x401, 18, 19, 20, -1, -1, -1 },
    { NULL, "[B", 0x401, 21, 6, 22, -1, -1, -1 },
    { NULL, "LJavaSecuritySpecAlgorithmParameterSpec;", 0x401, 23, 24, -1, -1, -1, -1 },
    { NULL, "[B", 0x401, 25, 26, 2, -1, -1, -1 },
    { NULL, "[LJavaSecurityCertX509Certificate;", 0x401, 27, 26, 28, -1, -1, -1 },
    { NULL, "LJavaSecurityCertX509Certificate;", 0x9, 29, 26, 30, -1, -1, -1 },
    { NULL, "LJavaSecurityCertX509Certificate;", 0x9, 29, 31, 30, -1, -1, -1 },
    { NULL, "LJavaSecurityInterfacesRSAPublicKey;", 0x401, 32, 33, -1, -1, -1, -1 },
    { NULL, "LEsGobJmulticardCryptoHelper_PaceChannelHelper;", 0x401, 34, 35, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(addPkcs1PaddingForPrivateKeyOperationWithByteArray:withInt:);
  methods[2].selector = @selector(digestWithEsGobJmulticardDigestAlgorithm:withByteArray:);
  methods[3].selector = @selector(desedeEncryptWithByteArray:withByteArray:);
  methods[4].selector = @selector(desedeDecryptWithByteArray:withByteArray:);
  methods[5].selector = @selector(desEncryptWithByteArray:withByteArray:);
  methods[6].selector = @selector(desDecryptWithByteArray:withByteArray:);
  methods[7].selector = @selector(aesDecryptWithByteArray:withByteArray:withByteArray:withEsGobJmulticardCryptoHelper_BlockMode:withEsGobJmulticardCryptoHelper_Padding:);
  methods[8].selector = @selector(aesEncryptWithByteArray:withByteArray:withByteArray:withEsGobJmulticardCryptoHelper_BlockMode:withEsGobJmulticardCryptoHelper_Padding:);
  methods[9].selector = @selector(rsaDecryptWithByteArray:withJavaSecurityInterfacesRSAKey:);
  methods[10].selector = @selector(rsaEncryptWithByteArray:withJavaSecurityInterfacesRSAKey:);
  methods[11].selector = @selector(generateRandomBytesWithInt:);
  methods[12].selector = @selector(generateEcKeyPairWithEsGobJmulticardCryptoHelper_EcCurve:);
  methods[13].selector = @selector(doAesCmacWithByteArray:withByteArray:);
  methods[14].selector = @selector(getEcPointWithByteArray:withByteArray:withEsGobJmulticardCryptoHelper_EcCurve:);
  methods[15].selector = @selector(getCmsSignatureSignedContentWithByteArray:);
  methods[16].selector = @selector(validateCmsSignatureWithByteArray:);
  methods[17].selector = @selector(generateCertificateWithByteArray:);
  methods[18].selector = @selector(generateCertificateWithJavaIoInputStream:);
  methods[19].selector = @selector(getRsaPublicKeyWithJavaSecurityCertX509Certificate:);
  methods[20].selector = @selector(getPaceChannelHelperWithEsGobJmulticardAsn1IcaoCardAccess:withEsGobJmulticardApduIso7816fourPacePaceChat:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "PKCS1_BLOCK_TYPE", "B", .constantValue.asChar = EsGobJmulticardCryptoHelper_PKCS1_BLOCK_TYPE, 0x1a, -1, -1, -1, -1 },
    { "PKCS1_FILL", "B", .constantValue.asChar = EsGobJmulticardCryptoHelper_PKCS1_FILL, 0x1a, -1, -1, -1, -1 },
    { "PKCS1_DELIMIT", "B", .constantValue.asChar = EsGobJmulticardCryptoHelper_PKCS1_DELIMIT, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "addPkcs1PaddingForPrivateKeyOperation", "[BI", "LJavaIoIOException;", "digest", "LEsGobJmulticardDigestAlgorithm;[B", "desedeEncrypt", "[B[B", "desedeDecrypt", "desEncrypt", "desDecrypt", "aesDecrypt", "[B[B[BLEsGobJmulticardCryptoHelper_BlockMode;LEsGobJmulticardCryptoHelper_Padding;", "aesEncrypt", "rsaDecrypt", "[BLJavaSecurityInterfacesRSAKey;", "rsaEncrypt", "generateRandomBytes", "I", "generateEcKeyPair", "LEsGobJmulticardCryptoHelper_EcCurve;", "LJavaSecurityNoSuchAlgorithmException;LJavaSecurityInvalidAlgorithmParameterException;", "doAesCmac", "LJavaSecurityNoSuchAlgorithmException;LJavaSecurityInvalidKeyException;", "getEcPoint", "[B[BLEsGobJmulticardCryptoHelper_EcCurve;", "getCmsSignatureSignedContent", "[B", "validateCmsSignature", "LJavaSecuritySignatureException;LJavaIoIOException;LJavaSecurityCertCertificateException;", "generateCertificate", "LJavaSecurityCertCertificateException;", "LJavaIoInputStream;", "getRsaPublicKey", "LJavaSecurityCertX509Certificate;", "getPaceChannelHelper", "LEsGobJmulticardAsn1IcaoCardAccess;LEsGobJmulticardApduIso7816fourPacePaceChat;", "LEsGobJmulticardCryptoHelper_Padding;LEsGobJmulticardCryptoHelper_BlockMode;LEsGobJmulticardCryptoHelper_EcCurve;LEsGobJmulticardCryptoHelper_PaceChannelHelper;" };
  static const J2ObjcClassInfo _EsGobJmulticardCryptoHelper = { "CryptoHelper", "es.gob.jmulticard", ptrTable, methods, fields, 7, 0x401, 21, 3, -1, 36, -1, -1, -1 };
  return &_EsGobJmulticardCryptoHelper;
}

@end


#line 70
void EsGobJmulticardCryptoHelper_init(EsGobJmulticardCryptoHelper *self) {
  NSObject_init(self);
}


#line 130
IOSByteArray *EsGobJmulticardCryptoHelper_addPkcs1PaddingForPrivateKeyOperationWithByteArray_withInt_(IOSByteArray *inByteArray, jint keySize) {
  EsGobJmulticardCryptoHelper_initialize();
  if (inByteArray == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"Los datos de entrada no pueden ser nulos");
  }
  jint len = JreIntDiv(keySize, 8);
  if (inByteArray->size_ > len - 3) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I$I$", @"Los datos son demasiado grandes para el valor de clave indicado: ",
#line 138
    inByteArray->size_, @" > ", len, @"-3"));
  }
  
#line 141
  JavaIoByteArrayOutputStream *baos = new_JavaIoByteArrayOutputStream_initWithInt_(len);
  [baos writeWithInt:EsGobJmulticardCryptoHelper_PKCS1_DELIMIT];
  [baos writeWithInt:EsGobJmulticardCryptoHelper_PKCS1_BLOCK_TYPE];
  while ([baos size] < len - (1 + inByteArray->size_)) {
    [baos writeWithInt:EsGobJmulticardCryptoHelper_PKCS1_FILL];
  }
  [baos writeWithInt:EsGobJmulticardCryptoHelper_PKCS1_DELIMIT];
  [baos writeWithByteArray:inByteArray];
  
#line 150
  return [baos toByteArray];
}


#line 291
JavaSecurityCertX509Certificate *EsGobJmulticardCryptoHelper_generateCertificateWithByteArray_(IOSByteArray *encoded) {
  EsGobJmulticardCryptoHelper_initialize();
  
#line 292
  return EsGobJmulticardCryptoHelper_generateCertificateWithJavaIoInputStream_(new_JavaIoByteArrayInputStream_initWithByteArray_(encoded));
}


#line 300
JavaSecurityCertX509Certificate *EsGobJmulticardCryptoHelper_generateCertificateWithJavaIoInputStream_(JavaIoInputStream *is) {
  EsGobJmulticardCryptoHelper_initialize();
  
#line 301
  JavaSecurityCertCertificateFactory *cf = JavaSecurityCertCertificateFactory_getInstanceWithNSString_(@"X.509");
  return (JavaSecurityCertX509Certificate *) cast_chk([((JavaSecurityCertCertificateFactory *) nil_chk(cf)) generateCertificateWithJavaIoInputStream:is], [JavaSecurityCertX509Certificate class]);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardCryptoHelper)

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/CryptoHelper.java"

J2OBJC_INITIALIZED_DEFN(EsGobJmulticardCryptoHelper_Padding)

EsGobJmulticardCryptoHelper_Padding *EsGobJmulticardCryptoHelper_Padding_values_[2];


#line 73
@implementation EsGobJmulticardCryptoHelper_Padding


#line 87
- (NSString *)description {
  
#line 89
  return algName_;
}

+ (IOSObjectArray *)values {
  return EsGobJmulticardCryptoHelper_Padding_values();
}

+ (EsGobJmulticardCryptoHelper_Padding *)valueOfWithNSString:(NSString *)name {
  return EsGobJmulticardCryptoHelper_Padding_valueOfWithNSString_(name);
}

- (EsGobJmulticardCryptoHelper_Padding_Enum)toNSEnum {
  return (EsGobJmulticardCryptoHelper_Padding_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNSString;", 0x1, 0, -1, -1, -1, -1, -1 },
    { NULL, "[LEsGobJmulticardCryptoHelper_Padding;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEsGobJmulticardCryptoHelper_Padding;", 0x9, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(description);
  methods[1].selector = @selector(values);
  methods[2].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NOPADDING", "LEsGobJmulticardCryptoHelper_Padding;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "ISO7816_4PADDING", "LEsGobJmulticardCryptoHelper_Padding;", .constantValue.asLong = 0, 0x4019, -1, 4, -1, -1 },
    { "algName_", "LNSString;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "toString", "valueOf", "LNSString;", &JreEnum(EsGobJmulticardCryptoHelper_Padding, NOPADDING), &JreEnum(EsGobJmulticardCryptoHelper_Padding, ISO7816_4PADDING), "LEsGobJmulticardCryptoHelper;", "Ljava/lang/Enum<Les/gob/jmulticard/CryptoHelper$Padding;>;" };
  static const J2ObjcClassInfo _EsGobJmulticardCryptoHelper_Padding = { "Padding", "es.gob.jmulticard", ptrTable, methods, fields, 7, 0x4019, 3, 3, 5, -1, -1, 6, -1 };
  return &_EsGobJmulticardCryptoHelper_Padding;
}

+ (void)initialize {
  if (self == [EsGobJmulticardCryptoHelper_Padding class]) {
    JreEnum(EsGobJmulticardCryptoHelper_Padding, NOPADDING) = new_EsGobJmulticardCryptoHelper_Padding_initWithNSString_withNSString_withInt_(
#line 76
    @"NOPADDING", JreEnumConstantName(EsGobJmulticardCryptoHelper_Padding_class_(), 0), 0);
    JreEnum(EsGobJmulticardCryptoHelper_Padding, ISO7816_4PADDING) = new_EsGobJmulticardCryptoHelper_Padding_initWithNSString_withNSString_withInt_(
#line 79
    @"ISO7816-4Padding", JreEnumConstantName(EsGobJmulticardCryptoHelper_Padding_class_(), 1), 1);
    J2OBJC_SET_INITIALIZED(EsGobJmulticardCryptoHelper_Padding)
  }
}

@end


#line 83
void EsGobJmulticardCryptoHelper_Padding_initWithNSString_withNSString_withInt_(EsGobJmulticardCryptoHelper_Padding *self, NSString *alg, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
  
#line 84
  self->algName_ = alg;
}


#line 83
EsGobJmulticardCryptoHelper_Padding *new_EsGobJmulticardCryptoHelper_Padding_initWithNSString_withNSString_withInt_(NSString *alg, NSString *__name, jint __ordinal) {
  J2OBJC_NEW_IMPL(EsGobJmulticardCryptoHelper_Padding, initWithNSString_withNSString_withInt_, alg, __name, __ordinal)
}

IOSObjectArray *EsGobJmulticardCryptoHelper_Padding_values() {
  EsGobJmulticardCryptoHelper_Padding_initialize();
  return [IOSObjectArray arrayWithObjects:EsGobJmulticardCryptoHelper_Padding_values_ count:2 type:EsGobJmulticardCryptoHelper_Padding_class_()];
}

EsGobJmulticardCryptoHelper_Padding *EsGobJmulticardCryptoHelper_Padding_valueOfWithNSString_(NSString *name) {
  EsGobJmulticardCryptoHelper_Padding_initialize();
  for (int i = 0; i < 2; i++) {
    EsGobJmulticardCryptoHelper_Padding *e = EsGobJmulticardCryptoHelper_Padding_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

EsGobJmulticardCryptoHelper_Padding *EsGobJmulticardCryptoHelper_Padding_fromOrdinal(NSUInteger ordinal) {
  EsGobJmulticardCryptoHelper_Padding_initialize();
  if (ordinal >= 2) {
    return nil;
  }
  return EsGobJmulticardCryptoHelper_Padding_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardCryptoHelper_Padding)

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/CryptoHelper.java"

J2OBJC_INITIALIZED_DEFN(EsGobJmulticardCryptoHelper_BlockMode)

EsGobJmulticardCryptoHelper_BlockMode *EsGobJmulticardCryptoHelper_BlockMode_values_[2];


#line 94
@implementation EsGobJmulticardCryptoHelper_BlockMode

+ (IOSObjectArray *)values {
  return EsGobJmulticardCryptoHelper_BlockMode_values();
}

+ (EsGobJmulticardCryptoHelper_BlockMode *)valueOfWithNSString:(NSString *)name {
  return EsGobJmulticardCryptoHelper_BlockMode_valueOfWithNSString_(name);
}

- (EsGobJmulticardCryptoHelper_BlockMode_Enum)toNSEnum {
  return (EsGobJmulticardCryptoHelper_BlockMode_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[LEsGobJmulticardCryptoHelper_BlockMode;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEsGobJmulticardCryptoHelper_BlockMode;", 0x9, 0, 1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(values);
  methods[1].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "CBC", "LEsGobJmulticardCryptoHelper_BlockMode;", .constantValue.asLong = 0, 0x4019, -1, 2, -1, -1 },
    { "ECB", "LEsGobJmulticardCryptoHelper_BlockMode;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
  };
  static const void *ptrTable[] = { "valueOf", "LNSString;", &JreEnum(EsGobJmulticardCryptoHelper_BlockMode, CBC), &JreEnum(EsGobJmulticardCryptoHelper_BlockMode, ECB), "LEsGobJmulticardCryptoHelper;", "Ljava/lang/Enum<Les/gob/jmulticard/CryptoHelper$BlockMode;>;" };
  static const J2ObjcClassInfo _EsGobJmulticardCryptoHelper_BlockMode = { "BlockMode", "es.gob.jmulticard", ptrTable, methods, fields, 7, 0x4019, 2, 2, 4, -1, -1, 5, -1 };
  return &_EsGobJmulticardCryptoHelper_BlockMode;
}

+ (void)initialize {
  if (self == [EsGobJmulticardCryptoHelper_BlockMode class]) {
    JreEnum(EsGobJmulticardCryptoHelper_BlockMode, CBC) = new_EsGobJmulticardCryptoHelper_BlockMode_initWithNSString_withInt_(JreEnumConstantName(EsGobJmulticardCryptoHelper_BlockMode_class_(), 0), 0);
    JreEnum(EsGobJmulticardCryptoHelper_BlockMode, ECB) = new_EsGobJmulticardCryptoHelper_BlockMode_initWithNSString_withInt_(JreEnumConstantName(EsGobJmulticardCryptoHelper_BlockMode_class_(), 1), 1);
    J2OBJC_SET_INITIALIZED(EsGobJmulticardCryptoHelper_BlockMode)
  }
}

@end


#line 94
void EsGobJmulticardCryptoHelper_BlockMode_initWithNSString_withInt_(EsGobJmulticardCryptoHelper_BlockMode *self, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
}


#line 94
EsGobJmulticardCryptoHelper_BlockMode *new_EsGobJmulticardCryptoHelper_BlockMode_initWithNSString_withInt_(NSString *__name, jint __ordinal) {
  J2OBJC_NEW_IMPL(EsGobJmulticardCryptoHelper_BlockMode, initWithNSString_withInt_, __name, __ordinal)
}

IOSObjectArray *EsGobJmulticardCryptoHelper_BlockMode_values() {
  EsGobJmulticardCryptoHelper_BlockMode_initialize();
  return [IOSObjectArray arrayWithObjects:EsGobJmulticardCryptoHelper_BlockMode_values_ count:2 type:EsGobJmulticardCryptoHelper_BlockMode_class_()];
}

EsGobJmulticardCryptoHelper_BlockMode *EsGobJmulticardCryptoHelper_BlockMode_valueOfWithNSString_(NSString *name) {
  EsGobJmulticardCryptoHelper_BlockMode_initialize();
  for (int i = 0; i < 2; i++) {
    EsGobJmulticardCryptoHelper_BlockMode *e = EsGobJmulticardCryptoHelper_BlockMode_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

EsGobJmulticardCryptoHelper_BlockMode *EsGobJmulticardCryptoHelper_BlockMode_fromOrdinal(NSUInteger ordinal) {
  EsGobJmulticardCryptoHelper_BlockMode_initialize();
  if (ordinal >= 2) {
    return nil;
  }
  return EsGobJmulticardCryptoHelper_BlockMode_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardCryptoHelper_BlockMode)

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/CryptoHelper.java"

J2OBJC_INITIALIZED_DEFN(EsGobJmulticardCryptoHelper_EcCurve)

EsGobJmulticardCryptoHelper_EcCurve *EsGobJmulticardCryptoHelper_EcCurve_values_[1];


#line 104
@implementation EsGobJmulticardCryptoHelper_EcCurve


#line 114
- (NSString *)description {
  
#line 116
  return name_EcCurve_;
}

+ (IOSObjectArray *)values {
  return EsGobJmulticardCryptoHelper_EcCurve_values();
}

+ (EsGobJmulticardCryptoHelper_EcCurve *)valueOfWithNSString:(NSString *)name {
  return EsGobJmulticardCryptoHelper_EcCurve_valueOfWithNSString_(name);
}

- (EsGobJmulticardCryptoHelper_EcCurve_Enum)toNSEnum {
  return (EsGobJmulticardCryptoHelper_EcCurve_Enum)[self ordinal];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LNSString;", 0x1, 0, -1, -1, -1, -1, -1 },
    { NULL, "[LEsGobJmulticardCryptoHelper_EcCurve;", 0x9, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEsGobJmulticardCryptoHelper_EcCurve;", 0x9, 1, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(description);
  methods[1].selector = @selector(values);
  methods[2].selector = @selector(valueOfWithNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "BRAINPOOL_P256_R1", "LEsGobJmulticardCryptoHelper_EcCurve;", .constantValue.asLong = 0, 0x4019, -1, 3, -1, -1 },
    { "name_EcCurve_", "LNSString;", .constantValue.asLong = 0, 0x12, 4, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "toString", "valueOf", "LNSString;", &JreEnum(EsGobJmulticardCryptoHelper_EcCurve, BRAINPOOL_P256_R1), "name", "LEsGobJmulticardCryptoHelper;", "Ljava/lang/Enum<Les/gob/jmulticard/CryptoHelper$EcCurve;>;" };
  static const J2ObjcClassInfo _EsGobJmulticardCryptoHelper_EcCurve = { "EcCurve", "es.gob.jmulticard", ptrTable, methods, fields, 7, 0x4019, 3, 2, 5, -1, -1, 6, -1 };
  return &_EsGobJmulticardCryptoHelper_EcCurve;
}

+ (void)initialize {
  if (self == [EsGobJmulticardCryptoHelper_EcCurve class]) {
    JreEnum(EsGobJmulticardCryptoHelper_EcCurve, BRAINPOOL_P256_R1) = new_EsGobJmulticardCryptoHelper_EcCurve_initWithNSString_withNSString_withInt_(
#line 107
    @"brainpoolp256r1", JreEnumConstantName(EsGobJmulticardCryptoHelper_EcCurve_class_(), 0), 0);
    J2OBJC_SET_INITIALIZED(EsGobJmulticardCryptoHelper_EcCurve)
  }
}

@end


#line 110
void EsGobJmulticardCryptoHelper_EcCurve_initWithNSString_withNSString_withInt_(EsGobJmulticardCryptoHelper_EcCurve *self, NSString *n, NSString *__name, jint __ordinal) {
  JavaLangEnum_initWithNSString_withInt_(self, __name, __ordinal);
  
#line 111
  self->name_EcCurve_ = n;
}


#line 110
EsGobJmulticardCryptoHelper_EcCurve *new_EsGobJmulticardCryptoHelper_EcCurve_initWithNSString_withNSString_withInt_(NSString *n, NSString *__name, jint __ordinal) {
  J2OBJC_NEW_IMPL(EsGobJmulticardCryptoHelper_EcCurve, initWithNSString_withNSString_withInt_, n, __name, __ordinal)
}

IOSObjectArray *EsGobJmulticardCryptoHelper_EcCurve_values() {
  EsGobJmulticardCryptoHelper_EcCurve_initialize();
  return [IOSObjectArray arrayWithObjects:EsGobJmulticardCryptoHelper_EcCurve_values_ count:1 type:EsGobJmulticardCryptoHelper_EcCurve_class_()];
}

EsGobJmulticardCryptoHelper_EcCurve *EsGobJmulticardCryptoHelper_EcCurve_valueOfWithNSString_(NSString *name) {
  EsGobJmulticardCryptoHelper_EcCurve_initialize();
  for (int i = 0; i < 1; i++) {
    EsGobJmulticardCryptoHelper_EcCurve *e = EsGobJmulticardCryptoHelper_EcCurve_values_[i];
    if ([name isEqual:[e name]]) {
      return e;
    }
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(name);
  return nil;
}

EsGobJmulticardCryptoHelper_EcCurve *EsGobJmulticardCryptoHelper_EcCurve_fromOrdinal(NSUInteger ordinal) {
  EsGobJmulticardCryptoHelper_EcCurve_initialize();
  if (ordinal >= 1) {
    return nil;
  }
  return EsGobJmulticardCryptoHelper_EcCurve_values_[ordinal];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardCryptoHelper_EcCurve)

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/CryptoHelper.java"

J2OBJC_INITIALIZED_DEFN(EsGobJmulticardCryptoHelper_PaceChannelHelper)

IOSByteArray *EsGobJmulticardCryptoHelper_PaceChannelHelper_CAN_MRZ_PADDING;
IOSByteArray *EsGobJmulticardCryptoHelper_PaceChannelHelper_KENC_PADDING;
IOSByteArray *EsGobJmulticardCryptoHelper_PaceChannelHelper_KMAC_PADDING;
IOSByteArray *EsGobJmulticardCryptoHelper_PaceChannelHelper_MAC_PADDING_PRE;
IOSByteArray *EsGobJmulticardCryptoHelper_PaceChannelHelper_MAC2_PADDING_POST;


#line 322
@implementation EsGobJmulticardCryptoHelper_PaceChannelHelper


#line 354
- (instancetype)initWithEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)ch {
  EsGobJmulticardCryptoHelper_PaceChannelHelper_initWithEsGobJmulticardCryptoHelper_(self, ch);
  return self;
}


#line 361
+ (IOSByteArray *)bigIntToByteArrayWithJavaMathBigInteger:(JavaMathBigInteger *)bi {
  return EsGobJmulticardCryptoHelper_PaceChannelHelper_bigIntToByteArrayWithJavaMathBigInteger_(bi);
}


#line 375
+ (IOSByteArray *)unwrapEcKeyWithByteArray:(IOSByteArray *)key {
  return EsGobJmulticardCryptoHelper_PaceChannelHelper_unwrapEcKeyWithByteArray_(key);
}


#line 387
- (EsGobJmulticardConnectionPaceSecureMessaging *)openPaceChannelWithByte:(jbyte)cla
                           withEsGobJmulticardCardIcaoWirelessInitializer:(id<EsGobJmulticardCardIcaoWirelessInitializer>)pi
                              withEsGobJmulticardConnectionApduConnection:(id<EsGobJmulticardConnectionApduConnection>)conn {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x4, -1, 0, -1, -1, -1, -1 },
    { NULL, "[B", 0xc, 1, 2, -1, -1, -1, -1 },
    { NULL, "[B", 0xc, 3, 4, 5, -1, -1, -1 },
    { NULL, "LEsGobJmulticardConnectionPaceSecureMessaging;", 0x401, 6, 7, 8, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithEsGobJmulticardCryptoHelper:);
  methods[1].selector = @selector(bigIntToByteArrayWithJavaMathBigInteger:);
  methods[2].selector = @selector(unwrapEcKeyWithByteArray:);
  methods[3].selector = @selector(openPaceChannelWithByte:withEsGobJmulticardCardIcaoWirelessInitializer:withEsGobJmulticardConnectionApduConnection:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "CAN_MRZ_PADDING", "[B", .constantValue.asLong = 0, 0x1c, -1, 9, -1, -1 },
    { "KENC_PADDING", "[B", .constantValue.asLong = 0, 0x1c, -1, 10, -1, -1 },
    { "KMAC_PADDING", "[B", .constantValue.asLong = 0, 0x1c, -1, 11, -1, -1 },
    { "MAC_PADDING_PRE", "[B", .constantValue.asLong = 0, 0x1c, -1, 12, -1, -1 },
    { "MAC2_PADDING_POST", "[B", .constantValue.asLong = 0, 0x1c, -1, 13, -1, -1 },
    { "cryptoHelper_", "LEsGobJmulticardCryptoHelper;", .constantValue.asLong = 0, 0x14, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LEsGobJmulticardCryptoHelper;", "bigIntToByteArray", "LJavaMathBigInteger;", "unwrapEcKey", "[B", "LEsGobJmulticardAsn1TlvException;", "openPaceChannel", "BLEsGobJmulticardCardIcaoWirelessInitializer;LEsGobJmulticardConnectionApduConnection;", "LEsGobJmulticardConnectionApduConnectionException;LEsGobJmulticardCardIcaoIcaoException;", &EsGobJmulticardCryptoHelper_PaceChannelHelper_CAN_MRZ_PADDING, &EsGobJmulticardCryptoHelper_PaceChannelHelper_KENC_PADDING, &EsGobJmulticardCryptoHelper_PaceChannelHelper_KMAC_PADDING, &EsGobJmulticardCryptoHelper_PaceChannelHelper_MAC_PADDING_PRE, &EsGobJmulticardCryptoHelper_PaceChannelHelper_MAC2_PADDING_POST };
  static const J2ObjcClassInfo _EsGobJmulticardCryptoHelper_PaceChannelHelper = { "PaceChannelHelper", "es.gob.jmulticard", ptrTable, methods, fields, 7, 0x409, 4, 6, 0, -1, -1, -1, -1 };
  return &_EsGobJmulticardCryptoHelper_PaceChannelHelper;
}

+ (void)initialize {
  if (self == [EsGobJmulticardCryptoHelper_PaceChannelHelper class]) {
    EsGobJmulticardCryptoHelper_PaceChannelHelper_CAN_MRZ_PADDING = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 326
      (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x03 } count:4];
      EsGobJmulticardCryptoHelper_PaceChannelHelper_KENC_PADDING = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 331
        (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x01 } count:4];
        EsGobJmulticardCryptoHelper_PaceChannelHelper_KMAC_PADDING = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 336
          (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x02 } count:4];
          EsGobJmulticardCryptoHelper_PaceChannelHelper_MAC_PADDING_PRE = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 341
            (jbyte) (jint) 0x7F, (jbyte) (jint) 0x49, (jbyte) (jint) 0x4F, (jbyte) (jint) 0x06 } count:4];
            EsGobJmulticardCryptoHelper_PaceChannelHelper_MAC2_PADDING_POST = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 346
              (jbyte) (jint) 0x86, (jbyte) (jint) 0x41, (jbyte) (jint) 0x04 } count:3];
              J2OBJC_SET_INITIALIZED(EsGobJmulticardCryptoHelper_PaceChannelHelper)
            }
          }

@end


#line 354
void EsGobJmulticardCryptoHelper_PaceChannelHelper_initWithEsGobJmulticardCryptoHelper_(EsGobJmulticardCryptoHelper_PaceChannelHelper *self, EsGobJmulticardCryptoHelper *ch) {
  NSObject_init(self);
  
#line 355
  self->cryptoHelper_ = ch;
}

IOSByteArray *EsGobJmulticardCryptoHelper_PaceChannelHelper_bigIntToByteArrayWithJavaMathBigInteger_(JavaMathBigInteger *bi) {
  EsGobJmulticardCryptoHelper_PaceChannelHelper_initialize();
  
#line 362
  IOSByteArray *temp = [((JavaMathBigInteger *) nil_chk(bi)) toByteArray];
  if (IOSByteArray_Get(nil_chk(temp), 0) == 0) {
    IOSByteArray *returnbytes = [IOSByteArray newArrayWithLength:temp->size_ - 1];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(temp, 1, returnbytes, 0, returnbytes->size_);
    return returnbytes;
  }
  return temp;
}


#line 375
IOSByteArray *EsGobJmulticardCryptoHelper_PaceChannelHelper_unwrapEcKeyWithByteArray_(IOSByteArray *key) {
  EsGobJmulticardCryptoHelper_PaceChannelHelper_initialize();
  
#line 376
  return [new_EsGobJmulticardAsn1Tlv_initWithByteArray_([new_EsGobJmulticardAsn1Tlv_initWithByteArray_(key) getValue]) getValue];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardCryptoHelper_PaceChannelHelper)
