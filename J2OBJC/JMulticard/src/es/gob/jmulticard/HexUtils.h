//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/HexUtils.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_EsGobJmulticardHexUtils")
#ifdef RESTRICT_EsGobJmulticardHexUtils
#define INCLUDE_ALL_EsGobJmulticardHexUtils 0
#else
#define INCLUDE_ALL_EsGobJmulticardHexUtils 1
#endif
#undef RESTRICT_EsGobJmulticardHexUtils

#if !defined (EsGobJmulticardHexUtils_) && (INCLUDE_ALL_EsGobJmulticardHexUtils || defined(INCLUDE_EsGobJmulticardHexUtils))
#define EsGobJmulticardHexUtils_

@class IOSByteArray;
@class IOSCharArray;
@class IOSObjectArray;

/*!
 @brief Utilidades varias de tratamiento de datos binarios y hexadecimales.
 @author Tom&aacute;s Garc&iacute;a-Mer&aacute;s
 @author Alberto Mart&iacute;nez
 @author Carlos Gamuci.
 */
@interface EsGobJmulticardHexUtils : NSObject

#pragma mark Public

/*!
 @brief Comprueba si dos <i>arrays</i> de octetos son iguales.
 @param v Primer  <i> array </i>  de octetos.
 @param w Segundo  <i> array </i>  de octetos.
 @return <code>true</code> si los <i>arrays</i> son iguales,
          <code>false</code> en caso contrario.
 */
+ (jboolean)arrayEqualsWithByteArray:(IOSByteArray *)v
                       withByteArray:(IOSByteArray *)w;

/*!
 @brief Comprueba si dos <i>arrays</i> de octetos son iguales.
 @param v Primer  <i> array </i>  de octetos.
 @param vOffset Desplazamiento ( <i> offset </i> ) de inicio para el primer  <i> array </i>
  .
 @param vLen Longitud de los datos en el primer  <i> array </i>
  .
 @param w Segundo  <i> array </i>  de octetos.
 @param wOffset Desplazamiento ( <i> offset </i> ) de inicio para el segundo  <i> array </i>
  .
 @param wLen Longitud de los datos en el segundo  <i> array </i>
  .
 @return <code>true</code> si los <i>arrays</i> son iguales en longitudes y valores comparados desde
          los respectivos desplazamientos, <code>false</code> en caso contrario.
 */
+ (jboolean)arrayEqualsWithByteArray:(IOSByteArray *)v
                             withInt:(jint)vOffset
                             withInt:(jint)vLen
                       withByteArray:(IOSByteArray *)w
                             withInt:(jint)wOffset
                             withInt:(jint)wLen;

/*!
 @brief Convierte un <i>array</i> de caracteres en otro de octetos.
 @param inCharArray El  <i> array </i>  de  <code> char </code>  de entrada.
 @return <i>Array</i> de <code>byte</code> correspondiente al
          <i>array</i> de <code>char</code> de entrada.
 */
+ (IOSByteArray *)charArrayToByteArrayWithCharArray:(IOSCharArray *)inCharArray;

/*!
 @brief Concatena <i>arrays</i> de octetos.
 @param arrays <i> Arrays </i>  de octetos a concatenar, en el orden de concatenaci &oacute; n.
 @return <i>Arrays</i> concatenados.
 */
+ (IOSByteArray *)concatenateByteArraysWithByteArray2:(IOSObjectArray *)arrays;

/*!
 @brief Obtiene un <code>short</code> a partir de un <i>array</i> de octetos.
 @param data <i> Array </i>  de octetos.
 @param offset Desplazamiento ( <i> offset </i> ) hasta el inicio de los datos a tratar.
 @return Valor <code>short</code>.
 */
+ (jshort)getShortWithByteArray:(IOSByteArray *)data
                        withInt:(jint)offset;

/*!
 @brief Obtiene un entero sin signo (doble octeto) a partir de un <i>array</i> de octetos.
 @param data <i> Array </i>  de octetos. Solo se tienen en cuenta dos posiciones, y si el
                <i> Array </i>  (a partir del desplazamiento) solo tiene una posici &oacute; n,              se considera que ese  &uacute; nico octeto es el valor sin signo del entero.
 @param offset Desplazamiento ( <i> offset </i> ) hasta el inicio de los datos a tratar.
 @return Valor entero sin signo (<i>2-byte unsigned int</i>).
 */
+ (jint)getUnsignedIntWithByteArray:(IOSByteArray *)data
                            withInt:(jint)offset;

/*!
 @brief Convierte un vector de octetos en una cadena de caracteres que contiene su
  representaci&oacute;n hexadecimal.Copiado directamente de <a href="http://www.openscdp.org/ocf/api/opencard/core/util/HexString.html">
  <code>opencard.core.util.HexString</code></a>.
 @param abyte <i> Array </i>  de octetos que deseamos representar textualmente.
 @param separator Indica si han de separarse o no los octetos con un gui &oacute; n y en                   l &iacute; neas de 16.
 @return Representaci&oacute;n textual del vector de octetos de entrada.
 */
+ (NSString *)hexifyWithByteArray:(IOSByteArray *)abyte
                      withBoolean:(jboolean)separator;

/*!
 @brief Devuelve una porci&oacute;n del <i>array</i> especificado.
 @param src <i> Array </i>  de octetos original.
 @param srcPos Posici &oacute; n de origen de la porci &oacute; n del  <i> array </i>  de octetos a obtener.
 @param length N &uacute; mero de octetos de la porci &oacute; n a obtener.
 @return Una porci&oacute;n del <i>array</i> especificado.
 */
+ (IOSByteArray *)subArrayWithByteArray:(IOSByteArray *)src
                                withInt:(jint)srcPos
                                withInt:(jint)length;

/*!
 @brief Realiza la operaci&oacute;n XOR entre dos <i>array</i> de octetos.
 El resultado se recortar&aacute; para ser del tama&ntilde;o del primer <i>array</i>
  recibido tomando los octetos menos significativos del resultado.
 @param v Primer  <i> array </i>  de bytes.
 @param w Segundo  <i> array </i>  de bytes.
 @return Resultado del XOR de los <i>arrays</i> de entrada.
 */
+ (IOSByteArray *)xor__WithByteArray:(IOSByteArray *)v
                       withByteArray:(IOSByteArray *)w;

@end

J2OBJC_STATIC_INIT(EsGobJmulticardHexUtils)

FOUNDATION_EXPORT jboolean EsGobJmulticardHexUtils_arrayEqualsWithByteArray_withByteArray_(IOSByteArray *v, IOSByteArray *w);

FOUNDATION_EXPORT jboolean EsGobJmulticardHexUtils_arrayEqualsWithByteArray_withInt_withInt_withByteArray_withInt_withInt_(IOSByteArray *v, jint vOffset, jint vLen, IOSByteArray *w, jint wOffset, jint wLen);

FOUNDATION_EXPORT jshort EsGobJmulticardHexUtils_getShortWithByteArray_withInt_(IOSByteArray *data, jint offset);

FOUNDATION_EXPORT jint EsGobJmulticardHexUtils_getUnsignedIntWithByteArray_withInt_(IOSByteArray *data, jint offset);

FOUNDATION_EXPORT NSString *EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(IOSByteArray *abyte, jboolean separator);

FOUNDATION_EXPORT IOSByteArray *EsGobJmulticardHexUtils_subArrayWithByteArray_withInt_withInt_(IOSByteArray *src, jint srcPos, jint length);

FOUNDATION_EXPORT IOSByteArray *EsGobJmulticardHexUtils_xor__WithByteArray_withByteArray_(IOSByteArray *v, IOSByteArray *w);

FOUNDATION_EXPORT IOSByteArray *EsGobJmulticardHexUtils_concatenateByteArraysWithByteArray2_(IOSObjectArray *arrays);

FOUNDATION_EXPORT IOSByteArray *EsGobJmulticardHexUtils_charArrayToByteArrayWithCharArray_(IOSCharArray *inCharArray);

J2OBJC_TYPE_LITERAL_HEADER(EsGobJmulticardHexUtils)

#endif

#pragma pop_macro("INCLUDE_ALL_EsGobJmulticardHexUtils")
