//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/asn1/Tlv.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "es/gob/jmulticard/HexUtils.h"
#include "es/gob/jmulticard/JmcLogger.h"
#include "es/gob/jmulticard/asn1/Tlv.h"
#include "es/gob/jmulticard/asn1/TlvException.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/IOException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/System.h"

#if !__has_feature(objc_arc)
#error "es/gob/jmulticard/asn1/Tlv must be compiled with ARC (-fobjc-arc)"
#endif

@interface EsGobJmulticardAsn1Tlv () {
 @public
  /*!
   @brief Octeto de tipo (etiqueta).
   */
  jbyte tag_;
  /*!
   @brief Longitud del valor.
   */
  jint length_;
  /*!
   @brief Estructura binaria completa del TLV.
   */
  IOSByteArray *bytes_;
  jint valueOffset_;
}

@end

J2OBJC_FIELD_SETTER(EsGobJmulticardAsn1Tlv, bytes_, IOSByteArray *)

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/asn1/Tlv.java"


#line 50
@implementation EsGobJmulticardAsn1Tlv


#line 66
- (instancetype)initWithByte:(jbyte)t
               withByteArray:(IOSByteArray *)value {
  EsGobJmulticardAsn1Tlv_initWithByte_withByteArray_(self, t, value);
  return self;
}


#line 108
- (instancetype)initWithByteArray:(IOSByteArray *)buffer {
  EsGobJmulticardAsn1Tlv_initWithByteArray_(self, buffer);
  return self;
}


#line 165
- (IOSByteArray *)getBytes {
  IOSByteArray *out = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(bytes_))->size_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bytes_, 0, out, 0, bytes_->size_);
  return out;
}


#line 173
- (jint)getLength {
  return length_;
}


#line 179
- (jbyte)getTag {
  return tag_;
}


#line 185
- (IOSByteArray *)getValue {
  IOSByteArray *out = [IOSByteArray newArrayWithLength:length_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(bytes_, valueOffset_, out, 0, length_);
  return out;
}


#line 196
+ (EsGobJmulticardAsn1Tlv *)decodeWithJavaIoByteArrayInputStream:(JavaIoByteArrayInputStream *)recordOfTlv {
  return EsGobJmulticardAsn1Tlv_decodeWithJavaIoByteArrayInputStream_(recordOfTlv);
}


#line 237
- (NSString *)description {
  
#line 239
  return JreStrcat("$$$I$$C", @"TLV (Tag=", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_([IOSByteArray newArrayWithBytes:(jbyte[]){ [self getTag] } count:1], false), @", Length=",
#line 240
  [self getLength], @", Value=",
#line 241
  (((IOSByteArray *) nil_chk([self getValue]))->size_ == 0 ? @"vacio" : EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_([self getValue], false)), ')');
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, 2, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEsGobJmulticardAsn1Tlv;", 0x9, 3, 4, 5, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 6, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithByte:withByteArray:);
  methods[1].selector = @selector(initWithByteArray:);
  methods[2].selector = @selector(getBytes);
  methods[3].selector = @selector(getLength);
  methods[4].selector = @selector(getTag);
  methods[5].selector = @selector(getValue);
  methods[6].selector = @selector(decodeWithJavaIoByteArrayInputStream:);
  methods[7].selector = @selector(description);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "tag_", "B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "length_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "bytes_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "valueOffset_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "B[B", "[B", "LEsGobJmulticardAsn1TlvException;", "decode", "LJavaIoByteArrayInputStream;", "LJavaIoIOException;", "toString" };
  static const J2ObjcClassInfo _EsGobJmulticardAsn1Tlv = { "Tlv", "es.gob.jmulticard.asn1", ptrTable, methods, fields, 7, 0x11, 8, 4, -1, -1, -1, -1, -1 };
  return &_EsGobJmulticardAsn1Tlv;
}

@end


#line 66
void EsGobJmulticardAsn1Tlv_initWithByte_withByteArray_(EsGobJmulticardAsn1Tlv *self, jbyte t, IOSByteArray *value) {
  NSObject_init(self);
  
#line 67
  if (value == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"El valor del TLV no puede ser nulo");
  }
  self->valueOffset_ = 2;
  self->tag_ = t;
  self->length_ = value->size_;
  
#line 75
  jint iExtLen;
  if (self->length_ >= 256) {
    iExtLen = 4;
  }
  else if (self->length_ >= 128) {
    iExtLen = 3;
  }
  else {
    iExtLen = 2;
  }
  
#line 86
  self->bytes_ = [IOSByteArray newArrayWithLength:value->size_ + iExtLen];
  *IOSByteArray_GetRef(self->bytes_, 0) = t;
  
#line 89
  if (self->length_ >= 256) {
    *IOSByteArray_GetRef(self->bytes_, 1) = (jbyte) (jint) 0x82;
    *IOSByteArray_GetRef(self->bytes_, 2) = (jbyte) ((JreRShift32(value->size_, 8)) & (jint) 0xFF);
    *IOSByteArray_GetRef(self->bytes_, 3) = (jbyte) (value->size_ & (jint) 0xFF);
  }
  else if (value->size_ >= 128) {
    *IOSByteArray_GetRef(self->bytes_, 1) = (jbyte) (jint) 0x81;
    *IOSByteArray_GetRef(self->bytes_, 2) = (jbyte) value->size_;
  }
  else {
    *IOSByteArray_GetRef(self->bytes_, 1) = (jbyte) value->size_;
  }
  
#line 102
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(value, 0, self->bytes_, iExtLen, value->size_);
}


#line 66
EsGobJmulticardAsn1Tlv *new_EsGobJmulticardAsn1Tlv_initWithByte_withByteArray_(jbyte t, IOSByteArray *value) {
  J2OBJC_NEW_IMPL(EsGobJmulticardAsn1Tlv, initWithByte_withByteArray_, t, value)
}


#line 66
EsGobJmulticardAsn1Tlv *create_EsGobJmulticardAsn1Tlv_initWithByte_withByteArray_(jbyte t, IOSByteArray *value) {
  J2OBJC_CREATE_IMPL(EsGobJmulticardAsn1Tlv, initWithByte_withByteArray_, t, value)
}


#line 108
void EsGobJmulticardAsn1Tlv_initWithByteArray_(EsGobJmulticardAsn1Tlv *self, IOSByteArray *buffer) {
  NSObject_init(self);
  
#line 109
  if (buffer == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(@"El TLV no puede ser nulo");
  }
  if (buffer->size_ == 0) {
    EsGobJmulticardJmcLogger_warningWithNSString_(@"Se ha pedido crear un TLV vacio");
    self->length_ = 0;
    self->bytes_ = [IOSByteArray newArrayWithLength:0];
    self->tag_ = (jbyte) (jint) 0xff;
    self->valueOffset_ = 0;
    return;
  }
  if (buffer->size_ < 2) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$$", @"El TLV no puede medir menos de dos octetos: ", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(
#line 122
    buffer, false)));
  }
  
#line 126
  jint offset = 0;
  
#line 129
  IOSByteArray *tempBytes = [IOSByteArray newArrayWithLength:buffer->size_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buffer, 0, tempBytes, 0, buffer->size_);
  
#line 132
  self->tag_ = IOSByteArray_Get(tempBytes, offset++);
  
#line 135
  jint size = IOSByteArray_Get(tempBytes, offset++) & (jint) 0xff;
  jboolean indefinite = size == 128;
  if (indefinite) {
    if ((self->tag_ & (jint) 0x20) == 0) {
      @throw new_EsGobJmulticardAsn1TlvException_initWithNSString_(@"Longitud del TLV invalida");
    }
  }
  else if (size >= 128) {
    jint sizeLen = size - 128;
    
#line 145
    if (sizeLen > 3) {
      @throw new_EsGobJmulticardAsn1TlvException_initWithNSString_(@"TLV demasiado largo");
    }
    size = 0;
    while (sizeLen > 0) {
      size = (JreLShift32(size, 8)) + (IOSByteArray_Get(tempBytes, offset++) & (jint) 0xff);
      sizeLen--;
    }
  }
  
#line 155
  self->length_ = size;
  self->valueOffset_ = offset;
  
#line 158
  self->bytes_ = [IOSByteArray newArrayWithLength:self->valueOffset_ + self->length_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tempBytes, 0, self->bytes_, 0, self->valueOffset_ + self->length_);
}


#line 108
EsGobJmulticardAsn1Tlv *new_EsGobJmulticardAsn1Tlv_initWithByteArray_(IOSByteArray *buffer) {
  J2OBJC_NEW_IMPL(EsGobJmulticardAsn1Tlv, initWithByteArray_, buffer)
}


#line 108
EsGobJmulticardAsn1Tlv *create_EsGobJmulticardAsn1Tlv_initWithByteArray_(IOSByteArray *buffer) {
  J2OBJC_CREATE_IMPL(EsGobJmulticardAsn1Tlv, initWithByteArray_, buffer)
}


#line 196
EsGobJmulticardAsn1Tlv *EsGobJmulticardAsn1Tlv_decodeWithJavaIoByteArrayInputStream_(JavaIoByteArrayInputStream *recordOfTlv) {
  EsGobJmulticardAsn1Tlv_initialize();
  jbyte tag = (jbyte) [((JavaIoByteArrayInputStream *) nil_chk(recordOfTlv)) read];
  
#line 201
  if ((tag & (jint) 0x1f) == (jint) 0x1f) {
    @throw new_JavaIoIOException_initWithNSString_(@"El tipo del TLV es invalido");
  }
  
#line 206
  jint size = [recordOfTlv read] & (jint) 0xff;
  
#line 208
  jboolean indefinite = size == 128;
  if (indefinite) {
    if ((tag & (jint) 0x20) == 0) {
      @throw new_JavaIoIOException_initWithNSString_(@"Longitud del TLV invalida");
    }
  }
  else if (size >= 128) {
    jint sizeLen = size - 128;
    
#line 217
    if (sizeLen > 3) {
      @throw new_JavaIoIOException_initWithNSString_(@"TLV demasiado largo");
    }
    size = 0;
    while (sizeLen > 0) {
      size = (JreLShift32(size, 8)) + ([recordOfTlv read] & (jint) 0xff);
      sizeLen--;
    }
  }
  
#line 227
  IOSByteArray *value = [IOSByteArray newArrayWithLength:size];
  if (value->size_ != [recordOfTlv readWithByteArray:value]) {
    @throw new_JavaLangIndexOutOfBoundsException_initWithNSString_(
#line 230
    @"La longitud de los datos leidos no coincide con el parametro indicado");
  }
  
#line 234
  return new_EsGobJmulticardAsn1Tlv_initWithByte_withByteArray_(tag, value);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardAsn1Tlv)
