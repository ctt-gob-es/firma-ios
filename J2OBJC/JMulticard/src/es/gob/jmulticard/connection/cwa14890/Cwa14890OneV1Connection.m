//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/connection/cwa14890/Cwa14890OneV1Connection.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "es/gob/jmulticard/CryptoHelper.h"
#include "es/gob/jmulticard/DigestAlgorithm.h"
#include "es/gob/jmulticard/HexUtils.h"
#include "es/gob/jmulticard/JmcLogger.h"
#include "es/gob/jmulticard/apdu/CommandApdu.h"
#include "es/gob/jmulticard/apdu/ResponseApdu.h"
#include "es/gob/jmulticard/apdu/StatusWord.h"
#include "es/gob/jmulticard/card/cwa14890/Cwa14890Card.h"
#include "es/gob/jmulticard/card/cwa14890/Cwa14890PrivateConstants.h"
#include "es/gob/jmulticard/card/cwa14890/Cwa14890PublicConstants.h"
#include "es/gob/jmulticard/connection/AbstractApduEncrypter.h"
#include "es/gob/jmulticard/connection/ApduConnection.h"
#include "es/gob/jmulticard/connection/ApduConnectionException.h"
#include "es/gob/jmulticard/connection/ApduConnectionProtocol.h"
#include "es/gob/jmulticard/connection/ApduEncrypterDes.h"
#include "es/gob/jmulticard/connection/CipheredApdu.h"
#include "es/gob/jmulticard/connection/cwa14890/Cwa14890Connection.h"
#include "es/gob/jmulticard/connection/cwa14890/Cwa14890OneV1Connection.h"
#include "es/gob/jmulticard/connection/cwa14890/InvalidCryptographicChecksumException.h"
#include "es/gob/jmulticard/connection/cwa14890/SecureChannelException.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Integer.h"
#include "java/lang/SecurityException.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "java/security/cert/CertificateException.h"
#include "java/security/interfaces/RSAPrivateKey.h"
#include "java/security/interfaces/RSAPublicKey.h"

#if !__has_feature(objc_arc)
#error "es/gob/jmulticard/connection/cwa14890/Cwa14890OneV1Connection must be compiled with ARC (-fobjc-arc)"
#endif

@interface EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection () {
 @public
  /*!
   @brief Utilidad para la ejecuci&oacute;n de funciones criptogr&aacute;ficas.
   */
  EsGobJmulticardCryptoHelper *cryptoHelper_;
  /*!
   @brief Tarjeta CWA-14890 con la que se desea establecer el canal seguro.
   */
  id<EsGobJmulticardCardCwa14890Cwa14890Card> card_;
  /*!
   @brief Clave Triple DES (TDES o DESEDE) para encriptar y desencriptar criptogramas.
   */
  IOSByteArray *kenc_;
  /*!
   @brief Clave Triple DES (TDES o DESEDE) para calcular y verificar <i>checksums</i>.
   */
  IOSByteArray *kmac_;
  /*!
   @brief Contador de secuencia.
   */
  IOSByteArray *ssc_;
  /*!
   @brief Clase de utilidad para encriptar las APDU.
   */
  EsGobJmulticardConnectionAbstractApduEncrypter *apduEncrypter_;
  id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants> pubConsts_;
  id<EsGobJmulticardCardCwa14890Cwa14890PrivateConstants> privConsts_;
}

/*!
 @brief Genera la clave <code>KENC</code> para encriptar y desencriptar criptogramas.
 La clave de cifrado Kenc se obtiene como los 16 primeros octetos de la huella SHA-1 de la
  concatenaci&oacute;n de <i>kifdicc</i> con el valor "00 00 00 01" (SECURE_CHANNEL_KENC_AUX).
 @param kidficc XOR de los valores  <code> Kifd </code>  y  <code> Kicc </code>
  .
 @return Clave Triple-DES.
 @throw IOExceptionCuando no puede generarse la clave.
 */
- (IOSByteArray *)generateKencWithByteArray:(IOSByteArray *)kidficc;

/*!
 @brief Genera la clave <code>KMAC</code> para calcular y verificar <i>checksums</i>.
 La clave para el c&aacute;lculo del MAC Kmac se obtiene como los 16 primeros octetos
  de la huella SHA-1 de la concatenaci&oacute;n de <i>kifdicc</i> con el valor
  "00 00 00 02" (SECURE_CHANNEL_KMAC_AUX).
 @param kidficc XOR de los valores  <code> Kifd </code>  y  <code> Kicc </code>
  .
 @return Clave Triple-DES.
 @throw IOExceptionCuando no puede generarse la clave.
 */
- (IOSByteArray *)generateKmacWithByteArray:(IOSByteArray *)kidficc;

/*!
 @brief Genera el contador de secuencia SSC a partir de los semillas aleatorias calculadas
  en los procesos de autenticaci&oacute;n interna y externa.
 El contador de secuencia SSC se obtiene concatenando los 4 octetos menos
  significativos del desaf&iacute;o de la tarjeta (RND.ICC) con los 4 menos
  significativos del desaf&iacute;o del terminal (RND.IFD)
 @param randomIfd Aleatorio del desaf &iacute; o del terminal.
 @param randomIcc Aleatorio del desaf &iacute; o de la tarjeta.
 @return Contador de secuencia.
 */
+ (IOSByteArray *)generateSscWithByteArray:(IOSByteArray *)randomIfd
                             withByteArray:(IOSByteArray *)randomIcc;

/*!
 @brief Lleva a cabo el proceso de autenticaci&oacute;n interna de la tarjeta mediante el
  cual el controlador comprueba la tarjeta.
 @param randomIfd Array de 8 bytes aleatorios (generados por el controlador, de forma externa a la tarjeta).
 @param iccPublicKey Clave p &uacute; blica del certificado de componente.
 @return Semilla de 32 [KICC_LENGTH] bits, generada por la tarjeta, para la derivaci&oacute;n de
          claves del canal seguro.
 @throw IOExceptionCuando ocurre un error en el cifrado/descifrado de los mensajes o
                      en la comunicaci&oacute;n con la tarjeta.
 */
- (IOSByteArray *)internalAuthenticationWithByteArray:(IOSByteArray *)randomIfd
               withJavaSecurityInterfacesRSAPublicKey:(id<JavaSecurityInterfacesRSAPublicKey>)iccPublicKey;

/*!
 @brief Lleva a cabo el proceso de autenticaci&oacute;n externa mediante el cual la tarjeta
  comprueba el controlador.La implementaci&oacute;n usa siempre SHA-1 para las huellas.
 @param serial N &uacute; mero de serie de la tarjeta.
 @param randomIcc Array de 8 octetos aleatorios generados por la tarjeta.
 @param iccPublicKey Clava p &uacute; blica del certificado de componente.
 @return Semilla de 32 [KIFD_LENGTH] bytes, generada por el Terminal, para la
          derivaci&oacute;n de claves del canal seguro.
 @throw SecureChannelExceptionCuando ocurre un error en el establecimiento de claves.
 @throw ApduConnectionExceptionCuando ocurre un error en la comunicaci&oacute;n con la tarjeta.
 @throw IOExceptionCuando ocurre un error en el cifrado o en el descifrado de los mensajes.
 */
- (IOSByteArray *)externalAuthenticationWithByteArray:(IOSByteArray *)serial
                                        withByteArray:(IOSByteArray *)randomIcc
               withJavaSecurityInterfacesRSAPublicKey:(id<JavaSecurityInterfacesRSAPublicKey>)iccPublicKey;

/*!
 @brief Obtiene el n&uacute;mero de serie de la tarjeta en un array de 8 octetos,
  completando con ceros a la izquierda si es necesario.
 @return N&uacute;mero de serie en formato de 8 bytes.
 @throw ApduConnectionExceptionCuando ocurre un error en la
                                  comunicaci&oacute;n con la tarjeta.
 */
- (IOSByteArray *)getPaddedSerial;

/*!
 @brief Calcula y devuelve el valor entregado m&aacute;s 1.
 @param data Datos a incrementar.
 @return Valor incrementado.
 */
+ (IOSByteArray *)incrementWithByteArray:(IOSByteArray *)data;

@end

J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, cryptoHelper_, EsGobJmulticardCryptoHelper *)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, card_, id<EsGobJmulticardCardCwa14890Cwa14890Card>)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, kenc_, IOSByteArray *)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, kmac_, IOSByteArray *)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, ssc_, IOSByteArray *)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, apduEncrypter_, EsGobJmulticardConnectionAbstractApduEncrypter *)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, pubConsts_, id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants>)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, privConsts_, id<EsGobJmulticardCardCwa14890Cwa14890PrivateConstants>)

inline jint EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_KICC_LENGTH(void);
#define EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_KICC_LENGTH 32
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, KICC_LENGTH, jint)

inline jint EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_KIFD_LENGTH(void);
#define EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_KIFD_LENGTH 32
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, KIFD_LENGTH, jint)

inline jbyte EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_ISO_9796_2_PADDING_START(void);
#define EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_START 106
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, ISO_9796_2_PADDING_START, jbyte)

inline jbyte EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_ISO_9796_2_PADDING_END(void);
#define EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_END -68
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, ISO_9796_2_PADDING_END, jbyte)

inline EsGobJmulticardApduStatusWord *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_INVALID_CRYPTO_CHECKSUM(void);
static EsGobJmulticardApduStatusWord *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_INVALID_CRYPTO_CHECKSUM;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, INVALID_CRYPTO_CHECKSUM, EsGobJmulticardApduStatusWord *)

/*!
 @brief Octeto de valor m&aacute;s significativo que indica un <code>Le</code> incorrecto en la petici&oacute;n.
 */
inline jbyte EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_MSB_INCORRECT_LE(void);
#define EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_MSB_INCORRECT_LE 108
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, MSB_INCORRECT_LE, jbyte)

/*!
 @brief Octeto de valor m&aacute;s significativo que indica un <code>Le</code> incorrecto en la petici&oacute;n.
 */
inline jbyte EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_MSB_INCORRECT_LE_PACE(void);
#define EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_MSB_INCORRECT_LE_PACE 98
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, MSB_INCORRECT_LE_PACE, jbyte)

/*!
 @brief C&oacute;digo auxiliar para el c&aacute;lculo de la clave <code>Kenc</code> del canal seguro.
 */
inline IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_SECURE_CHANNEL_KENC_AUX(void);
static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_SECURE_CHANNEL_KENC_AUX;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, SECURE_CHANNEL_KENC_AUX, IOSByteArray *)

/*!
 @brief C&oacute;digo auxiliar para el c&aacute;lculo de la clave <code>Kmac</code> del canal seguro.
 */
inline IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_get_SECURE_CHANNEL_KMAC_AUX(void);
static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_SECURE_CHANNEL_KMAC_AUX;
J2OBJC_STATIC_FIELD_OBJ_FINAL(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, SECURE_CHANNEL_KMAC_AUX, IOSByteArray *)

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateKencWithByteArray_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, IOSByteArray *kidficc);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateKmacWithByteArray_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, IOSByteArray *kidficc);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateSscWithByteArray_withByteArray_(IOSByteArray *randomIfd, IOSByteArray *randomIcc);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthenticationWithByteArray_withJavaSecurityInterfacesRSAPublicKey_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, IOSByteArray *randomIfd, id<JavaSecurityInterfacesRSAPublicKey> iccPublicKey);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_externalAuthenticationWithByteArray_withByteArray_withJavaSecurityInterfacesRSAPublicKey_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, IOSByteArray *serial, IOSByteArray *randomIcc, id<JavaSecurityInterfacesRSAPublicKey> iccPublicKey);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_getPaddedSerial(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_incrementWithByteArray_(IOSByteArray *data);

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/connection/cwa14890/Cwa14890OneV1Connection.java"

J2OBJC_INITIALIZED_DEFN(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection)


#line 69
@implementation EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection


#line 123
- (EsGobJmulticardConnectionAbstractApduEncrypter *)instantiateApduEncrypter {
  
#line 125
  return new_EsGobJmulticardConnectionApduEncrypterDes_init();
}


#line 128
- (NSString *)description {
  
#line 130
  return JreStrcat("$$", @"Conexion de tipo CWA-14890-V1 ",
#line 131
  ([self isOpen] ? JreStrcat("$@", @"abierta sobre ",
#line 132
  [self getSubConnection]) :
#line 133
  @"cerrada"));
}


#line 143
- (instancetype)initWithEsGobJmulticardConnectionApduConnection:(id<EsGobJmulticardConnectionApduConnection>)connection
                                withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHlpr {
  EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initWithEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_(self, connection, cryptoHlpr);
  return self;
}


#line 168
- (instancetype)initWithEsGobJmulticardCardCwa14890Cwa14890Card:(id<EsGobJmulticardCardCwa14890Cwa14890Card>)connectedCard
                    withEsGobJmulticardConnectionApduConnection:(id<EsGobJmulticardConnectionApduConnection>)connection
                                withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHlpr
         withEsGobJmulticardCardCwa14890Cwa14890PublicConstants:(id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants>)cwaConsts
        withEsGobJmulticardCardCwa14890Cwa14890PrivateConstants:(id<EsGobJmulticardCardCwa14890Cwa14890PrivateConstants>)cwaPrivConsts {
  EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withEsGobJmulticardCardCwa14890Cwa14890PrivateConstants_(self, connectedCard, connection, cryptoHlpr, cwaConsts, cwaPrivConsts);
  return self;
}


#line 202
- (void)open {
  
#line 205
  id<EsGobJmulticardConnectionApduConnection> conn = subConnection_;
  [((id<EsGobJmulticardConnectionApduConnection>) nil_chk(conn)) open];
  
#line 210
  IOSByteArray *serial = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_getPaddedSerial(self);
  
#line 212
  EsGobJmulticardJmcLogger_infoWithNSString_withNSString_withNSString_([EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_class_() getName], @"open", @"Obtenido el numero de serie de la tarjeta");
  
#line 218
  @try {
    [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(card_)) verifyIcc];
  }
  @catch (JavaLangSecurityException *e) {
    [conn close];
    @throw new_JavaLangIllegalStateException_initWithNSString_withJavaLangThrowable_(
#line 224
    @"Condicion de seguridad no satisfecha en la validacion de los certificados CWA-14890", e);
  }
  @catch (
#line 227
  JavaSecurityCertCertificateException *e) {
    [conn close];
    @throw new_JavaLangIllegalStateException_initWithNSString_withJavaLangThrowable_(@"No se han podido tratar los certificados CWA-14890", e);
  }
  @catch (JavaIoIOException *e) {
    [conn close];
    @throw new_JavaLangIllegalStateException_initWithNSString_withJavaLangThrowable_(@"No se han podido validar los certificados CWA-14890", e);
  }
  
#line 236
  EsGobJmulticardJmcLogger_infoWithNSString_withNSString_withNSString_([EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_class_() getName], @"open", @"Verificado correctamente el certificado de la tarjeta");
  
#line 240
  id<JavaSecurityInterfacesRSAPublicKey> iccPublicKey;
  @try {
    iccPublicKey = [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(card_)) getIccCertPublicKey];
  }
  @catch (JavaIoIOException *e) {
    [conn close];
    @throw new_EsGobJmulticardConnectionApduConnectionException_initWithNSString_withJavaLangThrowable_(@"No se pudo leer certificado de componente", e);
  }
  
#line 252
  @try {
    [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(card_)) verifyIfdCertificateChainWithEsGobJmulticardCardCwa14890Cwa14890PublicConstants:pubConsts_];
  }
  @catch (JavaLangException *e) {
    [conn close];
    @throw new_EsGobJmulticardConnectionApduConnectionException_initWithNSString_withJavaLangThrowable_(@"Error al verificar la cadena de certificados del controlador", e);
  }
  
#line 260
  EsGobJmulticardJmcLogger_infoWithNSString_withNSString_withNSString_(
#line 261
  [EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_class_() getName],
#line 262
  @"open",
#line 263
  @"Verificada correctamente la cadena de certificados del controlador");
  
#line 269
  IOSByteArray *randomIfd;
  @try {
    randomIfd = [((EsGobJmulticardCryptoHelper *) nil_chk(cryptoHelper_)) generateRandomBytesWithInt:8];
  }
  @catch (JavaIoIOException *e1) {
    [conn close];
    @throw new_EsGobJmulticardConnectionCwa14890SecureChannelException_initWithNSString_withJavaLangThrowable_(@"No se pudo generar el array de aleatorios", e1);
  }
  
#line 278
  IOSByteArray *kicc;
  @try {
    kicc = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthenticationWithByteArray_withJavaSecurityInterfacesRSAPublicKey_(self, randomIfd, iccPublicKey);
  }
  @catch (JavaLangException *e) {
    [conn close];
    @throw new_EsGobJmulticardConnectionApduConnectionException_initWithNSString_withJavaLangThrowable_(
#line 285
    @"Error durante el proceso de autenticacion interna de la tarjeta", e);
  }
  
#line 289
  EsGobJmulticardJmcLogger_infoWithNSString_withNSString_withNSString_(
#line 290
  [EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_class_() getName],
#line 291
  @"open",
#line 292
  @"Autenticacion interna de la tarjeta completada");
  
#line 298
  IOSByteArray *randomIcc = [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(card_)) getChallenge];
  IOSByteArray *kifd;
  @try {
    kifd = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_externalAuthenticationWithByteArray_withByteArray_withJavaSecurityInterfacesRSAPublicKey_(self, serial, randomIcc, iccPublicKey);
  }
  @catch (JavaLangException *e) {
    [conn close];
    @throw new_EsGobJmulticardConnectionApduConnectionException_initWithNSString_withJavaLangThrowable_(
#line 306
    @"Error durante el proceso de autenticacion externa de la tarjeta", e);
  }
  
#line 310
  EsGobJmulticardJmcLogger_infoWithNSString_withNSString_withNSString_(
#line 311
  [EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_class_() getName],
#line 312
  @"open",
#line 313
  @"Autenticacion externa de la tarjeta completada");
  
#line 326
  IOSByteArray *kidficc = EsGobJmulticardHexUtils_xor__WithByteArray_withByteArray_(kicc, kifd);
  @try {
    kenc_ = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateKencWithByteArray_(self, kidficc);
  }
  @catch (JavaIoIOException *e) {
    [conn close];
    @throw new_EsGobJmulticardConnectionApduConnectionException_initWithNSString_withJavaLangThrowable_(
#line 333
    @"Error al generar la clave Kenc para el tratamiento del canal seguro", e);
  }
  
#line 337
  @try {
    kmac_ = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateKmacWithByteArray_(self, kidficc);
  }
  @catch (JavaIoIOException *e) {
    [conn close];
    @throw new_EsGobJmulticardConnectionApduConnectionException_initWithNSString_withJavaLangThrowable_(
#line 343
    @"Error al generar la clave Kmac para el tratamiento del canal seguro", e);
  }
  
#line 347
  ssc_ = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateSscWithByteArray_withByteArray_(randomIfd, randomIcc);
  
#line 349
  EsGobJmulticardJmcLogger_infoWithNSString_withNSString_withNSString_(
#line 350
  [EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_class_() getName],
#line 351
  @"open",
#line 352
  @"Generadas claves y contador de secuencia para el canal CWA-14890");
  
#line 355
  openState_ = true;
}


#line 364
- (IOSByteArray *)generateKencWithByteArray:(IOSByteArray *)kidficc {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateKencWithByteArray_(self, kidficc);
}


#line 387
- (IOSByteArray *)generateKmacWithByteArray:(IOSByteArray *)kidficc {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateKmacWithByteArray_(self, kidficc);
}


#line 411
+ (IOSByteArray *)generateSscWithByteArray:(IOSByteArray *)randomIfd
                             withByteArray:(IOSByteArray *)randomIcc {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateSscWithByteArray_withByteArray_(randomIfd, randomIcc);
}


#line 426
+ (IOSByteArray *)internalAuthGetInternalAuthenticateMessageWithEsGobJmulticardCardCwa14890Cwa14890Card:(id<EsGobJmulticardCardCwa14890Cwa14890Card>)card
                                                 withEsGobJmulticardCardCwa14890Cwa14890PublicConstants:(id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants>)pubConsts
                                                                                          withByteArray:(IOSByteArray *)randomIfd {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthGetInternalAuthenticateMessageWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withByteArray_(card, pubConsts, randomIfd);
}


#line 461
+ (IOSByteArray *)internalAuthValidateInternalAuthenticateMessageWithByteArray:(IOSByteArray *)chrCCvIfd
                                                                 withByteArray:(IOSByteArray *)sigMinCiphered
                                                                 withByteArray:(IOSByteArray *)randomIfd
                                       withJavaSecurityInterfacesRSAPrivateKey:(id<JavaSecurityInterfacesRSAPrivateKey>)ifdPrivateKey
                                                                       withInt:(jint)ifdKeyLength
                        withEsGobJmulticardCardCwa14890Cwa14890PublicConstants:(id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants>)pubConsts
                                        withJavaSecurityInterfacesRSAPublicKey:(id<JavaSecurityInterfacesRSAPublicKey>)iccPublicKey
                                               withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHelper {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthValidateInternalAuthenticateMessageWithByteArray_withByteArray_withByteArray_withJavaSecurityInterfacesRSAPrivateKey_withInt_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withJavaSecurityInterfacesRSAPublicKey_withEsGobJmulticardCryptoHelper_(chrCCvIfd, sigMinCiphered, randomIfd, ifdPrivateKey, ifdKeyLength, pubConsts, iccPublicKey, cryptoHelper);
}


#line 582
- (IOSByteArray *)internalAuthenticationWithByteArray:(IOSByteArray *)randomIfd
               withJavaSecurityInterfacesRSAPublicKey:(id<JavaSecurityInterfacesRSAPublicKey>)iccPublicKey {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthenticationWithByteArray_withJavaSecurityInterfacesRSAPublicKey_(self, randomIfd, iccPublicKey);
}


#line 612
- (IOSByteArray *)externalAuthenticationWithByteArray:(IOSByteArray *)serial
                                        withByteArray:(IOSByteArray *)randomIcc
               withJavaSecurityInterfacesRSAPublicKey:(id<JavaSecurityInterfacesRSAPublicKey>)iccPublicKey {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_externalAuthenticationWithByteArray_withByteArray_withJavaSecurityInterfacesRSAPublicKey_(self, serial, randomIcc, iccPublicKey);
}


#line 700
- (IOSByteArray *)getPaddedSerial {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_getPaddedSerial(self);
}


#line 715
- (void)close {
  
#line 717
  if (openState_) {
    [((id<EsGobJmulticardConnectionApduConnection>) nil_chk(subConnection_)) close];
    openState_ = false;
  }
}


#line 723
- (EsGobJmulticardApduResponseApdu *)transmitWithEsGobJmulticardApduCommandApdu:(EsGobJmulticardApduCommandApdu *)command {
  
#line 726
  EsGobJmulticardApduCommandApdu *protectedApdu;
  @try {
    ssc_ = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_incrementWithByteArray_(ssc_);
    protectedApdu = [((EsGobJmulticardConnectionAbstractApduEncrypter *) nil_chk(apduEncrypter_)) protectAPDUWithEsGobJmulticardApduCommandApdu:command withByteArray:kenc_ withByteArray:kmac_ withByteArray:ssc_ withEsGobJmulticardCryptoHelper:cryptoHelper_];
  }
  @catch (JavaIoIOException *e) {
    @throw new_EsGobJmulticardConnectionCwa14890SecureChannelException_initWithNSString_withJavaLangThrowable_(
#line 733
    @"Error en la encriptacion de la APDU para su envio por el canal seguro", e);
  }
  
#line 737
  EsGobJmulticardApduResponseApdu *responseApdu = [((id<EsGobJmulticardConnectionApduConnection>) nil_chk(subConnection_)) transmitWithEsGobJmulticardApduCommandApdu:protectedApdu];
  if ([((EsGobJmulticardApduStatusWord *) nil_chk(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_INVALID_CRYPTO_CHECKSUM)) isEqual:[((EsGobJmulticardApduResponseApdu *) nil_chk(responseApdu)) getStatusWord]]) {
    @throw new_EsGobJmulticardConnectionCwa14890InvalidCryptographicChecksumException_init();
  }
  
#line 743
  @try {
    ssc_ = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_incrementWithByteArray_(ssc_);
    EsGobJmulticardApduResponseApdu *decipherApdu = [((EsGobJmulticardConnectionAbstractApduEncrypter *) nil_chk(apduEncrypter_)) decryptResponseApduWithEsGobJmulticardApduResponseApdu:
#line 746
    responseApdu withByteArray:
#line 747
    kenc_ withByteArray:
#line 748
    ssc_ withByteArray:
#line 749
    kmac_ withEsGobJmulticardCryptoHelper:
#line 750
    cryptoHelper_];
    
#line 755
    if ([((EsGobJmulticardApduStatusWord *) nil_chk([((EsGobJmulticardApduResponseApdu *) nil_chk(decipherApdu)) getStatusWord])) getMsb] == EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_MSB_INCORRECT_LE) {
      [((EsGobJmulticardApduCommandApdu *) nil_chk(command)) setLeWithInt:[((EsGobJmulticardApduStatusWord *) nil_chk([decipherApdu getStatusWord])) getLsb]];
      return [self transmitWithEsGobJmulticardApduCommandApdu:command];
    }
    if ([((EsGobJmulticardApduStatusWord *) nil_chk([decipherApdu getStatusWord])) getMsb] == EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_MSB_INCORRECT_LE_PACE) {
      [((EsGobJmulticardApduCommandApdu *) nil_chk(command)) setLeWithInt:[((JavaLangInteger *) nil_chk([command getLe])) intValue] - 1];
      return [self transmitWithEsGobJmulticardApduCommandApdu:command];
    }
    return decipherApdu;
  }
  @catch (JavaLangException *e) {
    @throw new_EsGobJmulticardConnectionApduConnectionException_initWithNSString_withJavaLangThrowable_(
#line 767
    @"Error en la desencriptacion de la APDU de respuesta recibida por el canal seguro", e);
  }
}


#line 772
- (IOSByteArray *)reset {
  
#line 775
  openState_ = false;
  
#line 778
  IOSByteArray *atr = [((id<EsGobJmulticardConnectionApduConnection>) nil_chk(subConnection_)) reset];
  
#line 781
  [self open];
  
#line 783
  return atr;
}


#line 786
- (IOSLongArray *)getTerminalsWithBoolean:(jboolean)onlyWithCardPresent {
  
#line 788
  return [((id<EsGobJmulticardConnectionApduConnection>) nil_chk(subConnection_)) getTerminalsWithBoolean:onlyWithCardPresent];
}


#line 791
- (NSString *)getTerminalInfoWithInt:(jint)terminal {
  
#line 793
  return [((id<EsGobJmulticardConnectionApduConnection>) nil_chk(subConnection_)) getTerminalInfoWithInt:terminal];
}


#line 796
- (void)setTerminalWithInt:(jint)t {
  
#line 798
  [((id<EsGobJmulticardConnectionApduConnection>) nil_chk(subConnection_)) setTerminalWithInt:t];
}


#line 801
- (jboolean)isOpen {
  
#line 803
  return openState_ && [((id<EsGobJmulticardConnectionApduConnection>) nil_chk(subConnection_)) isOpen];
}


#line 809
+ (IOSByteArray *)incrementWithByteArray:(IOSByteArray *)data {
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_incrementWithByteArray_(data);
}


#line 839
- (id<EsGobJmulticardConnectionApduConnection>)getSubConnection {
  
#line 841
  return subConnection_;
}


#line 844
- (void)setProtocolWithEsGobJmulticardConnectionApduConnectionProtocol:(EsGobJmulticardConnectionApduConnectionProtocol *)p {
  
#line 846
  if (subConnection_ != nil) {
    [subConnection_ setProtocolWithEsGobJmulticardConnectionApduConnectionProtocol:p];
  }
}


#line 851
- (IOSByteArray *)getKenc {
  
#line 853
  return kenc_;
}


#line 856
- (IOSByteArray *)getKmac {
  
#line 858
  return kmac_;
}


#line 861
- (IOSByteArray *)getSsc {
  
#line 863
  return ssc_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "LEsGobJmulticardConnectionAbstractApduEncrypter;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 0, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "[B", 0x2, 4, 5, 6, -1, -1, -1 },
    { NULL, "[B", 0x2, 7, 5, 6, -1, -1, -1 },
    { NULL, "[B", 0xa, 8, 9, -1, -1, -1, -1 },
    { NULL, "[B", 0x9, 10, 11, 3, -1, -1, -1 },
    { NULL, "[B", 0x9, 12, 13, 6, -1, -1, -1 },
    { NULL, "[B", 0x2, 14, 15, 6, -1, -1, -1 },
    { NULL, "[B", 0x2, 16, 17, 6, -1, -1, -1 },
    { NULL, "[B", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "LEsGobJmulticardApduResponseApdu;", 0x1, 18, 19, 3, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, 3, -1, -1, -1 },
    { NULL, "[J", 0x1, 20, 21, 3, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 22, 23, 3, -1, -1, -1 },
    { NULL, "V", 0x1, 24, 23, 3, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 25, 5, -1, -1, -1, -1 },
    { NULL, "LEsGobJmulticardConnectionApduConnection;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 26, 27, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, -1, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(instantiateApduEncrypter);
  methods[1].selector = @selector(description);
  methods[2].selector = @selector(initWithEsGobJmulticardConnectionApduConnection:withEsGobJmulticardCryptoHelper:);
  methods[3].selector = @selector(initWithEsGobJmulticardCardCwa14890Cwa14890Card:withEsGobJmulticardConnectionApduConnection:withEsGobJmulticardCryptoHelper:withEsGobJmulticardCardCwa14890Cwa14890PublicConstants:withEsGobJmulticardCardCwa14890Cwa14890PrivateConstants:);
  methods[4].selector = @selector(open);
  methods[5].selector = @selector(generateKencWithByteArray:);
  methods[6].selector = @selector(generateKmacWithByteArray:);
  methods[7].selector = @selector(generateSscWithByteArray:withByteArray:);
  methods[8].selector = @selector(internalAuthGetInternalAuthenticateMessageWithEsGobJmulticardCardCwa14890Cwa14890Card:withEsGobJmulticardCardCwa14890Cwa14890PublicConstants:withByteArray:);
  methods[9].selector = @selector(internalAuthValidateInternalAuthenticateMessageWithByteArray:withByteArray:withByteArray:withJavaSecurityInterfacesRSAPrivateKey:withInt:withEsGobJmulticardCardCwa14890Cwa14890PublicConstants:withJavaSecurityInterfacesRSAPublicKey:withEsGobJmulticardCryptoHelper:);
  methods[10].selector = @selector(internalAuthenticationWithByteArray:withJavaSecurityInterfacesRSAPublicKey:);
  methods[11].selector = @selector(externalAuthenticationWithByteArray:withByteArray:withJavaSecurityInterfacesRSAPublicKey:);
  methods[12].selector = @selector(getPaddedSerial);
  methods[13].selector = @selector(close);
  methods[14].selector = @selector(transmitWithEsGobJmulticardApduCommandApdu:);
  methods[15].selector = @selector(reset);
  methods[16].selector = @selector(getTerminalsWithBoolean:);
  methods[17].selector = @selector(getTerminalInfoWithInt:);
  methods[18].selector = @selector(setTerminalWithInt:);
  methods[19].selector = @selector(isOpen);
  methods[20].selector = @selector(incrementWithByteArray:);
  methods[21].selector = @selector(getSubConnection);
  methods[22].selector = @selector(setProtocolWithEsGobJmulticardConnectionApduConnectionProtocol:);
  methods[23].selector = @selector(getKenc);
  methods[24].selector = @selector(getKmac);
  methods[25].selector = @selector(getSsc);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "KICC_LENGTH", "I", .constantValue.asInt = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_KICC_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "KIFD_LENGTH", "I", .constantValue.asInt = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_KIFD_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "ISO_9796_2_PADDING_START", "B", .constantValue.asChar = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_START, 0x1a, -1, -1, -1, -1 },
    { "ISO_9796_2_PADDING_END", "B", .constantValue.asChar = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_END, 0x1a, -1, -1, -1, -1 },
    { "INVALID_CRYPTO_CHECKSUM", "LEsGobJmulticardApduStatusWord;", .constantValue.asLong = 0, 0x1a, -1, 28, -1, -1 },
    { "MSB_INCORRECT_LE", "B", .constantValue.asChar = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_MSB_INCORRECT_LE, 0x1a, -1, -1, -1, -1 },
    { "MSB_INCORRECT_LE_PACE", "B", .constantValue.asChar = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_MSB_INCORRECT_LE_PACE, 0x1a, -1, -1, -1, -1 },
    { "SECURE_CHANNEL_KENC_AUX", "[B", .constantValue.asLong = 0, 0x1a, -1, 29, -1, -1 },
    { "SECURE_CHANNEL_KMAC_AUX", "[B", .constantValue.asLong = 0, 0x1a, -1, 30, -1, -1 },
    { "cryptoHelper_", "LEsGobJmulticardCryptoHelper;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "card_", "LEsGobJmulticardCardCwa14890Cwa14890Card;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "subConnection_", "LEsGobJmulticardConnectionApduConnection;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "kenc_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "kmac_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "ssc_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "openState_", "Z", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
    { "apduEncrypter_", "LEsGobJmulticardConnectionAbstractApduEncrypter;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "pubConsts_", "LEsGobJmulticardCardCwa14890Cwa14890PublicConstants;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "privConsts_", "LEsGobJmulticardCardCwa14890Cwa14890PrivateConstants;", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "toString", "LEsGobJmulticardConnectionApduConnection;LEsGobJmulticardCryptoHelper;", "LEsGobJmulticardCardCwa14890Cwa14890Card;LEsGobJmulticardConnectionApduConnection;LEsGobJmulticardCryptoHelper;LEsGobJmulticardCardCwa14890Cwa14890PublicConstants;LEsGobJmulticardCardCwa14890Cwa14890PrivateConstants;", "LEsGobJmulticardConnectionApduConnectionException;", "generateKenc", "[B", "LJavaIoIOException;", "generateKmac", "generateSsc", "[B[B", "internalAuthGetInternalAuthenticateMessage", "LEsGobJmulticardCardCwa14890Cwa14890Card;LEsGobJmulticardCardCwa14890Cwa14890PublicConstants;[B", "internalAuthValidateInternalAuthenticateMessage", "[B[B[BLJavaSecurityInterfacesRSAPrivateKey;ILEsGobJmulticardCardCwa14890Cwa14890PublicConstants;LJavaSecurityInterfacesRSAPublicKey;LEsGobJmulticardCryptoHelper;", "internalAuthentication", "[BLJavaSecurityInterfacesRSAPublicKey;", "externalAuthentication", "[B[BLJavaSecurityInterfacesRSAPublicKey;", "transmit", "LEsGobJmulticardApduCommandApdu;", "getTerminals", "Z", "getTerminalInfo", "I", "setTerminal", "increment", "setProtocol", "LEsGobJmulticardConnectionApduConnectionProtocol;", &EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_INVALID_CRYPTO_CHECKSUM, &EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_SECURE_CHANNEL_KENC_AUX, &EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_SECURE_CHANNEL_KMAC_AUX };
  static const J2ObjcClassInfo _EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection = { "Cwa14890OneV1Connection", "es.gob.jmulticard.connection.cwa14890", ptrTable, methods, fields, 7, 0x1, 26, 19, -1, -1, -1, -1, -1 };
  return &_EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection;
}

+ (void)initialize {
  if (self == [EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection class]) {
    EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_INVALID_CRYPTO_CHECKSUM = new_EsGobJmulticardApduStatusWord_initWithByte_withByte_(
#line 76
    (jbyte) (jint) 0x66, (jbyte) (jint) 0x88);
    EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_SECURE_CHANNEL_KENC_AUX = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 86
      (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x01 } count:4];
      EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_SECURE_CHANNEL_KMAC_AUX = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 91
        (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x00, (jbyte) (jint) 0x02 } count:4];
        J2OBJC_SET_INITIALIZED(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection)
      }
    }

@end


#line 143
void EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initWithEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, id<EsGobJmulticardConnectionApduConnection> connection, EsGobJmulticardCryptoHelper *cryptoHlpr) {
  NSObject_init(self);
  self->kenc_ =
#line 104
  nil;
  self->kmac_ =
#line 107
  nil;
  self->ssc_ =
#line 110
  nil;
  self->openState_ =
#line 113
  false;
  
#line 146
  if (cryptoHlpr == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(
#line 148
    @"CryptoHelper no puede ser nulo");
  }
  
#line 151
  self->subConnection_ = [EsGobJmulticardConnectionCwa14890Cwa14890Connection_class_() isInstance:connection] ?
#line 152
  [((id<EsGobJmulticardConnectionCwa14890Cwa14890Connection>) nil_chk(((id<EsGobJmulticardConnectionCwa14890Cwa14890Connection>) cast_check(connection, EsGobJmulticardConnectionCwa14890Cwa14890Connection_class_())))) getSubConnection] :
#line 153
  connection;
  self->cryptoHelper_ = cryptoHlpr;
  self->apduEncrypter_ = [self instantiateApduEncrypter];
}


#line 143
EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *new_EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initWithEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_(id<EsGobJmulticardConnectionApduConnection> connection, EsGobJmulticardCryptoHelper *cryptoHlpr) {
  J2OBJC_NEW_IMPL(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, initWithEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_, connection, cryptoHlpr)
}


#line 143
EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *create_EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initWithEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_(id<EsGobJmulticardConnectionApduConnection> connection, EsGobJmulticardCryptoHelper *cryptoHlpr) {
  J2OBJC_CREATE_IMPL(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, initWithEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_, connection, cryptoHlpr)
}


#line 168
void EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withEsGobJmulticardCardCwa14890Cwa14890PrivateConstants_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, id<EsGobJmulticardCardCwa14890Cwa14890Card> connectedCard, id<EsGobJmulticardConnectionApduConnection> connection, EsGobJmulticardCryptoHelper *cryptoHlpr, id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants> cwaConsts, id<EsGobJmulticardCardCwa14890Cwa14890PrivateConstants> cwaPrivConsts) {
  NSObject_init(self);
  self->kenc_ =
#line 104
  nil;
  self->kmac_ =
#line 107
  nil;
  self->ssc_ =
#line 110
  nil;
  self->openState_ =
#line 113
  false;
  
#line 174
  if (connectedCard == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(
#line 176
    @"No se ha proporcionado la tarjeta CWA-14890 con la que abrir el canal seguro");
  }
  
#line 179
  if (cryptoHlpr == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(
#line 181
    @"CryptoHelper no puede ser nulo");
  }
  
#line 184
  if (cwaConsts == nil) {
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(
#line 186
    @"las claves CWA-14890 no pueden ser nulas");
  }
  
#line 190
  self->card_ = connectedCard;
  self->subConnection_ = [EsGobJmulticardConnectionCwa14890Cwa14890Connection_class_() isInstance:connection] ?
#line 192
  [((id<EsGobJmulticardConnectionCwa14890Cwa14890Connection>) nil_chk(((id<EsGobJmulticardConnectionCwa14890Cwa14890Connection>) cast_check(connection, EsGobJmulticardConnectionCwa14890Cwa14890Connection_class_())))) getSubConnection] :
#line 193
  connection;
  self->cryptoHelper_ = cryptoHlpr;
  self->apduEncrypter_ = [self instantiateApduEncrypter];
  self->pubConsts_ = cwaConsts;
  self->privConsts_ = cwaPrivConsts;
}


#line 168
EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *new_EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withEsGobJmulticardCardCwa14890Cwa14890PrivateConstants_(id<EsGobJmulticardCardCwa14890Cwa14890Card> connectedCard, id<EsGobJmulticardConnectionApduConnection> connection, EsGobJmulticardCryptoHelper *cryptoHlpr, id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants> cwaConsts, id<EsGobJmulticardCardCwa14890Cwa14890PrivateConstants> cwaPrivConsts) {
  J2OBJC_NEW_IMPL(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, initWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withEsGobJmulticardCardCwa14890Cwa14890PrivateConstants_, connectedCard, connection, cryptoHlpr, cwaConsts, cwaPrivConsts)
}


#line 168
EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *create_EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withEsGobJmulticardCardCwa14890Cwa14890PrivateConstants_(id<EsGobJmulticardCardCwa14890Cwa14890Card> connectedCard, id<EsGobJmulticardConnectionApduConnection> connection, EsGobJmulticardCryptoHelper *cryptoHlpr, id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants> cwaConsts, id<EsGobJmulticardCardCwa14890Cwa14890PrivateConstants> cwaPrivConsts) {
  J2OBJC_CREATE_IMPL(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection, initWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardConnectionApduConnection_withEsGobJmulticardCryptoHelper_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withEsGobJmulticardCardCwa14890Cwa14890PrivateConstants_, connectedCard, connection, cryptoHlpr, cwaConsts, cwaPrivConsts)
}


#line 364
IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateKencWithByteArray_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, IOSByteArray *kidficc) {
  
#line 366
  IOSByteArray *kidficcConcat = EsGobJmulticardHexUtils_concatenateByteArraysWithByteArray2_([IOSObjectArray newArrayWithObjects:(id[]){ kidficc, EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_SECURE_CHANNEL_KENC_AUX } count:2 type:IOSClass_byteArray(1)]);
  
#line 368
  IOSByteArray *keyEnc = [IOSByteArray newArrayWithLength:16];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 370
  [((EsGobJmulticardCryptoHelper *) nil_chk(self->cryptoHelper_)) digestWithEsGobJmulticardDigestAlgorithm:JreLoadEnum(EsGobJmulticardDigestAlgorithm, SHA1) withByteArray:kidficcConcat],
#line 371
  0,
#line 372
  keyEnc,
#line 373
  0,
#line 374
  keyEnc->size_);
  
#line 377
  return keyEnc;
}

IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateKmacWithByteArray_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, IOSByteArray *kidficc) {
  
#line 389
  IOSByteArray *kidficcConcat = EsGobJmulticardHexUtils_concatenateByteArraysWithByteArray2_([IOSObjectArray newArrayWithObjects:(id[]){ kidficc, EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_SECURE_CHANNEL_KMAC_AUX } count:2 type:IOSClass_byteArray(1)]);
  
#line 391
  IOSByteArray *keyMac = [IOSByteArray newArrayWithLength:16];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 393
  [((EsGobJmulticardCryptoHelper *) nil_chk(self->cryptoHelper_)) digestWithEsGobJmulticardDigestAlgorithm:JreLoadEnum(EsGobJmulticardDigestAlgorithm, SHA1) withByteArray:kidficcConcat],
#line 394
  0,
#line 395
  keyMac,
#line 396
  0,
#line 397
  keyMac->size_);
  
#line 400
  return keyMac;
}


#line 411
IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_generateSscWithByteArray_withByteArray_(IOSByteArray *randomIfd, IOSByteArray *randomIcc) {
  EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initialize();
  IOSByteArray *ssc = [IOSByteArray newArrayWithLength:8];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(randomIcc, 4, ssc, 0, 4);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(randomIfd, 4, ssc, 4, 4);
  
#line 417
  return ssc;
}


#line 426
IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthGetInternalAuthenticateMessageWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withByteArray_(id<EsGobJmulticardCardCwa14890Cwa14890Card> card, id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants> pubConsts, IOSByteArray *randomIfd) {
  EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initialize();
  
#line 432
  @try {
    [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(card)) setKeysToAuthenticationWithByteArray:
#line 434
    [card getChrCCvIfdWithEsGobJmulticardCardCwa14890Cwa14890PublicConstants:pubConsts] withByteArray:
#line 435
    [card getRefIccPrivateKeyWithEsGobJmulticardCardCwa14890Cwa14890PublicConstants:pubConsts]];
  }
  @catch (
#line 438
  JavaLangException *e) {
    @throw new_EsGobJmulticardConnectionCwa14890SecureChannelException_initWithNSString_withJavaLangThrowable_(
#line 440
    @"Error durante el establecimiento de la clave publica de Terminal y la privada de Componente para su autenticacion",
#line 441
    e);
  }
  
#line 446
  return [card getInternalAuthenticateMessageWithByteArray:randomIfd withByteArray:[card getChrCCvIfdWithEsGobJmulticardCardCwa14890Cwa14890PublicConstants:pubConsts]];
}


#line 461
IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthValidateInternalAuthenticateMessageWithByteArray_withByteArray_withByteArray_withJavaSecurityInterfacesRSAPrivateKey_withInt_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withJavaSecurityInterfacesRSAPublicKey_withEsGobJmulticardCryptoHelper_(IOSByteArray *chrCCvIfd, IOSByteArray *sigMinCiphered, IOSByteArray *randomIfd, id<JavaSecurityInterfacesRSAPrivateKey> ifdPrivateKey, jint ifdKeyLength, id<EsGobJmulticardCardCwa14890Cwa14890PublicConstants> pubConsts, id<JavaSecurityInterfacesRSAPublicKey> iccPublicKey, EsGobJmulticardCryptoHelper *cryptoHelper) {
  EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initialize();
  
#line 470
  IOSByteArray *sigMin = [((EsGobJmulticardCryptoHelper *) nil_chk(cryptoHelper)) rsaDecryptWithByteArray:sigMinCiphered withJavaSecurityInterfacesRSAKey:ifdPrivateKey];
  
#line 478
  IOSByteArray *sig = sigMin;
  IOSByteArray *desMsg = [cryptoHelper rsaEncryptWithByteArray:sig withJavaSecurityInterfacesRSAKey:iccPublicKey];
  
#line 488
  if (IOSByteArray_Get(nil_chk(desMsg), 0) != EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_START || IOSByteArray_Get(desMsg, desMsg->size_ - 1) != EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_END) {
    
#line 491
    IOSByteArray *sub = [((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((id<JavaSecurityInterfacesRSAPublicKey>) nil_chk(iccPublicKey)) getModulus])) subtractWithJavaMathBigInteger:new_JavaMathBigInteger_initWithInt_withByteArray_(1, sig)])) toByteArray];
    IOSByteArray *niccMinusSig = [IOSByteArray newArrayWithLength:ifdKeyLength];
    
#line 495
    if (((IOSByteArray *) nil_chk(sub))->size_ > ifdKeyLength && IOSByteArray_Get(sub, 0) == (jbyte) (jint) 0x00) {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(sub, 1, niccMinusSig, 0, sub->size_ - 1);
    }
    else {
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(sub, 0, niccMinusSig, 0, sub->size_);
    }
    
#line 503
    desMsg = [cryptoHelper rsaDecryptWithByteArray:niccMinusSig withJavaSecurityInterfacesRSAKey:iccPublicKey];
    
#line 507
    if (IOSByteArray_Get(nil_chk(desMsg), 0) != EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_START || IOSByteArray_Get(desMsg, desMsg->size_ - 1) != EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_END) {
      @throw new_EsGobJmulticardConnectionCwa14890SecureChannelException_initWithNSString_(JreStrcat("$$", @"Error en la autenticacion interna para el establecimiento del canal seguro. El mensaje descifrado es:\n", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(
#line 510
      desMsg, true)));
    }
  }
  
#line 521
  IOSByteArray *prnd1 = [IOSByteArray newArrayWithLength:ifdKeyLength - EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_KICC_LENGTH - [((EsGobJmulticardDigestAlgorithm *) nil_chk(JreLoadEnum(EsGobJmulticardDigestAlgorithm, SHA1))) getDigestLength] - 2];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 523
  desMsg,
#line 524
  1,
#line 525
  prnd1,
#line 526
  0,
#line 527
  prnd1->size_);
  
#line 530
  IOSByteArray *kicc = [IOSByteArray newArrayWithLength:EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_KICC_LENGTH];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 532
  desMsg,
#line 533
  prnd1->size_ + 1,
#line 534
  kicc,
#line 535
  0,
#line 536
  kicc->size_);
  
#line 539
  IOSByteArray *hash_ = [IOSByteArray newArrayWithLength:[JreLoadEnum(EsGobJmulticardDigestAlgorithm, SHA1) getDigestLength]];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 541
  desMsg,
#line 542
  prnd1->size_ + kicc->size_ + 1,
#line 543
  hash_,
#line 544
  0,
#line 545
  hash_->size_);
  
#line 556
  JavaIoByteArrayOutputStream *baos = new_JavaIoByteArrayOutputStream_init();
  [baos writeWithByteArray:prnd1];
  [baos writeWithByteArray:kicc];
  [baos writeWithByteArray:randomIfd];
  [baos writeWithByteArray:chrCCvIfd];
  
#line 562
  IOSByteArray *calculatedHash = [cryptoHelper digestWithEsGobJmulticardDigestAlgorithm:JreLoadEnum(EsGobJmulticardDigestAlgorithm, SHA1) withByteArray:[baos toByteArray]];
  if (!EsGobJmulticardHexUtils_arrayEqualsWithByteArray_withByteArray_(hash_, calculatedHash)) {
    @throw new_EsGobJmulticardConnectionCwa14890SecureChannelException_initWithNSString_(JreStrcat("$$$$C", @"Error en la comprobacion de la clave de autenticacion interna. Se obtuvo el hash '", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(
#line 566
    calculatedHash, false), @"' cuando se esperaba: '", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(
#line 567
    hash_, false), '\''));
  }
  
#line 571
  return kicc;
}


#line 582
IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthenticationWithByteArray_withJavaSecurityInterfacesRSAPublicKey_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, IOSByteArray *randomIfd, id<JavaSecurityInterfacesRSAPublicKey> iccPublicKey) {
  
#line 586
  IOSByteArray *sigMinCiphered = EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthGetInternalAuthenticateMessageWithEsGobJmulticardCardCwa14890Cwa14890Card_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withByteArray_(self->card_, self->pubConsts_, randomIfd);
  
#line 590
  return EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_internalAuthValidateInternalAuthenticateMessageWithByteArray_withByteArray_withByteArray_withJavaSecurityInterfacesRSAPrivateKey_withInt_withEsGobJmulticardCardCwa14890Cwa14890PublicConstants_withJavaSecurityInterfacesRSAPublicKey_withEsGobJmulticardCryptoHelper_(
#line 591
  [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(self->card_)) getChrCCvIfdWithEsGobJmulticardCardCwa14890Cwa14890PublicConstants:self->pubConsts_],
#line 592
  sigMinCiphered,
#line 593
  randomIfd,
#line 594
  [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(self->card_)) getIfdPrivateKeyWithEsGobJmulticardCardCwa14890Cwa14890PrivateConstants:self->privConsts_],
#line 595
  [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(self->card_)) getIfdKeyLengthWithEsGobJmulticardCardCwa14890Cwa14890PublicConstants:self->pubConsts_], self->pubConsts_,
#line 597
  iccPublicKey, self->cryptoHelper_);
}


#line 612
IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_externalAuthenticationWithByteArray_withByteArray_withJavaSecurityInterfacesRSAPublicKey_(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self, IOSByteArray *serial, IOSByteArray *randomIcc, id<JavaSecurityInterfacesRSAPublicKey> iccPublicKey) {
  
#line 639
  IOSByteArray *prnd2 = [((EsGobJmulticardCryptoHelper *) nil_chk(self->cryptoHelper_)) generateRandomBytesWithInt:
#line 640
  [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(self->card_)) getIfdKeyLengthWithEsGobJmulticardCardCwa14890Cwa14890PublicConstants:self->pubConsts_] - 2 - EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_KIFD_LENGTH - [((EsGobJmulticardDigestAlgorithm *) nil_chk(JreLoadEnum(EsGobJmulticardDigestAlgorithm, SHA1))) getDigestLength]];
  
#line 642
  IOSByteArray *kifd = [self->cryptoHelper_ generateRandomBytesWithInt:EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_KIFD_LENGTH];
  
#line 650
  JavaIoByteArrayOutputStream *baos = new_JavaIoByteArrayOutputStream_init();
  [baos writeWithByteArray:prnd2];
  [baos writeWithByteArray:kifd];
  [baos writeWithByteArray:randomIcc];
  [baos writeWithByteArray:serial];
  
#line 656
  IOSByteArray *hash_ = [self->cryptoHelper_ digestWithEsGobJmulticardDigestAlgorithm:JreLoadEnum(EsGobJmulticardDigestAlgorithm, SHA1) withByteArray:
#line 658
  [baos toByteArray]];
  
#line 667
  [baos reset];
  [baos writeWithInt:EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_START];
  [baos writeWithByteArray:prnd2];
  [baos writeWithByteArray:kifd];
  [baos writeWithByteArray:hash_];
  [baos writeWithInt:EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_ISO_9796_2_PADDING_END];
  
#line 674
  IOSByteArray *msg = [baos toByteArray];
  id<JavaSecurityInterfacesRSAPrivateKey> ifdPrivateKey = [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(self->card_)) getIfdPrivateKeyWithEsGobJmulticardCardCwa14890Cwa14890PrivateConstants:self->privConsts_];
  
#line 678
  IOSByteArray *sig = [self->cryptoHelper_ rsaDecryptWithByteArray:msg withJavaSecurityInterfacesRSAKey:ifdPrivateKey];
  
#line 681
  JavaMathBigInteger *biSig = new_JavaMathBigInteger_initWithInt_withByteArray_(1, sig);
  IOSByteArray *sigMin = [((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((id<JavaSecurityInterfacesRSAPrivateKey>) nil_chk(ifdPrivateKey)) getModulus])) subtractWithJavaMathBigInteger:biSig])) minWithJavaMathBigInteger:biSig])) toByteArray];
  
#line 685
  IOSByteArray *extAuthenticationData = [self->cryptoHelper_ rsaEncryptWithByteArray:sigMin withJavaSecurityInterfacesRSAKey:iccPublicKey];
  
#line 687
  jboolean valid = [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(self->card_)) externalAuthenticationWithByteArray:extAuthenticationData];
  if (!valid) {
    @throw new_EsGobJmulticardConnectionCwa14890SecureChannelException_initWithNSString_(@"Error durante la autenticacion externa del canal seguro");
  }
  
#line 692
  return kifd;
}


#line 700
IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_getPaddedSerial(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection *self) {
  
#line 702
  IOSByteArray *serial = [((id<EsGobJmulticardCardCwa14890Cwa14890Card>) nil_chk(self->card_)) getSerialNumber];
  IOSByteArray *paddedSerial = serial;
  if (((IOSByteArray *) nil_chk(paddedSerial))->size_ < 8) {
    paddedSerial = [IOSByteArray newArrayWithLength:8];
    jint i;
    for (i = 0; i < 8 - ((IOSByteArray *) nil_chk(serial))->size_; i++) {
      *IOSByteArray_GetRef(paddedSerial, i) = (jbyte) (jint) 0x00;
    }
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(serial, 0, paddedSerial, i, serial->size_);
  }
  return paddedSerial;
}


#line 809
IOSByteArray *EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_incrementWithByteArray_(IOSByteArray *data) {
  EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection_initialize();
  JavaMathBigInteger *bi = [new_JavaMathBigInteger_initWithInt_withByteArray_(1, data) addWithJavaMathBigInteger:JreLoadStatic(JavaMathBigInteger, ONE)];
  
#line 813
  IOSByteArray *biArray = [((JavaMathBigInteger *) nil_chk(bi)) toByteArray];
  if (((IOSByteArray *) nil_chk(biArray))->size_ > 8) {
    IOSByteArray *incrementedValue = [IOSByteArray newArrayWithLength:8];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 817
    biArray,
#line 818
    biArray->size_ - incrementedValue->size_,
#line 819
    incrementedValue,
#line 820
    0,
#line 821
    incrementedValue->size_);
    
#line 823
    return incrementedValue;
  }
  if (biArray->size_ < 8) {
    IOSByteArray *incrementedValue = [IOSByteArray newArrayWithLength:8];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 828
    biArray,
#line 829
    0,
#line 830
    incrementedValue,
#line 831
    incrementedValue->size_ - biArray->size_,
#line 832
    biArray->size_);
    
#line 834
    return incrementedValue;
  }
  return biArray;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardConnectionCwa14890Cwa14890OneV1Connection)
