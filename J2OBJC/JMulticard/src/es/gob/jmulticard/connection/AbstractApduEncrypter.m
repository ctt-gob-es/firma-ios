//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/connection/AbstractApduEncrypter.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "es/gob/jmulticard/CryptoHelper.h"
#include "es/gob/jmulticard/HexUtils.h"
#include "es/gob/jmulticard/apdu/CommandApdu.h"
#include "es/gob/jmulticard/apdu/ResponseApdu.h"
#include "es/gob/jmulticard/asn1/Tlv.h"
#include "es/gob/jmulticard/connection/AbstractApduEncrypter.h"
#include "es/gob/jmulticard/connection/CipheredApdu.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/lang/Integer.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"

#if !__has_feature(objc_arc)
#error "es/gob/jmulticard/connection/AbstractApduEncrypter must be compiled with ARC (-fobjc-arc)"
#endif

@interface EsGobJmulticardConnectionAbstractApduEncrypter ()

/*!
 @brief Borra un array de octetos insertando nulos.
 @param inArray Array a borrar, se modifica por mutabilidad.
 */
+ (void)wipeByteArrayWithByteArray:(IOSByteArray *)inArray;

+ (IOSByteArray *)getCompleteDataBytesWithJavaLangInteger:(JavaLangInteger *)le
                                            withByteArray:(IOSByteArray *)tlvDataBytes;

- (IOSByteArray *)getDataTlvWithByteArray:(IOSByteArray *)data
                            withByteArray:(IOSByteArray *)keyCipher
                            withByteArray:(IOSByteArray *)sendSequenceCounter
          withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHelper
                                  withInt:(jint)paddingSize;

@end

/*!
 @brief Tag del TLV del Le de una APDU protegida.
 */
inline jbyte EsGobJmulticardConnectionAbstractApduEncrypter_get_TAG_LE_TLV(void);
#define EsGobJmulticardConnectionAbstractApduEncrypter_TAG_LE_TLV -105
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionAbstractApduEncrypter, TAG_LE_TLV, jbyte)

/*!
 @brief Byte prefijo de los datos para el c&aacute;lculo de la MAC.
 */
inline jbyte EsGobJmulticardConnectionAbstractApduEncrypter_get_TLV_VALUE_PREFIX_TO_MAC(void);
#define EsGobJmulticardConnectionAbstractApduEncrypter_TLV_VALUE_PREFIX_TO_MAC 1
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionAbstractApduEncrypter, TLV_VALUE_PREFIX_TO_MAC, jbyte)

/*!
 @brief CLA que se suma a los CLA de las APDU que se protegen.
 */
inline jbyte EsGobJmulticardConnectionAbstractApduEncrypter_get_CLA_OF_PROTECTED_APDU(void);
#define EsGobJmulticardConnectionAbstractApduEncrypter_CLA_OF_PROTECTED_APDU 12
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionAbstractApduEncrypter, CLA_OF_PROTECTED_APDU, jbyte)

/*!
 @brief Primer byte a agregar en los padding ISO-7816.
 */
inline jbyte EsGobJmulticardConnectionAbstractApduEncrypter_get_ISO7816_PADDING_PREFIX(void);
#define EsGobJmulticardConnectionAbstractApduEncrypter_ISO7816_PADDING_PREFIX -128
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionAbstractApduEncrypter, ISO7816_PADDING_PREFIX, jbyte)

__attribute__((unused)) static void EsGobJmulticardConnectionAbstractApduEncrypter_wipeByteArrayWithByteArray_(IOSByteArray *inArray);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionAbstractApduEncrypter_getCompleteDataBytesWithJavaLangInteger_withByteArray_(JavaLangInteger *le, IOSByteArray *tlvDataBytes);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionAbstractApduEncrypter_getDataTlvWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_withInt_(EsGobJmulticardConnectionAbstractApduEncrypter *self, IOSByteArray *data, IOSByteArray *keyCipher, IOSByteArray *sendSequenceCounter, EsGobJmulticardCryptoHelper *cryptoHelper, jint paddingSize);

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/connection/AbstractApduEncrypter.java"


#line 55
@implementation EsGobJmulticardConnectionAbstractApduEncrypter

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 55
- (instancetype)init {
  EsGobJmulticardConnectionAbstractApduEncrypter_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 84
- (EsGobJmulticardConnectionCipheredApdu *)protectAPDUWithEsGobJmulticardApduCommandApdu:(EsGobJmulticardApduCommandApdu *)unprotectedApdu
                                                                           withByteArray:(IOSByteArray *)keyCipher
                                                                           withByteArray:(IOSByteArray *)keyMac
                                                                           withByteArray:(IOSByteArray *)sendSequenceCounter
                                                         withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHelper {
  
#line 90
  jbyte cla = [((EsGobJmulticardApduCommandApdu *) nil_chk(unprotectedApdu)) getCla];
  jbyte ins = [unprotectedApdu getIns];
  jbyte p1 = [unprotectedApdu getP1];
  jbyte p2 = [unprotectedApdu getP2];
  IOSByteArray *data = [unprotectedApdu getData];
  JavaLangInteger *le = [unprotectedApdu getLe];
  
#line 97
  IOSByteArray *tlvDataBytes = EsGobJmulticardConnectionAbstractApduEncrypter_getDataTlvWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_withInt_(self,
#line 98
  data, keyCipher, sendSequenceCounter, cryptoHelper, paddingLength_);
  
#line 100
  IOSByteArray *completeDataBytes = EsGobJmulticardConnectionAbstractApduEncrypter_getCompleteDataBytesWithJavaLangInteger_withByteArray_(le, tlvDataBytes);
  
#line 103
  cla = (jbyte) (cla | EsGobJmulticardConnectionAbstractApduEncrypter_CLA_OF_PROTECTED_APDU);
  
#line 106
  JavaIoByteArrayOutputStream *baos = new_JavaIoByteArrayOutputStream_init();
  [baos writeWithByteArray:EsGobJmulticardConnectionAbstractApduEncrypter_addPadding7816WithByteArray_withInt_([IOSByteArray newArrayWithBytes:(jbyte[]){
#line 110
    cla, ins, p1, p2 } count:4],
#line 112
    paddingLength_)];
    
#line 115
    [baos writeWithByteArray:completeDataBytes];
    IOSByteArray *encryptedDataPadded = EsGobJmulticardConnectionAbstractApduEncrypter_addPadding7816WithByteArray_withInt_([baos toByteArray], paddingLength_);
    
#line 119
    IOSByteArray *mac = [self generateMacWithByteArray:
#line 120
    encryptedDataPadded withByteArray:
#line 121
    sendSequenceCounter withByteArray:
#line 122
    keyMac withEsGobJmulticardCryptoHelper:
#line 123
    cryptoHelper];
    
#line 126
    return new_EsGobJmulticardConnectionCipheredApdu_initWithByte_withByte_withByte_withByte_withByteArray_withByteArray_(cla, ins, p1, p2, completeDataBytes, mac);
  }

- (IOSByteArray *)encryptDataWithByteArray:(IOSByteArray *)data
                             withByteArray:(IOSByteArray *)key
                             withByteArray:(IOSByteArray *)ssc
           withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHelper {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 147
+ (IOSByteArray *)addPadding7816WithByteArray:(IOSByteArray *)data
                                      withInt:(jint)size {
  return EsGobJmulticardConnectionAbstractApduEncrypter_addPadding7816WithByteArray_withInt_(data, size);
}


#line 161
+ (IOSByteArray *)removePadding7816WithByteArray:(IOSByteArray *)paddedData {
  return EsGobJmulticardConnectionAbstractApduEncrypter_removePadding7816WithByteArray_(paddedData);
}


#line 185
- (IOSByteArray *)generateMacWithByteArray:(IOSByteArray *)dataPadded
                             withByteArray:(IOSByteArray *)ssc
                             withByteArray:(IOSByteArray *)kMac
           withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHelper {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 198
- (EsGobJmulticardApduResponseApdu *)decryptResponseApduWithEsGobJmulticardApduResponseApdu:(EsGobJmulticardApduResponseApdu *)responseApdu
                                                                              withByteArray:(IOSByteArray *)keyCipher
                                                                              withByteArray:(IOSByteArray *)ssc
                                                                              withByteArray:(IOSByteArray *)kMac
                                                            withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHelper {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}


#line 206
+ (void)wipeByteArrayWithByteArray:(IOSByteArray *)inArray {
  EsGobJmulticardConnectionAbstractApduEncrypter_wipeByteArrayWithByteArray_(inArray);
}


#line 212
+ (IOSByteArray *)getCompleteDataBytesWithJavaLangInteger:(JavaLangInteger *)le
                                            withByteArray:(IOSByteArray *)tlvDataBytes {
  return EsGobJmulticardConnectionAbstractApduEncrypter_getCompleteDataBytesWithJavaLangInteger_withByteArray_(le, tlvDataBytes);
}


#line 233
- (IOSByteArray *)getDataTlvWithByteArray:(IOSByteArray *)data
                            withByteArray:(IOSByteArray *)keyCipher
                            withByteArray:(IOSByteArray *)sendSequenceCounter
          withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)cryptoHelper
                                  withInt:(jint)paddingSize {
  return EsGobJmulticardConnectionAbstractApduEncrypter_getDataTlvWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_withInt_(self, data, keyCipher, sendSequenceCounter, cryptoHelper, paddingSize);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LEsGobJmulticardConnectionCipheredApdu;", 0x1, 0, 1, 2, -1, -1, -1 },
    { NULL, "[B", 0x404, 3, 4, 2, -1, -1, -1 },
    { NULL, "[B", 0xc, 5, 6, -1, -1, -1, -1 },
    { NULL, "[B", 0xc, 7, 8, -1, -1, -1, -1 },
    { NULL, "[B", 0x404, 9, 4, 2, -1, -1, -1 },
    { NULL, "LEsGobJmulticardApduResponseApdu;", 0x401, 10, 11, 2, -1, -1, -1 },
    { NULL, "V", 0xa, 12, 8, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 13, 14, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 15, 16, 2, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(protectAPDUWithEsGobJmulticardApduCommandApdu:withByteArray:withByteArray:withByteArray:withEsGobJmulticardCryptoHelper:);
  methods[2].selector = @selector(encryptDataWithByteArray:withByteArray:withByteArray:withEsGobJmulticardCryptoHelper:);
  methods[3].selector = @selector(addPadding7816WithByteArray:withInt:);
  methods[4].selector = @selector(removePadding7816WithByteArray:);
  methods[5].selector = @selector(generateMacWithByteArray:withByteArray:withByteArray:withEsGobJmulticardCryptoHelper:);
  methods[6].selector = @selector(decryptResponseApduWithEsGobJmulticardApduResponseApdu:withByteArray:withByteArray:withByteArray:withEsGobJmulticardCryptoHelper:);
  methods[7].selector = @selector(wipeByteArrayWithByteArray:);
  methods[8].selector = @selector(getCompleteDataBytesWithJavaLangInteger:withByteArray:);
  methods[9].selector = @selector(getDataTlvWithByteArray:withByteArray:withByteArray:withEsGobJmulticardCryptoHelper:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG_DATA_TLV", "B", .constantValue.asChar = EsGobJmulticardConnectionAbstractApduEncrypter_TAG_DATA_TLV, 0x1c, -1, -1, -1, -1 },
    { "TAG_LE_TLV", "B", .constantValue.asChar = EsGobJmulticardConnectionAbstractApduEncrypter_TAG_LE_TLV, 0x1a, -1, -1, -1, -1 },
    { "TLV_VALUE_PREFIX_TO_MAC", "B", .constantValue.asChar = EsGobJmulticardConnectionAbstractApduEncrypter_TLV_VALUE_PREFIX_TO_MAC, 0x1a, -1, -1, -1, -1 },
    { "CLA_OF_PROTECTED_APDU", "B", .constantValue.asChar = EsGobJmulticardConnectionAbstractApduEncrypter_CLA_OF_PROTECTED_APDU, 0x1a, -1, -1, -1, -1 },
    { "ISO7816_PADDING_PREFIX", "B", .constantValue.asChar = EsGobJmulticardConnectionAbstractApduEncrypter_ISO7816_PADDING_PREFIX, 0x1a, -1, -1, -1, -1 },
    { "paddingLength_", "I", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "protectAPDU", "LEsGobJmulticardApduCommandApdu;[B[B[BLEsGobJmulticardCryptoHelper;", "LJavaIoIOException;", "encryptData", "[B[B[BLEsGobJmulticardCryptoHelper;", "addPadding7816", "[BI", "removePadding7816", "[B", "generateMac", "decryptResponseApdu", "LEsGobJmulticardApduResponseApdu;[B[B[BLEsGobJmulticardCryptoHelper;", "wipeByteArray", "getCompleteDataBytes", "LJavaLangInteger;[B", "getDataTlv", "[B[B[BLEsGobJmulticardCryptoHelper;I" };
  static const J2ObjcClassInfo _EsGobJmulticardConnectionAbstractApduEncrypter = { "AbstractApduEncrypter", "es.gob.jmulticard.connection", ptrTable, methods, fields, 7, 0x401, 10, 6, -1, -1, -1, -1, -1 };
  return &_EsGobJmulticardConnectionAbstractApduEncrypter;
}

@end


#line 55
void EsGobJmulticardConnectionAbstractApduEncrypter_init(EsGobJmulticardConnectionAbstractApduEncrypter *self) {
  NSObject_init(self);
  self->paddingLength_ =
#line 73
  8;
}


#line 147
IOSByteArray *EsGobJmulticardConnectionAbstractApduEncrypter_addPadding7816WithByteArray_withInt_(IOSByteArray *data, jint size) {
  EsGobJmulticardConnectionAbstractApduEncrypter_initialize();
  
#line 148
  IOSByteArray *paddedData = [IOSByteArray newArrayWithLength:(JreIntDiv(((IOSByteArray *) nil_chk(data))->size_, size) + 1) * size];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, paddedData, 0, data->size_);
  *IOSByteArray_GetRef(paddedData, data->size_) = EsGobJmulticardConnectionAbstractApduEncrypter_ISO7816_PADDING_PREFIX;
  
#line 152
  for (jint i = data->size_ + 1; i < paddedData->size_; i++) {
    *IOSByteArray_GetRef(paddedData, i) = 0x0000;
  }
  return paddedData;
}


#line 161
IOSByteArray *EsGobJmulticardConnectionAbstractApduEncrypter_removePadding7816WithByteArray_(IOSByteArray *paddedData) {
  EsGobJmulticardConnectionAbstractApduEncrypter_initialize();
  
#line 162
  for (jint i = ((IOSByteArray *) nil_chk(paddedData))->size_ - 1; i >= 0; i--) {
    if (IOSByteArray_Get(paddedData, i) == EsGobJmulticardConnectionAbstractApduEncrypter_ISO7816_PADDING_PREFIX) {
      if (i == 0) {
        return [IOSByteArray newArrayWithLength:0];
      }
      return EsGobJmulticardHexUtils_subArrayWithByteArray_withInt_withInt_(paddedData, 0, i);
    }
    if (IOSByteArray_Get(paddedData, i) != (jbyte) (jint) 0x00) {
      
#line 171
      return paddedData;
    }
  }
  
#line 175
  return paddedData;
}


#line 206
void EsGobJmulticardConnectionAbstractApduEncrypter_wipeByteArrayWithByteArray_(IOSByteArray *inArray) {
  EsGobJmulticardConnectionAbstractApduEncrypter_initialize();
  
#line 207
  if (inArray != nil) {
    JavaUtilArrays_fillWithByteArray_withByte_(inArray, (jbyte) 0x0000);
  }
}


#line 212
IOSByteArray *EsGobJmulticardConnectionAbstractApduEncrypter_getCompleteDataBytesWithJavaLangInteger_withByteArray_(JavaLangInteger *le, IOSByteArray *tlvDataBytes) {
  EsGobJmulticardConnectionAbstractApduEncrypter_initialize();
  
#line 215
  IOSByteArray *tlvLeBytes = [IOSByteArray newArrayWithBytes:(jbyte[]){  } count:0];
  if (le != nil) {
    tlvLeBytes = [new_EsGobJmulticardAsn1Tlv_initWithByte_withByteArray_(
#line 218
    EsGobJmulticardConnectionAbstractApduEncrypter_TAG_LE_TLV, [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 220
      [le charValue] } count:1]) getBytes];
    }
    
#line 226
    IOSByteArray *completeDataBytes = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(tlvDataBytes))->size_ + ((IOSByteArray *) nil_chk(tlvLeBytes))->size_];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tlvDataBytes, 0, completeDataBytes, 0, tlvDataBytes->size_);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(tlvLeBytes, 0, completeDataBytes, tlvDataBytes->size_, tlvLeBytes->size_);
    
#line 230
    return completeDataBytes;
  }


#line 233
IOSByteArray *EsGobJmulticardConnectionAbstractApduEncrypter_getDataTlvWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_withInt_(EsGobJmulticardConnectionAbstractApduEncrypter *self, IOSByteArray *data, IOSByteArray *keyCipher, IOSByteArray *sendSequenceCounter, EsGobJmulticardCryptoHelper *cryptoHelper, jint paddingSize) {
  
#line 240
  if (data != nil && data->size_ > 0) {
    JavaIoByteArrayOutputStream *baos = new_JavaIoByteArrayOutputStream_init();
    [baos writeWithInt:EsGobJmulticardConnectionAbstractApduEncrypter_TLV_VALUE_PREFIX_TO_MAC];
    IOSByteArray *paddedData = EsGobJmulticardConnectionAbstractApduEncrypter_addPadding7816WithByteArray_withInt_(data, paddingSize);
    [baos writeWithByteArray:[self encryptDataWithByteArray:paddedData withByteArray:keyCipher withByteArray:sendSequenceCounter withEsGobJmulticardCryptoHelper:cryptoHelper]];
    
#line 249
    EsGobJmulticardConnectionAbstractApduEncrypter_wipeByteArrayWithByteArray_(paddedData);
    EsGobJmulticardConnectionAbstractApduEncrypter_wipeByteArrayWithByteArray_(data);
    
#line 252
    return [new_EsGobJmulticardAsn1Tlv_initWithByte_withByteArray_(EsGobJmulticardConnectionAbstractApduEncrypter_TAG_DATA_TLV, [baos toByteArray]) getBytes];
  }
  return [IOSByteArray newArrayWithLength:0];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardConnectionAbstractApduEncrypter)
