//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/connection/pace/SecureMessaging.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "es/gob/jmulticard/CryptoHelper.h"
#include "es/gob/jmulticard/HexUtils.h"
#include "es/gob/jmulticard/JmcLogger.h"
#include "es/gob/jmulticard/apdu/CommandApdu.h"
#include "es/gob/jmulticard/apdu/ResponseApdu.h"
#include "es/gob/jmulticard/asn1/Tlv.h"
#include "es/gob/jmulticard/asn1/TlvException.h"
#include "es/gob/jmulticard/connection/pace/DO87.h"
#include "es/gob/jmulticard/connection/pace/DO8E.h"
#include "es/gob/jmulticard/connection/pace/DO97.h"
#include "es/gob/jmulticard/connection/pace/DO99.h"
#include "es/gob/jmulticard/connection/pace/SecureMessaging.h"
#include "es/gob/jmulticard/connection/pace/SecureMessagingException.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/IOException.h"
#include "java/lang/Integer.h"
#include "java/lang/System.h"
#include "java/math/BigInteger.h"
#include "java/security/GeneralSecurityException.h"
#include "java/security/InvalidKeyException.h"
#include "java/security/NoSuchAlgorithmException.h"
#include "java/util/Arrays.h"

#if !__has_feature(objc_arc)
#error "es/gob/jmulticard/connection/pace/SecureMessaging must be compiled with ARC (-fobjc-arc)"
#endif

@interface EsGobJmulticardConnectionPaceSecureMessaging () {
 @public
  IOSByteArray *kenc_;
  IOSByteArray *kmac_;
  IOSByteArray *ssc_;
  EsGobJmulticardCryptoHelper *cryptoHelper_;
}

/*!
 @brief Encripta los datos con <code>kenc</code> para construir el DO87.
 @param data Datos a encriptar.
 @return DO87 Par&aacute;metros del comando.
 @throw SecureMessagingExceptionEn caso de error en el cifrado.
 */
- (EsGobJmulticardConnectionPaceDO87 *)buildDO87WithByteArray:(IOSByteArray *)data;

- (EsGobJmulticardConnectionPaceDO8E *)buildDO8EWithByteArray:(IOSByteArray *)header
                        withEsGobJmulticardConnectionPaceDO87:(EsGobJmulticardConnectionPaceDO87 *)do87
                        withEsGobJmulticardConnectionPaceDO97:(EsGobJmulticardConnectionPaceDO97 *)do97;

+ (EsGobJmulticardConnectionPaceDO97 *)buildDO97WithInt:(jint)le;

/*!
 @brief Determina el equivalente a la APDU (ISO/IEC 7816-3 Cap&iacute;tulo 12&#46;1).
 @param capdu Comando APDU.
 @return Tipo de estructura (1 = CASE1, etc.).
 */
+ (jbyte)getAPDUStructureWithEsGobJmulticardApduCommandApdu:(EsGobJmulticardApduCommandApdu *)capdu;

+ (void)incrementAtIndexWithByteArray:(IOSByteArray *)array;

/*!
 @brief Obtiene el C&oacute;digo de Autenticaci&oacute;n de Mensaje (MAC) de
  tipo AES para los datos proporcionados.
 @param data Datos sobre los que calcular el MAC.
 @param ssCounter Contador de secuencia de env &iacute; os ( <i> Send Sequence Counter </i> ).
 @param keyBytes Clave de creaci &oacute; n de MAC.
 @return MAC de los datos.
 @throw NoSuchAlgorithmExceptionSi no se encuentra el algoritmo de creaci&oacute;n
                                   del MAC.
 @throw InvalidKeyExceptionSi la clave de creaci&oacute;n del MAC es inv&aacute;lida.
 */
- (IOSByteArray *)getMacWithByteArray:(IOSByteArray *)data
                        withByteArray:(IOSByteArray *)ssCounter
                        withByteArray:(IOSByteArray *)keyBytes;

/*!
 @brief A&ntilde;ade un relleno ISO9797-1 (m&eacute;todo 2) / ISO7816d4-Padding
  a los datos proporcionados.
 @param data Datos a rellenar.
 @return Datos con el relleno aplicado.
 */
+ (IOSByteArray *)addPaddingWithByteArray:(IOSByteArray *)data;

@end

J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionPaceSecureMessaging, kenc_, IOSByteArray *)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionPaceSecureMessaging, kmac_, IOSByteArray *)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionPaceSecureMessaging, ssc_, IOSByteArray *)
J2OBJC_FIELD_SETTER(EsGobJmulticardConnectionPaceSecureMessaging, cryptoHelper_, EsGobJmulticardCryptoHelper *)

/*!
 @brief Tama&ntilde;o de bloque de cifrado AES.
 */
inline jint EsGobJmulticardConnectionPaceSecureMessaging_get_BLOCK_SIZE(void);
#define EsGobJmulticardConnectionPaceSecureMessaging_BLOCK_SIZE 16
J2OBJC_STATIC_FIELD_CONSTANT(EsGobJmulticardConnectionPaceSecureMessaging, BLOCK_SIZE, jint)

__attribute__((unused)) static EsGobJmulticardConnectionPaceDO87 *EsGobJmulticardConnectionPaceSecureMessaging_buildDO87WithByteArray_(EsGobJmulticardConnectionPaceSecureMessaging *self, IOSByteArray *data);

__attribute__((unused)) static EsGobJmulticardConnectionPaceDO8E *EsGobJmulticardConnectionPaceSecureMessaging_buildDO8EWithByteArray_withEsGobJmulticardConnectionPaceDO87_withEsGobJmulticardConnectionPaceDO97_(EsGobJmulticardConnectionPaceSecureMessaging *self, IOSByteArray *header, EsGobJmulticardConnectionPaceDO87 *do87, EsGobJmulticardConnectionPaceDO97 *do97);

__attribute__((unused)) static EsGobJmulticardConnectionPaceDO97 *EsGobJmulticardConnectionPaceSecureMessaging_buildDO97WithInt_(jint le);

__attribute__((unused)) static jbyte EsGobJmulticardConnectionPaceSecureMessaging_getAPDUStructureWithEsGobJmulticardApduCommandApdu_(EsGobJmulticardApduCommandApdu *capdu);

__attribute__((unused)) static void EsGobJmulticardConnectionPaceSecureMessaging_incrementAtIndexWithByteArray_(IOSByteArray *array);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionPaceSecureMessaging_getMacWithByteArray_withByteArray_withByteArray_(EsGobJmulticardConnectionPaceSecureMessaging *self, IOSByteArray *data, IOSByteArray *ssCounter, IOSByteArray *keyBytes);

__attribute__((unused)) static IOSByteArray *EsGobJmulticardConnectionPaceSecureMessaging_addPaddingWithByteArray_(IOSByteArray *data);

#line 1 "/Users/desarrolloabamobile/Downloads/jmulticard-ios/src/main/java/es/gob/jmulticard/connection/pace/SecureMessaging.java"


#line 42
@implementation EsGobJmulticardConnectionPaceSecureMessaging


#line 54
- (instancetype)initWithByteArray:(IOSByteArray *)ksenc
                    withByteArray:(IOSByteArray *)ksmac
                    withByteArray:(IOSByteArray *)initialSSC
  withEsGobJmulticardCryptoHelper:(EsGobJmulticardCryptoHelper *)ch {
  EsGobJmulticardConnectionPaceSecureMessaging_initWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_(self, ksenc, ksmac, initialSSC, ch);
  return self;
}


#line 68
- (EsGobJmulticardApduCommandApdu *)wrapWithEsGobJmulticardApduCommandApdu:(EsGobJmulticardApduCommandApdu *)capdu {
  
#line 70
  jbyte lc = 0;
  EsGobJmulticardConnectionPaceDO97 *do97 = nil;
  EsGobJmulticardConnectionPaceDO87 *do87 = nil;
  
#line 74
  EsGobJmulticardConnectionPaceSecureMessaging_incrementAtIndexWithByteArray_(ssc_);
  
#line 77
  IOSByteArray *header = [IOSByteArray newArrayWithLength:4];
  
#line 80
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_([((EsGobJmulticardApduCommandApdu *) nil_chk(capdu)) getBytes], 0, header, 0, 4);
  
#line 83
  *IOSByteArray_GetRef(header, 0) = (jbyte) (IOSByteArray_Get(header, 0) | (jbyte) (jint) 0x0C);
  
#line 86
  if (EsGobJmulticardConnectionPaceSecureMessaging_getAPDUStructureWithEsGobJmulticardApduCommandApdu_(capdu) == 3 || EsGobJmulticardConnectionPaceSecureMessaging_getAPDUStructureWithEsGobJmulticardApduCommandApdu_(capdu) == 4) {
    do87 = EsGobJmulticardConnectionPaceSecureMessaging_buildDO87WithByteArray_(self, [((IOSByteArray *) nil_chk([capdu getData])) java_clone]);
    lc += ((IOSByteArray *) nil_chk([((EsGobJmulticardConnectionPaceDO87 *) nil_chk(do87)) getEncoded]))->size_;
  }
  
#line 92
  if (EsGobJmulticardConnectionPaceSecureMessaging_getAPDUStructureWithEsGobJmulticardApduCommandApdu_(capdu) == 2 || EsGobJmulticardConnectionPaceSecureMessaging_getAPDUStructureWithEsGobJmulticardApduCommandApdu_(capdu) == 4) {
    do97 = EsGobJmulticardConnectionPaceSecureMessaging_buildDO97WithInt_([((JavaLangInteger *) nil_chk([capdu getLe])) intValue]);
    lc += ((IOSByteArray *) nil_chk([((EsGobJmulticardConnectionPaceDO97 *) nil_chk(do97)) getEncoded]))->size_;
  }
  
#line 98
  EsGobJmulticardConnectionPaceDO8E *do8E = EsGobJmulticardConnectionPaceSecureMessaging_buildDO8EWithByteArray_withEsGobJmulticardConnectionPaceDO87_withEsGobJmulticardConnectionPaceDO97_(self, header, do87, do97);
  lc += ((IOSByteArray *) nil_chk([((EsGobJmulticardConnectionPaceDO8E *) nil_chk(do8E)) getEncoded]))->size_;
  
#line 102
  JavaIoByteArrayOutputStream *bOut = new_JavaIoByteArrayOutputStream_init();
  @try {
    [bOut writeWithByteArray:header];
    [bOut writeWithInt:lc];
    if (do87 != nil) {
      [bOut writeWithByteArray:[do87 getEncoded]];
    }
    if (do97 != nil) {
      [bOut writeWithByteArray:[do97 getEncoded]];
    }
    [bOut writeWithByteArray:[do8E getEncoded]];
    [bOut writeWithInt:0];
  }
  @catch (JavaIoIOException *e) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithJavaLangThrowable_(e);
  }
  
#line 119
  return new_EsGobJmulticardApduCommandApdu_initWithByteArray_([bOut toByteArray]);
}


#line 126
- (EsGobJmulticardApduResponseApdu *)unwrapWithEsGobJmulticardApduResponseApdu:(EsGobJmulticardApduResponseApdu *)responseApduEncrypted {
  
#line 128
  EsGobJmulticardConnectionPaceDO87 *do87 = nil;
  EsGobJmulticardConnectionPaceDO99 *do99 = nil;
  EsGobJmulticardConnectionPaceDO8E *do8E = nil;
  
#line 132
  EsGobJmulticardConnectionPaceSecureMessaging_incrementAtIndexWithByteArray_(ssc_);
  
#line 134
  jint pointer = 0;
  IOSByteArray *responseApduBytes = [((EsGobJmulticardApduResponseApdu *) nil_chk(responseApduEncrypted)) getData];
  IOSByteArray *subArray = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(responseApduBytes))->size_];
  
#line 138
  while (pointer < responseApduBytes->size_) {
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 140
    responseApduBytes,
#line 141
    pointer,
#line 142
    subArray,
#line 143
    0,
#line 144
    responseApduBytes->size_ - pointer);
    
#line 147
    IOSByteArray *encodedBytes;
    @try {
      encodedBytes = [new_EsGobJmulticardAsn1Tlv_initWithByteArray_(subArray) getBytes];
    }
    @catch (EsGobJmulticardAsn1TlvException *e1) {
      @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithNSString_withJavaLangThrowable_(
#line 153
      @"Los datos de la APDU protegida no forman un TLV valido", e1);
    }
    
#line 157
    switch (IOSByteArray_Get(nil_chk(encodedBytes), 0)) {
      case (jbyte) (jint) 0x87:
      do87 = new_EsGobJmulticardConnectionPaceDO87_initPackagePrivateWithByteArray_(encodedBytes);
      break;
      case (jbyte) (jint) 0x99:
      do99 = new_EsGobJmulticardConnectionPaceDO99_initPackagePrivateWithByteArray_(encodedBytes);
      break;
      case (jbyte) (jint) 0x8E:
      do8E = new_EsGobJmulticardConnectionPaceDO8E_initPackagePrivateWithByteArray_(encodedBytes);
      break;
      default:
      EsGobJmulticardJmcLogger_warningWithNSString_(JreStrcat("$$", @"Encontrada estructura desconocida en la APDU protegida: ", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(
#line 169
      encodedBytes, false)));
      
#line 171
      break;
    }
    
#line 174
    pointer += encodedBytes->size_;
  }
  
#line 177
  if (do99 == nil || do8E == nil) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithNSString_(JreStrcat("$$", @"Error desempaquetando el mensaje seguro, DO99 o DO8E no encontrados en la APDU de respuesta: ", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(
#line 180
    responseApduBytes, true)));
  }
  
#line 185
  JavaIoByteArrayOutputStream *bout = new_JavaIoByteArrayOutputStream_init();
  @try {
    if (do87 != nil) {
      [bout writeWithByteArray:[do87 getEncoded]];
    }
    [bout writeWithByteArray:[do99 getEncoded]];
  }
  @catch (JavaIoIOException *e) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithJavaLangThrowable_(e);
  }
  
#line 196
  IOSByteArray *cc;
  @try {
    cc = EsGobJmulticardConnectionPaceSecureMessaging_getMacWithByteArray_withByteArray_withByteArray_(self, [bout toByteArray], ssc_, kmac_);
  }
  @catch (JavaSecurityInvalidKeyException *e1) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithNSString_withJavaLangThrowable_(
#line 202
    @"Error calculando el CMAC", e1);
  }
  @catch (
#line 200
  JavaSecurityNoSuchAlgorithmException *e1) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithNSString_withJavaLangThrowable_(
#line 202
    @"Error calculando el CMAC", e1);
  }
  
#line 206
  IOSByteArray *do8eData = [do8E getData];
  
#line 208
  if (!JavaUtilArrays_equalsWithByteArray_withByteArray_(cc, do8eData)) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithNSString_(JreStrcat("$$$$C", @"Checksum incorrecto (CC Calculado = ", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(
#line 211
    cc, false), @", CC en DO8E = ", EsGobJmulticardHexUtils_hexifyWithByteArray_withBoolean_(
#line 212
    do8eData, false), ')'));
  }
  
#line 217
  IOSByteArray *unwrappedAPDUBytes;
  if (do87 != nil) {
    IOSByteArray *do87Data = [do87 getData];
    IOSByteArray *data;
    @try {
      data = [((EsGobJmulticardCryptoHelper *) nil_chk(cryptoHelper_)) aesDecryptWithByteArray:
#line 223
      do87Data withByteArray:
#line 225
      [cryptoHelper_ aesEncryptWithByteArray:
#line 226
      ssc_ withByteArray:
#line 227
      nil withByteArray:
#line 228
      kenc_ withEsGobJmulticardCryptoHelper_BlockMode:JreLoadEnum(EsGobJmulticardCryptoHelper_BlockMode, ECB) withEsGobJmulticardCryptoHelper_Padding:JreLoadEnum(EsGobJmulticardCryptoHelper_Padding, NOPADDING)] withByteArray:
#line 232
      kenc_ withEsGobJmulticardCryptoHelper_BlockMode:JreLoadEnum(EsGobJmulticardCryptoHelper_BlockMode, CBC) withEsGobJmulticardCryptoHelper_Padding:JreLoadEnum(EsGobJmulticardCryptoHelper_Padding, ISO7816_4PADDING)];
    }
    @catch (
#line 237
    JavaIoIOException *e) {
      @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithJavaLangThrowable_(e);
    }
    
#line 241
    unwrappedAPDUBytes = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(data))->size_ + 2];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, unwrappedAPDUBytes, 0, data->size_);
    IOSByteArray *do99Data = [do99 getData];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(
#line 245
    do99Data,
#line 246
    0,
#line 247
    unwrappedAPDUBytes,
#line 248
    data->size_, ((IOSByteArray *) nil_chk(
#line 249
    do99Data))->size_);
  }
  else {
    
#line 253
    unwrappedAPDUBytes = [((IOSByteArray *) nil_chk([do99 getData])) java_clone];
  }
  
#line 256
  return new_EsGobJmulticardApduResponseApdu_initWithByteArray_(unwrappedAPDUBytes);
}


#line 263
- (EsGobJmulticardConnectionPaceDO87 *)buildDO87WithByteArray:(IOSByteArray *)data {
  return EsGobJmulticardConnectionPaceSecureMessaging_buildDO87WithByteArray_(self, data);
}


#line 287
- (EsGobJmulticardConnectionPaceDO8E *)buildDO8EWithByteArray:(IOSByteArray *)header
                        withEsGobJmulticardConnectionPaceDO87:(EsGobJmulticardConnectionPaceDO87 *)do87
                        withEsGobJmulticardConnectionPaceDO97:(EsGobJmulticardConnectionPaceDO97 *)do97 {
  return EsGobJmulticardConnectionPaceSecureMessaging_buildDO8EWithByteArray_withEsGobJmulticardConnectionPaceDO87_withEsGobJmulticardConnectionPaceDO97_(self, header, do87, do97);
}


#line 323
+ (EsGobJmulticardConnectionPaceDO97 *)buildDO97WithInt:(jint)le {
  return EsGobJmulticardConnectionPaceSecureMessaging_buildDO97WithInt_(le);
}


#line 330
+ (jbyte)getAPDUStructureWithEsGobJmulticardApduCommandApdu:(EsGobJmulticardApduCommandApdu *)capdu {
  return EsGobJmulticardConnectionPaceSecureMessaging_getAPDUStructureWithEsGobJmulticardApduCommandApdu_(capdu);
}


#line 359
+ (void)incrementAtIndexWithByteArray:(IOSByteArray *)array {
  EsGobJmulticardConnectionPaceSecureMessaging_incrementAtIndexWithByteArray_(array);
}


#line 382
- (IOSByteArray *)getMacWithByteArray:(IOSByteArray *)data
                        withByteArray:(IOSByteArray *)ssCounter
                        withByteArray:(IOSByteArray *)keyBytes {
  return EsGobJmulticardConnectionPaceSecureMessaging_getMacWithByteArray_withByteArray_withByteArray_(self, data, ssCounter, keyBytes);
}


#line 399
+ (IOSByteArray *)addPaddingWithByteArray:(IOSByteArray *)data {
  return EsGobJmulticardConnectionPaceSecureMessaging_addPaddingWithByteArray_(data);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "LEsGobJmulticardApduCommandApdu;", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "LEsGobJmulticardApduResponseApdu;", 0x1, 4, 5, 3, -1, -1, -1 },
    { NULL, "LEsGobJmulticardConnectionPaceDO87;", 0x2, 6, 7, 3, -1, -1, -1 },
    { NULL, "LEsGobJmulticardConnectionPaceDO8E;", 0x2, 8, 9, 3, -1, -1, -1 },
    { NULL, "LEsGobJmulticardConnectionPaceDO97;", 0xa, 10, 11, -1, -1, -1, -1 },
    { NULL, "B", 0xa, 12, 2, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 13, 7, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 14, 15, 16, -1, -1, -1 },
    { NULL, "[B", 0xa, 17, 7, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithByteArray:withByteArray:withByteArray:withEsGobJmulticardCryptoHelper:);
  methods[1].selector = @selector(wrapWithEsGobJmulticardApduCommandApdu:);
  methods[2].selector = @selector(unwrapWithEsGobJmulticardApduResponseApdu:);
  methods[3].selector = @selector(buildDO87WithByteArray:);
  methods[4].selector = @selector(buildDO8EWithByteArray:withEsGobJmulticardConnectionPaceDO87:withEsGobJmulticardConnectionPaceDO97:);
  methods[5].selector = @selector(buildDO97WithInt:);
  methods[6].selector = @selector(getAPDUStructureWithEsGobJmulticardApduCommandApdu:);
  methods[7].selector = @selector(incrementAtIndexWithByteArray:);
  methods[8].selector = @selector(getMacWithByteArray:withByteArray:withByteArray:);
  methods[9].selector = @selector(addPaddingWithByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "kenc_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "kmac_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "ssc_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "cryptoHelper_", "LEsGobJmulticardCryptoHelper;", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "BLOCK_SIZE", "I", .constantValue.asInt = EsGobJmulticardConnectionPaceSecureMessaging_BLOCK_SIZE, 0x1a, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "[B[B[BLEsGobJmulticardCryptoHelper;", "wrap", "LEsGobJmulticardApduCommandApdu;", "LEsGobJmulticardConnectionPaceSecureMessagingException;", "unwrap", "LEsGobJmulticardApduResponseApdu;", "buildDO87", "[B", "buildDO8E", "[BLEsGobJmulticardConnectionPaceDO87;LEsGobJmulticardConnectionPaceDO97;", "buildDO97", "I", "getAPDUStructure", "incrementAtIndex", "getMac", "[B[B[B", "LJavaSecurityInvalidKeyException;LJavaSecurityNoSuchAlgorithmException;", "addPadding" };
  static const J2ObjcClassInfo _EsGobJmulticardConnectionPaceSecureMessaging = { "SecureMessaging", "es.gob.jmulticard.connection.pace", ptrTable, methods, fields, 7, 0x11, 10, 5, -1, -1, -1, -1, -1 };
  return &_EsGobJmulticardConnectionPaceSecureMessaging;
}

@end


#line 54
void EsGobJmulticardConnectionPaceSecureMessaging_initWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_(EsGobJmulticardConnectionPaceSecureMessaging *self, IOSByteArray *ksenc, IOSByteArray *ksmac, IOSByteArray *initialSSC, EsGobJmulticardCryptoHelper *ch) {
  NSObject_init(self);
  
#line 58
  self->cryptoHelper_ = ch;
  self->kenc_ = [((IOSByteArray *) nil_chk(ksenc)) java_clone];
  self->kmac_ = [((IOSByteArray *) nil_chk(ksmac)) java_clone];
  self->ssc_ = [((IOSByteArray *) nil_chk(initialSSC)) java_clone];
}


#line 54
EsGobJmulticardConnectionPaceSecureMessaging *new_EsGobJmulticardConnectionPaceSecureMessaging_initWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_(IOSByteArray *ksenc, IOSByteArray *ksmac, IOSByteArray *initialSSC, EsGobJmulticardCryptoHelper *ch) {
  J2OBJC_NEW_IMPL(EsGobJmulticardConnectionPaceSecureMessaging, initWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_, ksenc, ksmac, initialSSC, ch)
}


#line 54
EsGobJmulticardConnectionPaceSecureMessaging *create_EsGobJmulticardConnectionPaceSecureMessaging_initWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_(IOSByteArray *ksenc, IOSByteArray *ksmac, IOSByteArray *initialSSC, EsGobJmulticardCryptoHelper *ch) {
  J2OBJC_CREATE_IMPL(EsGobJmulticardConnectionPaceSecureMessaging, initWithByteArray_withByteArray_withByteArray_withEsGobJmulticardCryptoHelper_, ksenc, ksmac, initialSSC, ch)
}


#line 263
EsGobJmulticardConnectionPaceDO87 *EsGobJmulticardConnectionPaceSecureMessaging_buildDO87WithByteArray_(EsGobJmulticardConnectionPaceSecureMessaging *self, IOSByteArray *data) {
  IOSByteArray *encData;
  @try {
    encData = [((EsGobJmulticardCryptoHelper *) nil_chk(self->cryptoHelper_)) aesEncryptWithByteArray:
#line 267
    data withByteArray:
#line 269
    [self->cryptoHelper_ aesEncryptWithByteArray:self->ssc_ withByteArray:
#line 271
    nil withByteArray:self->kenc_ withEsGobJmulticardCryptoHelper_BlockMode:JreLoadEnum(EsGobJmulticardCryptoHelper_BlockMode, ECB) withEsGobJmulticardCryptoHelper_Padding:JreLoadEnum(EsGobJmulticardCryptoHelper_Padding, NOPADDING)] withByteArray:self->kenc_ withEsGobJmulticardCryptoHelper_BlockMode:JreLoadEnum(EsGobJmulticardCryptoHelper_BlockMode, CBC) withEsGobJmulticardCryptoHelper_Padding:JreLoadEnum(EsGobJmulticardCryptoHelper_Padding, ISO7816_4PADDING)];
  }
  @catch (
#line 281
  JavaIoIOException *e) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithJavaLangThrowable_(e);
  }
  return new_EsGobJmulticardConnectionPaceDO87_initPackagePrivateWithByteArray_(encData);
}


#line 287
EsGobJmulticardConnectionPaceDO8E *EsGobJmulticardConnectionPaceSecureMessaging_buildDO8EWithByteArray_withEsGobJmulticardConnectionPaceDO87_withEsGobJmulticardConnectionPaceDO97_(EsGobJmulticardConnectionPaceSecureMessaging *self, IOSByteArray *header, EsGobJmulticardConnectionPaceDO87 *do87, EsGobJmulticardConnectionPaceDO97 *do97) {
  
#line 289
  JavaIoByteArrayOutputStream *m = new_JavaIoByteArrayOutputStream_init();
  
#line 294
  @try {
    if (do87 != nil || do97 != nil) {
      [m writeWithByteArray:EsGobJmulticardConnectionPaceSecureMessaging_addPaddingWithByteArray_(header)];
    }
    else {
      [m writeWithByteArray:header];
    }
    
#line 302
    if (do87 != nil) {
      [m writeWithByteArray:[do87 getEncoded]];
    }
    if (do97 != nil) {
      [m writeWithByteArray:[do97 getEncoded]];
    }
  }
  @catch (JavaIoIOException *e) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithJavaLangThrowable_(e);
  }
  
#line 313
  @try {
    return new_EsGobJmulticardConnectionPaceDO8E_initPackagePrivateWithByteArray_(EsGobJmulticardConnectionPaceSecureMessaging_getMacWithByteArray_withByteArray_withByteArray_(self, [m toByteArray], self->ssc_, self->kmac_));
  }
  @catch (JavaSecurityInvalidKeyException *e) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithNSString_withJavaLangThrowable_(
#line 318
    @"Error calculando el CMAC", e);
  }
  @catch (
#line 316
  JavaSecurityNoSuchAlgorithmException *e) {
    @throw new_EsGobJmulticardConnectionPaceSecureMessagingException_initWithNSString_withJavaLangThrowable_(
#line 318
    @"Error calculando el CMAC", e);
  }
}


#line 323
EsGobJmulticardConnectionPaceDO97 *EsGobJmulticardConnectionPaceSecureMessaging_buildDO97WithInt_(jint le) {
  EsGobJmulticardConnectionPaceSecureMessaging_initialize();
  
#line 324
  return new_EsGobJmulticardConnectionPaceDO97_initPackagePrivateWithInt_(le);
}

jbyte EsGobJmulticardConnectionPaceSecureMessaging_getAPDUStructureWithEsGobJmulticardApduCommandApdu_(EsGobJmulticardApduCommandApdu *capdu) {
  EsGobJmulticardConnectionPaceSecureMessaging_initialize();
  
#line 331
  IOSByteArray *cardcmd = [((EsGobJmulticardApduCommandApdu *) nil_chk(capdu)) getBytes];
  
#line 333
  if (((IOSByteArray *) nil_chk(cardcmd))->size_ == 4) {
    return 1;
  }
  if (cardcmd->size_ == 5) {
    return 2;
  }
  if (cardcmd->size_ == 5 + (IOSByteArray_Get(cardcmd, 4) & (jint) 0xff) && IOSByteArray_Get(cardcmd, 4) != 0) {
    return 3;
  }
  if (cardcmd->size_ == 6 + (IOSByteArray_Get(cardcmd, 4) & (jint) 0xff) && IOSByteArray_Get(cardcmd, 4) != 0) {
    return 4;
  }
  if (cardcmd->size_ == 7 && IOSByteArray_Get(cardcmd, 4) == 0) {
    return 5;
  }
  if (cardcmd->size_ == 7 + (IOSByteArray_Get(cardcmd, 5) & (jint) 0xff) * 256 + (IOSByteArray_Get(cardcmd, 6) & (jint) 0xff) &&
#line 349
  IOSByteArray_Get(cardcmd, 4) == 0 && (IOSByteArray_Get(cardcmd, 5) != 0 || IOSByteArray_Get(cardcmd, 6) != 0)) {
    return 6;
  }
  if (cardcmd->size_ == 9 + (IOSByteArray_Get(cardcmd, 5) & (jint) 0xff) * 256 + (IOSByteArray_Get(cardcmd, 6) & (jint) 0xff) &&
#line 353
  IOSByteArray_Get(cardcmd, 4) == 0 && (IOSByteArray_Get(cardcmd, 5) != 0 || IOSByteArray_Get(cardcmd, 6) != 0)) {
    return 7;
  }
  return 0;
}


#line 359
void EsGobJmulticardConnectionPaceSecureMessaging_incrementAtIndexWithByteArray_(IOSByteArray *array) {
  EsGobJmulticardConnectionPaceSecureMessaging_initialize();
  
#line 360
  IOSByteArray *result = [((JavaMathBigInteger *) nil_chk([new_JavaMathBigInteger_initWithInt_withByteArray_(1, array) addWithJavaMathBigInteger:JreLoadStatic(JavaMathBigInteger, ONE)])) toByteArray];
  if (((IOSByteArray *) nil_chk(result))->size_ > ((IOSByteArray *) nil_chk(array))->size_) {
    JavaUtilArrays_fillWithByteArray_withByte_(array, (jbyte) 0);
  }
  else {
    jint lengthA = array->size_;
    jint lengthR = result->size_;
    for (jint i = 0; i < lengthR; i++) {
      *IOSByteArray_GetRef(array, lengthA - 1 - i) = IOSByteArray_Get(result, lengthR - 1 - i);
    }
  }
}


#line 382
IOSByteArray *EsGobJmulticardConnectionPaceSecureMessaging_getMacWithByteArray_withByteArray_withByteArray_(EsGobJmulticardConnectionPaceSecureMessaging *self, IOSByteArray *data, IOSByteArray *ssCounter, IOSByteArray *keyBytes) {
  
#line 386
  IOSByteArray *n = [IOSByteArray newArrayWithLength:((IOSByteArray *) nil_chk(ssCounter))->size_ + ((IOSByteArray *) nil_chk(data))->size_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ssCounter, 0, n, 0, ssCounter->size_);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, n, ssCounter->size_, data->size_);
  return [((EsGobJmulticardCryptoHelper *) nil_chk(self->cryptoHelper_)) doAesCmacWithByteArray:EsGobJmulticardConnectionPaceSecureMessaging_addPaddingWithByteArray_(n) withByteArray:keyBytes];
}


#line 399
IOSByteArray *EsGobJmulticardConnectionPaceSecureMessaging_addPaddingWithByteArray_(IOSByteArray *data) {
  EsGobJmulticardConnectionPaceSecureMessaging_initialize();
  
#line 400
  jint len = ((IOSByteArray *) nil_chk(data))->size_;
  jint nLen = (JreIntDiv(len, EsGobJmulticardConnectionPaceSecureMessaging_BLOCK_SIZE) + 1) * EsGobJmulticardConnectionPaceSecureMessaging_BLOCK_SIZE;
  IOSByteArray *in = [IOSByteArray newArrayWithLength:nLen];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(data, 0, in, 0, data->size_);
  
#line 405
  *IOSByteArray_GetRef(in, len) = (jbyte) (jint) 0x80;
  len++;
  while (len < in->size_) {
    *IOSByteArray_GetRef(in, len) = (jbyte) 0;
    len++;
  }
  return in;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobJmulticardConnectionPaceSecureMessaging)
