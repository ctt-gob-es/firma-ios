//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Documents/JAVA/pades-ios/src/main/java/harmony/java/awt/Polygon.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "harmony/java/awt/AWTRectangle.h"
#include "harmony/java/awt/Point.h"
#include "harmony/java/awt/Polygon.h"
#include "harmony/java/awt/geom/AffineTransform.h"
#include "harmony/java/awt/geom/PathIterator.h"
#include "harmony/java/awt/geom/Point2D.h"
#include "harmony/java/awt/geom/Rectangle2D.h"
#include "java/lang/Deprecated.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/Math.h"
#include "java/lang/NegativeArraySizeException.h"
#include "java/lang/System.h"
#include "java/lang/annotation/Annotation.h"
#include "java/util/NoSuchElementException.h"
#include "org/apache/harmony/awt/gl/Crossing.h"
#include "org/apache/harmony/awt/internal/nls/Messages.h"

#if !__has_feature(objc_arc)
#error "harmony/java/awt/Polygon must be compiled with ARC (-fobjc-arc)"
#endif

inline jlong HarmonyJavaAwtPolygon_get_serialVersionUID(void);
#define HarmonyJavaAwtPolygon_serialVersionUID -6460061437900069969LL
J2OBJC_STATIC_FIELD_CONSTANT(HarmonyJavaAwtPolygon, serialVersionUID, jlong)

/*!
 @brief The points buffer capacity
 */
inline jint HarmonyJavaAwtPolygon_get_BUFFER_CAPACITY(void);
#define HarmonyJavaAwtPolygon_BUFFER_CAPACITY 4
J2OBJC_STATIC_FIELD_CONSTANT(HarmonyJavaAwtPolygon, BUFFER_CAPACITY, jint)

__attribute__((unused)) static IOSObjectArray *HarmonyJavaAwtPolygon__Annotations$0(void);

__attribute__((unused)) static IOSObjectArray *HarmonyJavaAwtPolygon__Annotations$1(void);

#line 1 "/Users/desarrolloabamobile/Documents/JAVA/pades-ios/src/main/java/harmony/java/awt/Polygon.java"


#line 36
@implementation HarmonyJavaAwtPolygon

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 132
- (instancetype)init {
  HarmonyJavaAwtPolygon_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 137
- (instancetype)initWithIntArray:(IOSIntArray *)xpoints
                    withIntArray:(IOSIntArray *)ypoints
                         withInt:(jint)npoints {
  HarmonyJavaAwtPolygon_initWithIntArray_withIntArray_withInt_(self, xpoints, ypoints, npoints);
  return self;
}


#line 153
- (void)reset {
  npoints_ = 0;
  bounds_ = nil;
}

- (void)invalidate {
  bounds_ = nil;
}

- (void)addPointWithInt:(jint)px
                withInt:(jint)py {
  
#line 163
  if (npoints_ == ((IOSIntArray *) nil_chk(xpoints_))->size_) {
    IOSIntArray *tmp;
    
#line 166
    tmp = [IOSIntArray newArrayWithLength:xpoints_->size_ + HarmonyJavaAwtPolygon_BUFFER_CAPACITY];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(xpoints_, 0, tmp, 0, xpoints_->size_);
    xpoints_ = tmp;
    
#line 170
    tmp = [IOSIntArray newArrayWithLength:((IOSIntArray *) nil_chk(ypoints_))->size_ + HarmonyJavaAwtPolygon_BUFFER_CAPACITY];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ypoints_, 0, tmp, 0, ypoints_->size_);
    ypoints_ = tmp;
  }
  
#line 175
  *IOSIntArray_GetRef(nil_chk(xpoints_), npoints_) = px;
  *IOSIntArray_GetRef(nil_chk(ypoints_), npoints_) = py;
  npoints_++;
  
#line 179
  if (bounds_ != nil) {
    [bounds_ setFrameFromDiagonalWithDouble:JavaLangMath_minWithDouble_withDouble_([bounds_ getMinX], px) withDouble:JavaLangMath_minWithDouble_withDouble_([((HarmonyJavaAwtAWTRectangle *) nil_chk(bounds_)) getMinY], py) withDouble:JavaLangMath_maxWithDouble_withDouble_([((HarmonyJavaAwtAWTRectangle *) nil_chk(bounds_)) getMaxX],
#line 181
    px) withDouble:JavaLangMath_maxWithDouble_withDouble_([((HarmonyJavaAwtAWTRectangle *) nil_chk(bounds_)) getMaxY], py)];
  }
}


#line 185
- (HarmonyJavaAwtAWTRectangle *)getBounds {
  if (bounds_ != nil) {
    return bounds_;
  }
  if (npoints_ == 0) {
    return new_HarmonyJavaAwtAWTRectangle_init();
  }
  
#line 193
  jint bx1 = IOSIntArray_Get(nil_chk(xpoints_), 0);
  jint by1 = IOSIntArray_Get(nil_chk(ypoints_), 0);
  jint bx2 = bx1;
  jint by2 = by1;
  
#line 198
  for (jint i = 1; i < npoints_; i++) {
    jint x = IOSIntArray_Get(xpoints_, i);
    jint y = IOSIntArray_Get(ypoints_, i);
    if (x < bx1) {
      bx1 = x;
    }
    else
#line 203
    if (x > bx2) {
      bx2 = x;
    }
    if (y < by1) {
      by1 = y;
    }
    else
#line 208
    if (y > by2) {
      by2 = y;
    }
  }
  
#line 213
  return bounds_ = new_HarmonyJavaAwtAWTRectangle_initWithInt_withInt_withInt_withInt_(bx1, by1, bx2 - bx1, by2 - by1);
}


#line 220
- (HarmonyJavaAwtAWTRectangle *)getBoundingBox {
  
#line 222
  return [self getBounds];
}


#line 225
- (HarmonyJavaAwtGeomRectangle2D *)getBounds2D {
  return [((HarmonyJavaAwtAWTRectangle *) nil_chk([self getBounds])) getBounds2D];
}

- (void)translateWithInt:(jint)mx
                 withInt:(jint)my {
  
#line 230
  for (jint i = 0; i < npoints_; i++) {
    *IOSIntArray_GetRef(nil_chk(xpoints_), i) += mx;
    *IOSIntArray_GetRef(nil_chk(ypoints_), i) += my;
  }
  if (bounds_ != nil) {
    [bounds_ translateWithInt:mx withInt:my];
  }
}


#line 245
- (jboolean)insideWithInt:(jint)x
                  withInt:(jint)y {
  return [self containsWithDouble:(jdouble) x withDouble:(jdouble) y];
}

- (jboolean)containsWithInt:(jint)x
                    withInt:(jint)y {
  
#line 251
  return [self containsWithDouble:(jdouble) x withDouble:(jdouble) y];
}


#line 254
- (jboolean)containsWithDouble:(jdouble)x
                    withDouble:(jdouble)y {
  
#line 255
  return OrgApacheHarmonyAwtGlCrossing_isInsideEvenOddWithInt_(OrgApacheHarmonyAwtGlCrossing_crossShapeWithHarmonyJavaAwtShape_withDouble_withDouble_(self, x, y));
}


#line 258
- (jboolean)containsWithDouble:(jdouble)x
                    withDouble:(jdouble)y
                    withDouble:(jdouble)width
                    withDouble:(jdouble)height {
  
#line 259
  jint cross = OrgApacheHarmonyAwtGlCrossing_intersectShapeWithHarmonyJavaAwtShape_withDouble_withDouble_withDouble_withDouble_(self, x, y, width, height);
  return cross != OrgApacheHarmonyAwtGlCrossing_CROSSING && OrgApacheHarmonyAwtGlCrossing_isInsideEvenOddWithInt_(cross);
}


#line 263
- (jboolean)intersectsWithDouble:(jdouble)x
                      withDouble:(jdouble)y
                      withDouble:(jdouble)width
                      withDouble:(jdouble)height {
  
#line 264
  jint cross = OrgApacheHarmonyAwtGlCrossing_intersectShapeWithHarmonyJavaAwtShape_withDouble_withDouble_withDouble_withDouble_(self, x, y, width, height);
  return cross == OrgApacheHarmonyAwtGlCrossing_CROSSING || OrgApacheHarmonyAwtGlCrossing_isInsideEvenOddWithInt_(cross);
}


#line 268
- (jboolean)containsWithHarmonyJavaAwtGeomRectangle2D:(HarmonyJavaAwtGeomRectangle2D *)rect {
  return [self containsWithDouble:[((HarmonyJavaAwtGeomRectangle2D *) nil_chk(rect)) getX] withDouble:[rect getY] withDouble:[rect getWidth] withDouble:[rect getHeight]];
}

- (jboolean)containsWithHarmonyJavaAwtPoint:(HarmonyJavaAwtPoint *)point {
  return [self containsWithDouble:[((HarmonyJavaAwtPoint *) nil_chk(point)) getX] withDouble:[point getY]];
}

- (jboolean)containsWithHarmonyJavaAwtGeomPoint2D:(HarmonyJavaAwtGeomPoint2D *)point {
  return [self containsWithDouble:[((HarmonyJavaAwtGeomPoint2D *) nil_chk(point)) getX] withDouble:[point getY]];
}

- (jboolean)intersectsWithHarmonyJavaAwtGeomRectangle2D:(HarmonyJavaAwtGeomRectangle2D *)rect {
  return [self intersectsWithDouble:[((HarmonyJavaAwtGeomRectangle2D *) nil_chk(rect)) getX] withDouble:[rect getY] withDouble:[rect getWidth] withDouble:[rect getHeight]];
}

- (id<HarmonyJavaAwtGeomPathIterator>)getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t {
  return new_HarmonyJavaAwtPolygon_Iterator_initWithHarmonyJavaAwtPolygon_withHarmonyJavaAwtGeomAffineTransform_withHarmonyJavaAwtPolygon_(self, t, self);
}

- (id<HarmonyJavaAwtGeomPathIterator>)getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t
                                                                                withDouble:(jdouble)flatness {
  
#line 289
  return new_HarmonyJavaAwtPolygon_Iterator_initWithHarmonyJavaAwtPolygon_withHarmonyJavaAwtGeomAffineTransform_withHarmonyJavaAwtPolygon_(self, t, self);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtAWTRectangle;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtAWTRectangle;", 0x1, -1, -1, -1, -1, 3, -1 },
    { NULL, "LHarmonyJavaAwtGeomRectangle2D;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 4, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 5, 2, -1, -1, 6, -1 },
    { NULL, "Z", 0x1, 7, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 7, 9, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 10, 9, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 7, 11, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 7, 12, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 7, 13, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomPathIterator;", 0x1, 14, 15, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomPathIterator;", 0x1, 14, 16, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithIntArray:withIntArray:withInt:);
  methods[2].selector = @selector(reset);
  methods[3].selector = @selector(invalidate);
  methods[4].selector = @selector(addPointWithInt:withInt:);
  methods[5].selector = @selector(getBounds);
  methods[6].selector = @selector(getBoundingBox);
  methods[7].selector = @selector(getBounds2D);
  methods[8].selector = @selector(translateWithInt:withInt:);
  methods[9].selector = @selector(insideWithInt:withInt:);
  methods[10].selector = @selector(containsWithInt:withInt:);
  methods[11].selector = @selector(containsWithDouble:withDouble:);
  methods[12].selector = @selector(containsWithDouble:withDouble:withDouble:withDouble:);
  methods[13].selector = @selector(intersectsWithDouble:withDouble:withDouble:withDouble:);
  methods[14].selector = @selector(containsWithHarmonyJavaAwtGeomRectangle2D:);
  methods[15].selector = @selector(containsWithHarmonyJavaAwtPoint:);
  methods[16].selector = @selector(containsWithHarmonyJavaAwtGeomPoint2D:);
  methods[17].selector = @selector(intersectsWithHarmonyJavaAwtGeomRectangle2D:);
  methods[18].selector = @selector(getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:);
  methods[19].selector = @selector(getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:withDouble:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID", "J", .constantValue.asLong = HarmonyJavaAwtPolygon_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "BUFFER_CAPACITY", "I", .constantValue.asInt = HarmonyJavaAwtPolygon_BUFFER_CAPACITY, 0x1a, -1, -1, -1, -1 },
    { "npoints_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "xpoints_", "[I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "ypoints_", "[I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "bounds_", "LHarmonyJavaAwtAWTRectangle;", .constantValue.asLong = 0, 0x4, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "[I[II", "addPoint", "II", (void *)&HarmonyJavaAwtPolygon__Annotations$0, "translate", "inside", (void *)&HarmonyJavaAwtPolygon__Annotations$1, "contains", "DD", "DDDD", "intersects", "LHarmonyJavaAwtGeomRectangle2D;", "LHarmonyJavaAwtPoint;", "LHarmonyJavaAwtGeomPoint2D;", "getPathIterator", "LHarmonyJavaAwtGeomAffineTransform;", "LHarmonyJavaAwtGeomAffineTransform;D", "LHarmonyJavaAwtPolygon_Iterator;" };
  static const J2ObjcClassInfo _HarmonyJavaAwtPolygon = { "Polygon", "harmony.java.awt", ptrTable, methods, fields, 7, 0x1, 20, 6, -1, 17, -1, -1, -1 };
  return &_HarmonyJavaAwtPolygon;
}

@end


#line 132
void HarmonyJavaAwtPolygon_init(HarmonyJavaAwtPolygon *self) {
  NSObject_init(self);
  
#line 133
  self->xpoints_ = [IOSIntArray newArrayWithLength:HarmonyJavaAwtPolygon_BUFFER_CAPACITY];
  self->ypoints_ = [IOSIntArray newArrayWithLength:HarmonyJavaAwtPolygon_BUFFER_CAPACITY];
}


#line 132
HarmonyJavaAwtPolygon *new_HarmonyJavaAwtPolygon_init() {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtPolygon, init)
}


#line 132
HarmonyJavaAwtPolygon *create_HarmonyJavaAwtPolygon_init() {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtPolygon, init)
}


#line 137
void HarmonyJavaAwtPolygon_initWithIntArray_withIntArray_withInt_(HarmonyJavaAwtPolygon *self, IOSIntArray *xpoints, IOSIntArray *ypoints, jint npoints) {
  NSObject_init(self);
  
#line 138
  if (npoints > ((IOSIntArray *) nil_chk(xpoints))->size_ || npoints > ((IOSIntArray *) nil_chk(ypoints))->size_) {
    
#line 140
    @throw new_JavaLangIndexOutOfBoundsException_initWithNSString_(OrgApacheHarmonyAwtInternalNlsMessages_getStringWithNSString_(@"awt.111"));
  }
  if (npoints < 0) {
    
#line 144
    @throw new_JavaLangNegativeArraySizeException_initWithNSString_(OrgApacheHarmonyAwtInternalNlsMessages_getStringWithNSString_(@"awt.112"));
  }
  self->npoints_ = npoints;
  self->xpoints_ = [IOSIntArray newArrayWithLength:npoints];
  self->ypoints_ = [IOSIntArray newArrayWithLength:npoints];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(xpoints, 0, self->xpoints_, 0, npoints);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(ypoints, 0, self->ypoints_, 0, npoints);
}


#line 137
HarmonyJavaAwtPolygon *new_HarmonyJavaAwtPolygon_initWithIntArray_withIntArray_withInt_(IOSIntArray *xpoints, IOSIntArray *ypoints, jint npoints) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtPolygon, initWithIntArray_withIntArray_withInt_, xpoints, ypoints, npoints)
}


#line 137
HarmonyJavaAwtPolygon *create_HarmonyJavaAwtPolygon_initWithIntArray_withIntArray_withInt_(IOSIntArray *xpoints, IOSIntArray *ypoints, jint npoints) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtPolygon, initWithIntArray_withIntArray_withInt_, xpoints, ypoints, npoints)
}

IOSObjectArray *HarmonyJavaAwtPolygon__Annotations$0() {
  return [IOSObjectArray newArrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

IOSObjectArray *HarmonyJavaAwtPolygon__Annotations$1() {
  return [IOSObjectArray newArrayWithObjects:(id[]){ create_JavaLangDeprecated() } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(HarmonyJavaAwtPolygon)

#line 1 "/Users/desarrolloabamobile/Documents/JAVA/pades-ios/src/main/java/harmony/java/awt/Polygon.java"


#line 53
@implementation HarmonyJavaAwtPolygon_Iterator


#line 79
- (instancetype)initWithHarmonyJavaAwtPolygon:(HarmonyJavaAwtPolygon *)outer$
        withHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)at
                    withHarmonyJavaAwtPolygon:(HarmonyJavaAwtPolygon *)p {
  HarmonyJavaAwtPolygon_Iterator_initWithHarmonyJavaAwtPolygon_withHarmonyJavaAwtGeomAffineTransform_withHarmonyJavaAwtPolygon_(self, outer$, at, p);
  return self;
}


#line 87
- (jint)getWindingRule {
  return HarmonyJavaAwtGeomPathIterator_WIND_EVEN_ODD;
}

- (jboolean)isDone {
  return index_ > ((HarmonyJavaAwtPolygon *) nil_chk(p_))->npoints_;
}

- (void)next {
  index_++;
}

- (jint)currentSegmentWithDoubleArray:(IOSDoubleArray *)coords {
  if ([self isDone]) {
    
#line 102
    @throw new_JavaUtilNoSuchElementException_initWithNSString_(OrgApacheHarmonyAwtInternalNlsMessages_getStringWithNSString_(@"awt.110"));
  }
  if (index_ == ((HarmonyJavaAwtPolygon *) nil_chk(p_))->npoints_) {
    return HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
  }
  *IOSDoubleArray_GetRef(nil_chk(coords), 0) = IOSIntArray_Get(nil_chk(p_->xpoints_), index_);
  *IOSDoubleArray_GetRef(coords, 1) = IOSIntArray_Get(nil_chk(p_->ypoints_), index_);
  if (t_ != nil) {
    [t_ transformWithDoubleArray:coords withInt:0 withDoubleArray:coords withInt:0 withInt:1];
  }
  return index_ == 0 ? HarmonyJavaAwtGeomPathIterator_SEG_MOVETO : HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
}


#line 115
- (jint)currentSegmentWithFloatArray:(IOSFloatArray *)coords {
  if ([self isDone]) {
    
#line 118
    @throw new_JavaUtilNoSuchElementException_initWithNSString_(OrgApacheHarmonyAwtInternalNlsMessages_getStringWithNSString_(@"awt.110"));
  }
  if (index_ == ((HarmonyJavaAwtPolygon *) nil_chk(p_))->npoints_) {
    return HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
  }
  *IOSFloatArray_GetRef(nil_chk(coords), 0) = IOSIntArray_Get(nil_chk(p_->xpoints_), index_);
  *IOSFloatArray_GetRef(coords, 1) = IOSIntArray_Get(nil_chk(p_->ypoints_), index_);
  if (t_ != nil) {
    [t_ transformWithFloatArray:coords withInt:0 withFloatArray:coords withInt:0 withInt:1];
  }
  return index_ == 0 ? HarmonyJavaAwtGeomPathIterator_SEG_MOVETO : HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 1, 3, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithHarmonyJavaAwtPolygon:withHarmonyJavaAwtGeomAffineTransform:withHarmonyJavaAwtPolygon:);
  methods[1].selector = @selector(getWindingRule);
  methods[2].selector = @selector(isDone);
  methods[3].selector = @selector(next);
  methods[4].selector = @selector(currentSegmentWithDoubleArray:);
  methods[5].selector = @selector(currentSegmentWithFloatArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "p_", "LHarmonyJavaAwtPolygon;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "t_", "LHarmonyJavaAwtGeomAffineTransform;", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
    { "index_", "I", .constantValue.asLong = 0, 0x1, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LHarmonyJavaAwtPolygon;LHarmonyJavaAwtGeomAffineTransform;LHarmonyJavaAwtPolygon;", "currentSegment", "[D", "[F", "LHarmonyJavaAwtPolygon;" };
  static const J2ObjcClassInfo _HarmonyJavaAwtPolygon_Iterator = { "Iterator", "harmony.java.awt", ptrTable, methods, fields, 7, 0x0, 6, 3, 4, -1, -1, -1, -1 };
  return &_HarmonyJavaAwtPolygon_Iterator;
}

@end


#line 79
void HarmonyJavaAwtPolygon_Iterator_initWithHarmonyJavaAwtPolygon_withHarmonyJavaAwtGeomAffineTransform_withHarmonyJavaAwtPolygon_(HarmonyJavaAwtPolygon_Iterator *self, HarmonyJavaAwtPolygon *outer$, HarmonyJavaAwtGeomAffineTransform *at, HarmonyJavaAwtPolygon *p) {
  NSObject_init(self);
  
#line 80
  self->p_ = p;
  self->t_ = at;
  if (((HarmonyJavaAwtPolygon *) nil_chk(p))->npoints_ == 0) {
    self->index_ = 1;
  }
}


#line 79
HarmonyJavaAwtPolygon_Iterator *new_HarmonyJavaAwtPolygon_Iterator_initWithHarmonyJavaAwtPolygon_withHarmonyJavaAwtGeomAffineTransform_withHarmonyJavaAwtPolygon_(HarmonyJavaAwtPolygon *outer$, HarmonyJavaAwtGeomAffineTransform *at, HarmonyJavaAwtPolygon *p) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtPolygon_Iterator, initWithHarmonyJavaAwtPolygon_withHarmonyJavaAwtGeomAffineTransform_withHarmonyJavaAwtPolygon_, outer$, at, p)
}


#line 79
HarmonyJavaAwtPolygon_Iterator *create_HarmonyJavaAwtPolygon_Iterator_initWithHarmonyJavaAwtPolygon_withHarmonyJavaAwtGeomAffineTransform_withHarmonyJavaAwtPolygon_(HarmonyJavaAwtPolygon *outer$, HarmonyJavaAwtGeomAffineTransform *at, HarmonyJavaAwtPolygon *p) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtPolygon_Iterator, initWithHarmonyJavaAwtPolygon_withHarmonyJavaAwtGeomAffineTransform_withHarmonyJavaAwtPolygon_, outer$, at, p)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(HarmonyJavaAwtPolygon_Iterator)
