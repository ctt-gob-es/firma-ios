//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/harmony/java/awt/geom/Area.java
//

#include "AWTRectangle.h"
#include "AffineTransform.h"
#include "Area.h"
#include "Crossing.h"
#include "CrossingHelper.h"
#include "CurveCrossingHelper.h"
#include "FlatteningPathIterator.h"
#include "GeometryUtil.h"
#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "IntersectPoint.h"
#include "J2ObjC_source.h"
#include "Messages.h"
#include "PathIterator.h"
#include "Point2D.h"
#include "Rectangle2D.h"
#include "Shape.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/NoSuchElementException.h"

#if !__has_feature(objc_arc)
#error "Area must be compiled with ARC (-fobjc-arc)"
#endif

@interface HarmonyJavaAwtGeomArea () {
 @public
  /*!
   @brief the coordinates array of the shape vertices
   */
  IOSDoubleArray *coords_;
  /*!
   @brief the coordinates quantity
   */
  jint coordsSize_;
  /*!
   @brief the rules array for the drawing of the shape edges
   */
  IOSIntArray *rules_;
  /*!
   @brief the rules quantity
   */
  jint rulesSize_;
  /*!
   @brief offsets[i] - index in array of coords and i - index in array of rules
   */
  IOSIntArray *offsets_;
  /*!
   @brief the quantity of MOVETO rule occurences
   */
  jint moveToCount_;
  /*!
   @brief true if the shape is polygon
   */
  jboolean isPolygonal_;
}

- (void)addCurvePolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area;

- (void)addPolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area;

- (void)intersectCurvePolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area;

- (void)intersectPolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area;

- (void)subtractCurvePolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area;

- (void)subtractPolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area;

- (ComIntersectPoint *)getNextIntersectPointWithComIntersectPointArray:(IOSObjectArray *)iPoints
                                                 withComIntersectPoint:(ComIntersectPoint *)isectPoint
                                                           withBoolean:(jboolean)isCurrentArea;

- (ComIntersectPoint *)getPrevIntersectPointWithComIntersectPointArray:(IOSObjectArray *)iPoints
                                                 withComIntersectPoint:(ComIntersectPoint *)isectPoint
                                                           withBoolean:(jboolean)isCurrentArea;

- (jint)includeCoordsAndRulesWithInt:(jint)offset
                             withInt:(jint)length
                        withIntArray:(IOSIntArray *)rules
                        withIntArray:(IOSIntArray *)offsets
                        withIntArray:(IOSIntArray *)resultRules
                        withIntArray:(IOSIntArray *)resultOffsets
                     withDoubleArray:(IOSDoubleArray *)resultCoords
                     withDoubleArray:(IOSDoubleArray *)coords
                             withInt:(jint)resultRulesPos
                             withInt:(jint)resultCoordPos
               withComIntersectPoint:(ComIntersectPoint *)point
                         withBoolean:(jboolean)isCurrentArea
                         withBoolean:(jboolean)way
                             withInt:(jint)operation;

+ (IOSDoubleArray *)adjustSizeWithDoubleArray:(IOSDoubleArray *)array
                                      withInt:(jint)newSize;

+ (IOSIntArray *)adjustSizeWithIntArray:(IOSIntArray *)array
                                withInt:(jint)newSize;

- (void)copy__WithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)src
              withHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)dst OBJC_METHOD_FAMILY_NONE;

- (jint)containsExactWithDouble:(jdouble)x
                     withDouble:(jdouble)y;

- (void)reverseCopyWithDoubleArray:(IOSDoubleArray *)coords;

- (jdouble)getAreaBoundsSquare;

- (jboolean)isVertexWithDouble:(jdouble)x
                    withDouble:(jdouble)y;

@end

J2OBJC_FIELD_SETTER(HarmonyJavaAwtGeomArea, coords_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(HarmonyJavaAwtGeomArea, rules_, IOSIntArray *)
J2OBJC_FIELD_SETTER(HarmonyJavaAwtGeomArea, offsets_, IOSIntArray *)

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_addCurvePolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area);

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_addPolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area);

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_intersectCurvePolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area);

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_intersectPolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area);

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_subtractCurvePolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area);

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_subtractPolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area);

__attribute__((unused)) static ComIntersectPoint *HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(HarmonyJavaAwtGeomArea *self, IOSObjectArray *iPoints, ComIntersectPoint *isectPoint, jboolean isCurrentArea);

__attribute__((unused)) static ComIntersectPoint *HarmonyJavaAwtGeomArea_getPrevIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(HarmonyJavaAwtGeomArea *self, IOSObjectArray *iPoints, ComIntersectPoint *isectPoint, jboolean isCurrentArea);

__attribute__((unused)) static jint HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(HarmonyJavaAwtGeomArea *self, jint offset, jint length, IOSIntArray *rules, IOSIntArray *offsets, IOSIntArray *resultRules, IOSIntArray *resultOffsets, IOSDoubleArray *resultCoords, IOSDoubleArray *coords, jint resultRulesPos, jint resultCoordPos, ComIntersectPoint *point, jboolean isCurrentArea, jboolean way, jint operation);

__attribute__((unused)) static IOSDoubleArray *HarmonyJavaAwtGeomArea_adjustSizeWithDoubleArray_withInt_(IOSDoubleArray *array, jint newSize);

__attribute__((unused)) static IOSIntArray *HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(IOSIntArray *array, jint newSize);

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *src, HarmonyJavaAwtGeomArea *dst);

__attribute__((unused)) static jint HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(HarmonyJavaAwtGeomArea *self, jdouble x, jdouble y);

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_reverseCopyWithDoubleArray_(HarmonyJavaAwtGeomArea *self, IOSDoubleArray *coords);

__attribute__((unused)) static jdouble HarmonyJavaAwtGeomArea_getAreaBoundsSquare(HarmonyJavaAwtGeomArea *self);

__attribute__((unused)) static jboolean HarmonyJavaAwtGeomArea_isVertexWithDouble_withDouble_(HarmonyJavaAwtGeomArea *self, jdouble x, jdouble y);

@interface HarmonyJavaAwtGeomArea_AreaPathIterator : NSObject < HarmonyJavaAwtGeomPathIterator > {
 @public
  HarmonyJavaAwtGeomArea *this$0_;
  HarmonyJavaAwtGeomAffineTransform *transform_;
  HarmonyJavaAwtGeomArea *area_;
  jint curRuleIndex_;
  jint curCoordIndex_;
}

- (instancetype)initWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)outer$
                    withHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area;

- (instancetype)initWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)outer$
                    withHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area
         withHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t;

- (jint)getWindingRule;

- (jboolean)isDone;

- (void)next;

- (jint)currentSegmentWithDoubleArray:(IOSDoubleArray *)c;

- (jint)currentSegmentWithFloatArray:(IOSFloatArray *)c;

@end

J2OBJC_EMPTY_STATIC_INIT(HarmonyJavaAwtGeomArea_AreaPathIterator)

J2OBJC_FIELD_SETTER(HarmonyJavaAwtGeomArea_AreaPathIterator, transform_, HarmonyJavaAwtGeomAffineTransform *)
J2OBJC_FIELD_SETTER(HarmonyJavaAwtGeomArea_AreaPathIterator, area_, HarmonyJavaAwtGeomArea *)

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea_AreaPathIterator *self, HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area);

__attribute__((unused)) static HarmonyJavaAwtGeomArea_AreaPathIterator *new_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area) NS_RETURNS_RETAINED;

__attribute__((unused)) static HarmonyJavaAwtGeomArea_AreaPathIterator *create_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area);

__attribute__((unused)) static void HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomArea_AreaPathIterator *self, HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area, HarmonyJavaAwtGeomAffineTransform *t);

__attribute__((unused)) static HarmonyJavaAwtGeomArea_AreaPathIterator *new_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area, HarmonyJavaAwtGeomAffineTransform *t) NS_RETURNS_RETAINED;

__attribute__((unused)) static HarmonyJavaAwtGeomArea_AreaPathIterator *create_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area, HarmonyJavaAwtGeomAffineTransform *t);

J2OBJC_TYPE_LITERAL_HEADER(HarmonyJavaAwtGeomArea_AreaPathIterator)

#line 1 "/Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/harmony/java/awt/geom/Area.java"


#line 31
@implementation HarmonyJavaAwtGeomArea

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 68
- (instancetype)init {
  HarmonyJavaAwtGeomArea_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 71
- (instancetype)initWithHarmonyJavaAwtShape:(id<HarmonyJavaAwtShape>)s {
  HarmonyJavaAwtGeomArea_initWithHarmonyJavaAwtShape_(self, s);
  return self;
}


#line 126
- (jboolean)containsWithDouble:(jdouble)x
                    withDouble:(jdouble)y {
  return ![self isEmpty] && HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(self, x, y) > 0;
}

- (jboolean)containsWithDouble:(jdouble)x
                    withDouble:(jdouble)y
                    withDouble:(jdouble)width
                    withDouble:(jdouble)height {
  
#line 133
  jint crossCount = ComCrossing_intersectPathWithHarmonyJavaAwtGeomPathIterator_withDouble_withDouble_withDouble_withDouble_([self getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:nil], x, y, width, height);
  return crossCount != ComCrossing_CROSSING && ComCrossing_isInsideEvenOddWithInt_(crossCount);
}


#line 137
- (jboolean)containsWithHarmonyJavaAwtGeomPoint2D:(HarmonyJavaAwtGeomPoint2D *)p {
  
#line 139
  return [self containsWithDouble:[((HarmonyJavaAwtGeomPoint2D *) nil_chk(p)) getX] withDouble:[p getY]];
}


#line 142
- (jboolean)containsWithHarmonyJavaAwtGeomRectangle2D:(HarmonyJavaAwtGeomRectangle2D *)r {
  
#line 144
  return [self containsWithDouble:[((HarmonyJavaAwtGeomRectangle2D *) nil_chk(r)) getX] withDouble:[r getY] withDouble:[r getWidth] withDouble:[r getHeight]];
}


#line 147
- (jboolean)equalsWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)obj {
  if (JreObjectEqualsEquals(self, obj)) {
    return true;
  }
  
#line 152
  if (obj == nil) {
    return false;
  }
  
#line 156
  HarmonyJavaAwtGeomArea *area = (HarmonyJavaAwtGeomArea *) cast_chk([self java_clone], [HarmonyJavaAwtGeomArea class]);
  [((HarmonyJavaAwtGeomArea *) nil_chk(area)) subtractWithHarmonyJavaAwtGeomArea:obj];
  return [area isEmpty];
}


#line 161
- (jboolean)intersectsWithDouble:(jdouble)x
                      withDouble:(jdouble)y
                      withDouble:(jdouble)width
                      withDouble:(jdouble)height {
  
#line 163
  if (width <= 0.0 || height <= 0.0) {
    return false;
  }
  else
#line 165
  if (![((HarmonyJavaAwtGeomRectangle2D *) nil_chk([self getBounds2D])) intersectsWithDouble:x withDouble:y withDouble:width withDouble:height]) {
    return false;
  }
  
#line 169
  jint crossCount = ComCrossing_intersectShapeWithHarmonyJavaAwtShape_withDouble_withDouble_withDouble_withDouble_(self, x, y, width, height);
  return ComCrossing_isInsideEvenOddWithInt_(crossCount);
}


#line 173
- (jboolean)intersectsWithHarmonyJavaAwtGeomRectangle2D:(HarmonyJavaAwtGeomRectangle2D *)r {
  
#line 175
  return [self intersectsWithDouble:[((HarmonyJavaAwtGeomRectangle2D *) nil_chk(r)) getX] withDouble:[r getY] withDouble:[r getWidth] withDouble:[r getHeight]];
}


#line 178
- (HarmonyJavaAwtAWTRectangle *)getBounds {
  
#line 180
  return [((HarmonyJavaAwtGeomRectangle2D *) nil_chk([self getBounds2D])) getBounds];
}


#line 183
- (HarmonyJavaAwtGeomRectangle2D *)getBounds2D {
  
#line 185
  jdouble maxX = IOSDoubleArray_Get(nil_chk(self->coords_), 0);
  jdouble maxY = IOSDoubleArray_Get(self->coords_, 1);
  jdouble minX = IOSDoubleArray_Get(self->coords_, 0);
  jdouble minY = IOSDoubleArray_Get(self->coords_, 1);
  
#line 190
  for (jint i = 0; i < self->coordsSize_; ) {
    minX = JavaLangMath_minWithDouble_withDouble_(minX, IOSDoubleArray_Get(nil_chk(self->coords_), i));
    maxX = JavaLangMath_maxWithDouble_withDouble_(maxX, IOSDoubleArray_Get(nil_chk(self->coords_), i++));
    minY = JavaLangMath_minWithDouble_withDouble_(minY, IOSDoubleArray_Get(nil_chk(self->coords_), i));
    maxY = JavaLangMath_maxWithDouble_withDouble_(maxY, IOSDoubleArray_Get(nil_chk(self->coords_), i++));
  }
  
#line 197
  return new_HarmonyJavaAwtGeomRectangle2D_Double_initWithDouble_withDouble_withDouble_withDouble_(minX, minY, maxX - minX, maxY - minY);
}


#line 200
- (id<HarmonyJavaAwtGeomPathIterator>)getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t {
  
#line 202
  return new_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(self, self, t);
}


#line 205
- (id<HarmonyJavaAwtGeomPathIterator>)getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t
                                                                                withDouble:(jdouble)flatness {
  return new_HarmonyJavaAwtGeomFlatteningPathIterator_initWithHarmonyJavaAwtGeomPathIterator_withDouble_([self getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:t], flatness);
}

- (jboolean)isEmpty {
  return self->rulesSize_ == 0 && self->coordsSize_ == 0;
}

- (jboolean)isPolygonal {
  return self->isPolygonal_;
}

- (jboolean)isRectangular {
  return self->isPolygonal_ && self->rulesSize_ <= 5 && self->coordsSize_ <= 8 && IOSDoubleArray_Get(nil_chk(self->coords_), 1) == IOSDoubleArray_Get(self->coords_, 3) &&
#line 220
  IOSDoubleArray_Get(self->coords_, 7) == IOSDoubleArray_Get(self->coords_, 5) && IOSDoubleArray_Get(self->coords_, 0) == IOSDoubleArray_Get(self->coords_, 6) && IOSDoubleArray_Get(self->coords_, 2) == IOSDoubleArray_Get(self->coords_, 4);
}


#line 223
- (jboolean)isSingular {
  return self->moveToCount_ <= 1;
}

- (void)reset {
  self->coordsSize_ = 0;
  self->rulesSize_ = 0;
}

- (void)transformWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t {
  HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, new_HarmonyJavaAwtGeomArea_initWithHarmonyJavaAwtShape_([((HarmonyJavaAwtGeomAffineTransform *) nil_chk(t)) createTransformedShapeWithHarmonyJavaAwtShape:self]), self);
}

- (HarmonyJavaAwtGeomArea *)createTransformedAreaWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t {
  return new_HarmonyJavaAwtGeomArea_initWithHarmonyJavaAwtShape_([((HarmonyJavaAwtGeomAffineTransform *) nil_chk(t)) createTransformedShapeWithHarmonyJavaAwtShape:self]);
}

- (id)java_clone {
  
#line 242
  HarmonyJavaAwtGeomArea *area = new_HarmonyJavaAwtGeomArea_init();
  HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, self, area);
  return area;
}


#line 247
- (void)addWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  if (area == nil || [area isEmpty]) {
    return;
  }
  else
#line 250
  if ([self isEmpty]) {
    HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, area, self);
    return;
  }
  
#line 255
  if ([self isPolygonal] && [area isPolygonal]) {
    HarmonyJavaAwtGeomArea_addPolygonWithHarmonyJavaAwtGeomArea_(self, area);
  }
  else {
    
#line 258
    HarmonyJavaAwtGeomArea_addCurvePolygonWithHarmonyJavaAwtGeomArea_(self, area);
  }
  
#line 261
  if (HarmonyJavaAwtGeomArea_getAreaBoundsSquare(self) < JreLoadStatic(ComGeometryUtil, EPSILON)) {
    [self reset];
  }
}


#line 266
- (void)intersectWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  if (area == nil) {
    return;
  }
  else
#line 269
  if ([self isEmpty] || [area isEmpty]) {
    [self reset];
    return;
  }
  
#line 274
  if ([self isPolygonal] && [area isPolygonal]) {
    HarmonyJavaAwtGeomArea_intersectPolygonWithHarmonyJavaAwtGeomArea_(self, area);
  }
  else {
    
#line 277
    HarmonyJavaAwtGeomArea_intersectCurvePolygonWithHarmonyJavaAwtGeomArea_(self, area);
  }
  
#line 280
  if (HarmonyJavaAwtGeomArea_getAreaBoundsSquare(self) < JreLoadStatic(ComGeometryUtil, EPSILON)) {
    [self reset];
  }
}


#line 285
- (void)subtractWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  if (area == nil || [self isEmpty] || [area isEmpty]) {
    return;
  }
  
#line 290
  if ([self isPolygonal] && [area isPolygonal]) {
    HarmonyJavaAwtGeomArea_subtractPolygonWithHarmonyJavaAwtGeomArea_(self, area);
  }
  else {
    
#line 293
    HarmonyJavaAwtGeomArea_subtractCurvePolygonWithHarmonyJavaAwtGeomArea_(self, area);
  }
  
#line 296
  if (HarmonyJavaAwtGeomArea_getAreaBoundsSquare(self) < JreLoadStatic(ComGeometryUtil, EPSILON)) {
    [self reset];
  }
}


#line 301
- (void)exclusiveOrWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  HarmonyJavaAwtGeomArea *a = (HarmonyJavaAwtGeomArea *) cast_chk([self java_clone], [HarmonyJavaAwtGeomArea class]);
  [((HarmonyJavaAwtGeomArea *) nil_chk(a)) intersectWithHarmonyJavaAwtGeomArea:area];
  [self addWithHarmonyJavaAwtGeomArea:area];
  [self subtractWithHarmonyJavaAwtGeomArea:a];
}

- (void)addCurvePolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  HarmonyJavaAwtGeomArea_addCurvePolygonWithHarmonyJavaAwtGeomArea_(self, area);
}


#line 393
- (void)addPolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  HarmonyJavaAwtGeomArea_addPolygonWithHarmonyJavaAwtGeomArea_(self, area);
}


#line 480
- (void)intersectCurvePolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  HarmonyJavaAwtGeomArea_intersectCurvePolygonWithHarmonyJavaAwtGeomArea_(self, area);
}


#line 575
- (void)intersectPolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  HarmonyJavaAwtGeomArea_intersectPolygonWithHarmonyJavaAwtGeomArea_(self, area);
}


#line 655
- (void)subtractCurvePolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  HarmonyJavaAwtGeomArea_subtractCurvePolygonWithHarmonyJavaAwtGeomArea_(self, area);
}


#line 742
- (void)subtractPolygonWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  HarmonyJavaAwtGeomArea_subtractPolygonWithHarmonyJavaAwtGeomArea_(self, area);
}


#line 863
- (ComIntersectPoint *)getNextIntersectPointWithComIntersectPointArray:(IOSObjectArray *)iPoints
                                                 withComIntersectPoint:(ComIntersectPoint *)isectPoint
                                                           withBoolean:(jboolean)isCurrentArea {
  return HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self, iPoints, isectPoint, isCurrentArea);
}


#line 895
- (ComIntersectPoint *)getPrevIntersectPointWithComIntersectPointArray:(IOSObjectArray *)iPoints
                                                 withComIntersectPoint:(ComIntersectPoint *)isectPoint
                                                           withBoolean:(jboolean)isCurrentArea {
  return HarmonyJavaAwtGeomArea_getPrevIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self, iPoints, isectPoint, isCurrentArea);
}


#line 929
- (jint)includeCoordsAndRulesWithInt:(jint)offset
                             withInt:(jint)length
                        withIntArray:(IOSIntArray *)rules
                        withIntArray:(IOSIntArray *)offsets
                        withIntArray:(IOSIntArray *)resultRules
                        withIntArray:(IOSIntArray *)resultOffsets
                     withDoubleArray:(IOSDoubleArray *)resultCoords
                     withDoubleArray:(IOSDoubleArray *)coords
                             withInt:(jint)resultRulesPos
                             withInt:(jint)resultCoordPos
               withComIntersectPoint:(ComIntersectPoint *)point
                         withBoolean:(jboolean)isCurrentArea
                         withBoolean:(jboolean)way
                             withInt:(jint)operation {
  return HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(self, offset, length, rules, offsets, resultRules, resultOffsets, resultCoords, coords, resultRulesPos, resultCoordPos, point, isCurrentArea, way, operation);
}


#line 1034
+ (IOSDoubleArray *)adjustSizeWithDoubleArray:(IOSDoubleArray *)array
                                      withInt:(jint)newSize {
  return HarmonyJavaAwtGeomArea_adjustSizeWithDoubleArray_withInt_(array, newSize);
}


#line 1043
+ (IOSIntArray *)adjustSizeWithIntArray:(IOSIntArray *)array
                                withInt:(jint)newSize {
  return HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(array, newSize);
}


#line 1052
- (void)copy__WithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)src
              withHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)dst {
  HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, src, dst);
}


#line 1061
- (jint)containsExactWithDouble:(jdouble)x
                     withDouble:(jdouble)y {
  return HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(self, x, y);
}


#line 1120
- (void)reverseCopyWithDoubleArray:(IOSDoubleArray *)coords {
  HarmonyJavaAwtGeomArea_reverseCopyWithDoubleArray_(self, coords);
}


#line 1131
- (jdouble)getAreaBoundsSquare {
  return HarmonyJavaAwtGeomArea_getAreaBoundsSquare(self);
}


#line 1136
- (jboolean)isVertexWithDouble:(jdouble)x
                    withDouble:(jdouble)y {
  return HarmonyJavaAwtGeomArea_isVertexWithDouble_withDouble_(self, x, y);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 2, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 4, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 1, 5, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 8, 3, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 8, 5, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtAWTRectangle;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomRectangle2D;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomPathIterator;", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomPathIterator;", 0x1, 9, 11, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 12, 10, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomArea;", 0x1, 13, 10, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 14, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 15, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 16, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 17, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 18, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 19, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 20, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 21, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 22, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 23, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 24, 7, -1, -1, -1, -1 },
    { NULL, "LComIntersectPoint;", 0x2, 25, 26, -1, -1, -1, -1 },
    { NULL, "LComIntersectPoint;", 0x2, 27, 26, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 28, 29, -1, -1, -1, -1 },
    { NULL, "[D", 0xa, 30, 31, -1, -1, -1, -1 },
    { NULL, "[I", 0xa, 30, 32, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 33, 34, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 35, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 36, 37, -1, -1, -1, -1 },
    { NULL, "D", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x2, 38, 2, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithHarmonyJavaAwtShape:);
  methods[2].selector = @selector(containsWithDouble:withDouble:);
  methods[3].selector = @selector(containsWithDouble:withDouble:withDouble:withDouble:);
  methods[4].selector = @selector(containsWithHarmonyJavaAwtGeomPoint2D:);
  methods[5].selector = @selector(containsWithHarmonyJavaAwtGeomRectangle2D:);
  methods[6].selector = @selector(equalsWithHarmonyJavaAwtGeomArea:);
  methods[7].selector = @selector(intersectsWithDouble:withDouble:withDouble:withDouble:);
  methods[8].selector = @selector(intersectsWithHarmonyJavaAwtGeomRectangle2D:);
  methods[9].selector = @selector(getBounds);
  methods[10].selector = @selector(getBounds2D);
  methods[11].selector = @selector(getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:);
  methods[12].selector = @selector(getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:withDouble:);
  methods[13].selector = @selector(isEmpty);
  methods[14].selector = @selector(isPolygonal);
  methods[15].selector = @selector(isRectangular);
  methods[16].selector = @selector(isSingular);
  methods[17].selector = @selector(reset);
  methods[18].selector = @selector(transformWithHarmonyJavaAwtGeomAffineTransform:);
  methods[19].selector = @selector(createTransformedAreaWithHarmonyJavaAwtGeomAffineTransform:);
  methods[20].selector = @selector(java_clone);
  methods[21].selector = @selector(addWithHarmonyJavaAwtGeomArea:);
  methods[22].selector = @selector(intersectWithHarmonyJavaAwtGeomArea:);
  methods[23].selector = @selector(subtractWithHarmonyJavaAwtGeomArea:);
  methods[24].selector = @selector(exclusiveOrWithHarmonyJavaAwtGeomArea:);
  methods[25].selector = @selector(addCurvePolygonWithHarmonyJavaAwtGeomArea:);
  methods[26].selector = @selector(addPolygonWithHarmonyJavaAwtGeomArea:);
  methods[27].selector = @selector(intersectCurvePolygonWithHarmonyJavaAwtGeomArea:);
  methods[28].selector = @selector(intersectPolygonWithHarmonyJavaAwtGeomArea:);
  methods[29].selector = @selector(subtractCurvePolygonWithHarmonyJavaAwtGeomArea:);
  methods[30].selector = @selector(subtractPolygonWithHarmonyJavaAwtGeomArea:);
  methods[31].selector = @selector(getNextIntersectPointWithComIntersectPointArray:withComIntersectPoint:withBoolean:);
  methods[32].selector = @selector(getPrevIntersectPointWithComIntersectPointArray:withComIntersectPoint:withBoolean:);
  methods[33].selector = @selector(includeCoordsAndRulesWithInt:withInt:withIntArray:withIntArray:withIntArray:withIntArray:withDoubleArray:withDoubleArray:withInt:withInt:withComIntersectPoint:withBoolean:withBoolean:withInt:);
  methods[34].selector = @selector(adjustSizeWithDoubleArray:withInt:);
  methods[35].selector = @selector(adjustSizeWithIntArray:withInt:);
  methods[36].selector = @selector(copy__WithHarmonyJavaAwtGeomArea:withHarmonyJavaAwtGeomArea:);
  methods[37].selector = @selector(containsExactWithDouble:withDouble:);
  methods[38].selector = @selector(reverseCopyWithDoubleArray:);
  methods[39].selector = @selector(getAreaBoundsSquare);
  methods[40].selector = @selector(isVertexWithDouble:withDouble:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "coords_", "[D", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "coordsSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "rules_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "rulesSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "offsets_", "[I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "moveToCount_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "isPolygonal_", "Z", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LHarmonyJavaAwtShape;", "contains", "DD", "DDDD", "LHarmonyJavaAwtGeomPoint2D;", "LHarmonyJavaAwtGeomRectangle2D;", "equals", "LHarmonyJavaAwtGeomArea;", "intersects", "getPathIterator", "LHarmonyJavaAwtGeomAffineTransform;", "LHarmonyJavaAwtGeomAffineTransform;D", "transform", "createTransformedArea", "clone", "add", "intersect", "subtract", "exclusiveOr", "addCurvePolygon", "addPolygon", "intersectCurvePolygon", "intersectPolygon", "subtractCurvePolygon", "subtractPolygon", "getNextIntersectPoint", "[LComIntersectPoint;LComIntersectPoint;Z", "getPrevIntersectPoint", "includeCoordsAndRules", "II[I[I[I[I[D[DIILComIntersectPoint;ZZI", "adjustSize", "[DI", "[II", "copy", "LHarmonyJavaAwtGeomArea;LHarmonyJavaAwtGeomArea;", "containsExact", "reverseCopy", "[D", "isVertex", "LHarmonyJavaAwtGeomArea_AreaPathIterator;" };
  static const J2ObjcClassInfo _HarmonyJavaAwtGeomArea = { "Area", "harmony.java.awt.geom", ptrTable, methods, fields, 7, 0x1, 41, 7, -1, 39, -1, -1, -1 };
  return &_HarmonyJavaAwtGeomArea;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self java_clone];
}

@end


#line 68
void HarmonyJavaAwtGeomArea_init(HarmonyJavaAwtGeomArea *self) {
  NSObject_init(self);
  self->coords_ = [IOSDoubleArray newArrayWithLength:
#line 36
  20];
  self->coordsSize_ =
#line 41
  0;
  self->rules_ = [IOSIntArray newArrayWithLength:
#line 46
  10];
  self->rulesSize_ =
#line 51
  0;
  self->offsets_ = [IOSIntArray newArrayWithLength:
#line 56
  10];
  self->moveToCount_ =
#line 61
  0;
  self->isPolygonal_ =
#line 66
  true;
}


#line 68
HarmonyJavaAwtGeomArea *new_HarmonyJavaAwtGeomArea_init() {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomArea, init)
}


#line 68
HarmonyJavaAwtGeomArea *create_HarmonyJavaAwtGeomArea_init() {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomArea, init)
}


#line 71
void HarmonyJavaAwtGeomArea_initWithHarmonyJavaAwtShape_(HarmonyJavaAwtGeomArea *self, id<HarmonyJavaAwtShape> s) {
  NSObject_init(self);
  self->coords_ = [IOSDoubleArray newArrayWithLength:
#line 36
  20];
  self->coordsSize_ =
#line 41
  0;
  self->rules_ = [IOSIntArray newArrayWithLength:
#line 46
  10];
  self->rulesSize_ =
#line 51
  0;
  self->offsets_ = [IOSIntArray newArrayWithLength:
#line 56
  10];
  self->moveToCount_ =
#line 61
  0;
  self->isPolygonal_ =
#line 66
  true;
  
#line 72
  IOSDoubleArray *segmentCoords = [IOSDoubleArray newArrayWithLength:6];
  jdouble lastMoveX = 0.0;
  jdouble lastMoveY = 0.0;
  jint rulesIndex = 0;
  jint coordsIndex = 0;
  
#line 78
  for (id<HarmonyJavaAwtGeomPathIterator> pi = [((id<HarmonyJavaAwtShape>) nil_chk(s)) getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:nil]; ![((id<HarmonyJavaAwtGeomPathIterator>) nil_chk(pi)) isDone]; [pi next]) {
    self->coords_ = HarmonyJavaAwtGeomArea_adjustSizeWithDoubleArray_withInt_(self->coords_, coordsIndex + 6);
    self->rules_ = HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(self->rules_, rulesIndex + 1);
    self->offsets_ = HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(self->offsets_, rulesIndex + 1);
    *IOSIntArray_GetRef(nil_chk(self->rules_), rulesIndex) = [pi currentSegmentWithDoubleArray:segmentCoords];
    *IOSIntArray_GetRef(nil_chk(self->offsets_), rulesIndex) = coordsIndex;
    
#line 85
    switch (IOSIntArray_Get(nil_chk(self->rules_), rulesIndex)) {
      case HarmonyJavaAwtGeomPathIterator_SEG_MOVETO:
      *IOSDoubleArray_GetRef(nil_chk(self->coords_), coordsIndex++) = IOSDoubleArray_Get(segmentCoords, 0);
      *IOSDoubleArray_GetRef(self->coords_, coordsIndex++) = IOSDoubleArray_Get(segmentCoords, 1);
      lastMoveX = IOSDoubleArray_Get(segmentCoords, 0);
      lastMoveY = IOSDoubleArray_Get(segmentCoords, 1);
      ++self->moveToCount_;
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_LINETO:
      if (IOSDoubleArray_Get(segmentCoords, 0) != lastMoveX || IOSDoubleArray_Get(segmentCoords, 1) != lastMoveY) {
        *IOSDoubleArray_GetRef(nil_chk(self->coords_), coordsIndex++) = IOSDoubleArray_Get(segmentCoords, 0);
        *IOSDoubleArray_GetRef(self->coords_, coordsIndex++) = IOSDoubleArray_Get(segmentCoords, 1);
      }
      else {
        
#line 98
        --rulesIndex;
      }
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_QUADTO:
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(segmentCoords, 0, self->coords_, coordsIndex, 4);
      coordsIndex += 4;
      self->isPolygonal_ = false;
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO:
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(segmentCoords, 0, self->coords_, coordsIndex, 6);
      coordsIndex += 6;
      self->isPolygonal_ = false;
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_CLOSE:
      break;
    }
    ++rulesIndex;
  }
  
#line 117
  if (rulesIndex != 0 && IOSIntArray_Get(nil_chk(self->rules_), rulesIndex - 1) != HarmonyJavaAwtGeomPathIterator_SEG_CLOSE) {
    *IOSIntArray_GetRef(nil_chk(self->rules_), rulesIndex) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
    *IOSIntArray_GetRef(nil_chk(self->offsets_), rulesIndex) = self->coordsSize_;
  }
  
#line 122
  self->rulesSize_ = rulesIndex;
  self->coordsSize_ = coordsIndex;
}


#line 71
HarmonyJavaAwtGeomArea *new_HarmonyJavaAwtGeomArea_initWithHarmonyJavaAwtShape_(id<HarmonyJavaAwtShape> s) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomArea, initWithHarmonyJavaAwtShape_, s)
}


#line 71
HarmonyJavaAwtGeomArea *create_HarmonyJavaAwtGeomArea_initWithHarmonyJavaAwtShape_(id<HarmonyJavaAwtShape> s) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomArea, initWithHarmonyJavaAwtShape_, s)
}


#line 308
void HarmonyJavaAwtGeomArea_addCurvePolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area) {
  ComCurveCrossingHelper *crossHelper = new_ComCurveCrossingHelper_initWithDoubleArray2_withIntArray_withIntArray2_withIntArray_withIntArray2_([IOSObjectArray newArrayWithObjects:(id[]){ self->coords_, ((HarmonyJavaAwtGeomArea *) nil_chk(area))->coords_ } count:2 type:IOSClass_doubleArray(1)], [IOSIntArray newArrayWithInts:(jint[]){
#line 310
    self->coordsSize_, area->coordsSize_ } count:2], [IOSObjectArray newArrayWithObjects:(id[]){ self->rules_, area->rules_ } count:2 type:IOSClass_intArray(1)], [IOSIntArray newArrayWithInts:(jint[]){
#line 311
      self->rulesSize_, area->rulesSize_ } count:2], [IOSObjectArray newArrayWithObjects:(id[]){ self->offsets_, area->offsets_ } count:2 type:IOSClass_intArray(1)]);
      IOSObjectArray *intersectPoints = [crossHelper findCrossing];
      
#line 314
      if (((IOSObjectArray *) nil_chk(intersectPoints))->size_ == 0) {
        if ([area containsWithHarmonyJavaAwtGeomRectangle2D:[self getBounds2D]]) {
          HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, area, self);
        }
        else
#line 317
        if (![self containsWithHarmonyJavaAwtGeomRectangle2D:[area getBounds2D]]) {
          self->coords_ = HarmonyJavaAwtGeomArea_adjustSizeWithDoubleArray_withInt_(self->coords_, self->coordsSize_ + area->coordsSize_);
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(area->coords_, 0, self->coords_, self->coordsSize_, area->coordsSize_);
          self->coordsSize_ += area->coordsSize_;
          self->rules_ = HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(self->rules_, self->rulesSize_ + area->rulesSize_);
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(area->rules_, 0, self->rules_, self->rulesSize_, area->rulesSize_);
          self->rulesSize_ += area->rulesSize_;
          self->offsets_ = HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(self->offsets_, self->rulesSize_ + area->rulesSize_);
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(area->offsets_, 0, self->offsets_, self->rulesSize_, area->rulesSize_);
        }
        
#line 328
        return;
      }
      
#line 331
      IOSDoubleArray *resultCoords = [IOSDoubleArray newArrayWithLength:self->coordsSize_ + area->coordsSize_ + intersectPoints->size_];
      IOSIntArray *resultRules = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
      IOSIntArray *resultOffsets = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
      jint resultCoordPos = 0;
      jint resultRulesPos = 0;
      jboolean isCurrentArea = true;
      
#line 338
      ComIntersectPoint *point = IOSObjectArray_Get(intersectPoints, 0);
      *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_MOVETO;
      *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
      
#line 342
      do {
        *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [((ComIntersectPoint *) nil_chk(point)) getX];
        *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [point getY];
        jint curIndex = [point getEndIndexWithBoolean:true];
        
#line 347
        if (curIndex < 0) {
          isCurrentArea = !isCurrentArea;
        }
        else
#line 349
        if (HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1)) > 0) {
          isCurrentArea = false;
        }
        else {
          
#line 352
          isCurrentArea = true;
        }
        
#line 355
        ComIntersectPoint *nextPoint = HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self, intersectPoints, point, isCurrentArea);
        IOSDoubleArray *coords = isCurrentArea ? self->coords_ : area->coords_;
        IOSIntArray *offsets = isCurrentArea ? self->offsets_ : area->offsets_;
        IOSIntArray *rules = isCurrentArea ? self->rules_ : area->rules_;
        jint offset = [point getRuleIndexWithBoolean:isCurrentArea];
        jboolean isCopyUntilZero = false;
        
#line 362
        if ([point getRuleIndexWithBoolean:isCurrentArea] > [((ComIntersectPoint *) nil_chk(nextPoint)) getRuleIndexWithBoolean:isCurrentArea]) {
          jint rulesSize = isCurrentArea ? self->rulesSize_ : area->rulesSize_;
          resultCoordPos = HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(self, offset + 1, rulesSize, rules, offsets, resultRules,
#line 365
          resultOffsets, resultCoords, coords, resultRulesPos, resultCoordPos, point, isCurrentArea,
#line 366
          false, 0);
          resultRulesPos += rulesSize - offset - 1;
          offset = 1;
          isCopyUntilZero = true;
        }
        
#line 372
        jint length = [nextPoint getRuleIndexWithBoolean:isCurrentArea] - offset + 1;
        
#line 374
        if (isCopyUntilZero) {
          offset = 0;
        }
        
#line 378
        resultCoordPos = HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(self, offset, length, rules, offsets, resultRules, resultOffsets,
#line 379
        resultCoords, coords, resultRulesPos, resultCoordPos, point, isCurrentArea, true, 0);
        resultRulesPos += length - offset;
        point = nextPoint;
      }
      while (!JreObjectEqualsEquals(
#line 382
      point, IOSObjectArray_Get(intersectPoints, 0)));
      
#line 384
      *IOSIntArray_GetRef(resultRules, resultRulesPos++) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
      *IOSIntArray_GetRef(resultOffsets, resultRulesPos - 1) = resultCoordPos;
      self->coords_ = resultCoords;
      self->rules_ = resultRules;
      self->offsets_ = resultOffsets;
      self->coordsSize_ = resultCoordPos;
      self->rulesSize_ = resultRulesPos;
    }


#line 393
void HarmonyJavaAwtGeomArea_addPolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area) {
  ComCrossingHelper *crossHelper = new_ComCrossingHelper_initWithDoubleArray2_withIntArray_([IOSObjectArray newArrayWithObjects:(id[]){ self->coords_, ((HarmonyJavaAwtGeomArea *) nil_chk(area))->coords_ } count:2 type:IOSClass_doubleArray(1)], [IOSIntArray newArrayWithInts:(jint[]){ self->coordsSize_,
#line 395
  area->coordsSize_ } count:2]);
  IOSObjectArray *intersectPoints = [crossHelper findCrossing];
  
#line 398
  if (((IOSObjectArray *) nil_chk(intersectPoints))->size_ == 0) {
    if ([area containsWithHarmonyJavaAwtGeomRectangle2D:[self getBounds2D]]) {
      HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, area, self);
    }
    else
#line 401
    if (![self containsWithHarmonyJavaAwtGeomRectangle2D:[area getBounds2D]]) {
      self->coords_ = HarmonyJavaAwtGeomArea_adjustSizeWithDoubleArray_withInt_(self->coords_, self->coordsSize_ + area->coordsSize_);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(area->coords_, 0, self->coords_, self->coordsSize_, area->coordsSize_);
      self->coordsSize_ += area->coordsSize_;
      self->rules_ = HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(self->rules_, self->rulesSize_ + area->rulesSize_);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(area->rules_, 0, self->rules_, self->rulesSize_, area->rulesSize_);
      self->rulesSize_ += area->rulesSize_;
      self->offsets_ = HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(self->offsets_, self->rulesSize_ + area->rulesSize_);
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(area->offsets_, 0, self->offsets_, self->rulesSize_, area->rulesSize_);
    }
    return;
  }
  
#line 414
  IOSDoubleArray *resultCoords = [IOSDoubleArray newArrayWithLength:self->coordsSize_ + area->coordsSize_ + intersectPoints->size_];
  IOSIntArray *resultRules = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
  IOSIntArray *resultOffsets = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
  jint resultCoordPos = 0;
  jint resultRulesPos = 0;
  jboolean isCurrentArea = true;
  
#line 421
  ComIntersectPoint *point = IOSObjectArray_Get(intersectPoints, 0);
  *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_MOVETO;
  *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
  
#line 425
  do {
    *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [((ComIntersectPoint *) nil_chk(point)) getX];
    *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [point getY];
    *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
    *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos - 2;
    jint curIndex = [point getEndIndexWithBoolean:true];
    if (curIndex < 0) {
      isCurrentArea = !isCurrentArea;
    }
    else
#line 433
    if (HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1)) > 0) {
      isCurrentArea = false;
    }
    else {
      
#line 436
      isCurrentArea = true;
    }
    
#line 439
    ComIntersectPoint *nextPoint = HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self, intersectPoints, point, isCurrentArea);
    IOSDoubleArray *coords = isCurrentArea ? self->coords_ : area->coords_;
    jint offset = 2 * [point getEndIndexWithBoolean:isCurrentArea];
    
#line 443
    if (offset >= 0 && [((ComIntersectPoint *) nil_chk(nextPoint)) getBegIndexWithBoolean:isCurrentArea] < [point getEndIndexWithBoolean:isCurrentArea]) {
      jint coordSize = isCurrentArea ? self->coordsSize_ : area->coordsSize_;
      jint length = coordSize - offset;
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, offset, resultCoords, resultCoordPos, length);
      
#line 448
      for (jint i = 0; i < JreIntDiv(length, 2); i++) {
        *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
        *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
        resultCoordPos += 2;
      }
      
#line 454
      offset = 0;
    }
    
#line 457
    if (offset >= 0) {
      jint length = 2 * [((ComIntersectPoint *) nil_chk(nextPoint)) getBegIndexWithBoolean:isCurrentArea] - offset + 2;
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, offset, resultCoords, resultCoordPos, length);
      
#line 461
      for (jint i = 0; i < JreIntDiv(length, 2); i++) {
        *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
        *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    
#line 468
    point = nextPoint;
  }
  while (!JreObjectEqualsEquals(
#line 469
  point, IOSObjectArray_Get(intersectPoints, 0)));
  
#line 471
  *IOSIntArray_GetRef(resultRules, resultRulesPos - 1) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
  *IOSIntArray_GetRef(resultOffsets, resultRulesPos - 1) = resultCoordPos;
  self->coords_ = resultCoords;
  self->rules_ = resultRules;
  self->offsets_ = resultOffsets;
  self->coordsSize_ = resultCoordPos;
  self->rulesSize_ = resultRulesPos;
}


#line 480
void HarmonyJavaAwtGeomArea_intersectCurvePolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area) {
  ComCurveCrossingHelper *crossHelper = new_ComCurveCrossingHelper_initWithDoubleArray2_withIntArray_withIntArray2_withIntArray_withIntArray2_([IOSObjectArray newArrayWithObjects:(id[]){ self->coords_, ((HarmonyJavaAwtGeomArea *) nil_chk(area))->coords_ } count:2 type:IOSClass_doubleArray(1)], [IOSIntArray newArrayWithInts:(jint[]){
#line 482
    self->coordsSize_, area->coordsSize_ } count:2], [IOSObjectArray newArrayWithObjects:(id[]){ self->rules_, area->rules_ } count:2 type:IOSClass_intArray(1)], [IOSIntArray newArrayWithInts:(jint[]){
#line 483
      self->rulesSize_, area->rulesSize_ } count:2], [IOSObjectArray newArrayWithObjects:(id[]){ self->offsets_, area->offsets_ } count:2 type:IOSClass_intArray(1)]);
      IOSObjectArray *intersectPoints = [crossHelper findCrossing];
      
#line 486
      if (((IOSObjectArray *) nil_chk(intersectPoints))->size_ == 0) {
        if ([self containsWithHarmonyJavaAwtGeomRectangle2D:[area getBounds2D]]) {
          HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, area, self);
        }
        else
#line 489
        if (![area containsWithHarmonyJavaAwtGeomRectangle2D:[self getBounds2D]]) {
          [self reset];
        }
        return;
      }
      
#line 495
      IOSDoubleArray *resultCoords = [IOSDoubleArray newArrayWithLength:self->coordsSize_ + area->coordsSize_ + intersectPoints->size_];
      IOSIntArray *resultRules = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
      IOSIntArray *resultOffsets = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
      jint resultCoordPos = 0;
      jint resultRulesPos = 0;
      jboolean isCurrentArea = true;
      
#line 502
      ComIntersectPoint *point = IOSObjectArray_Get(intersectPoints, 0);
      ComIntersectPoint *nextPoint = IOSObjectArray_Get(intersectPoints, 0);
      *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_MOVETO;
      *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
      
#line 507
      do {
        *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [((ComIntersectPoint *) nil_chk(point)) getX];
        *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [point getY];
        
#line 511
        jint curIndex = [point getEndIndexWithBoolean:true];
        if (curIndex < 0 || HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1)) == 0) {
          isCurrentArea = !isCurrentArea;
        }
        else
#line 514
        if (HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1)) > 0) {
          isCurrentArea = true;
        }
        else {
          
#line 517
          isCurrentArea = false;
        }
        
#line 520
        nextPoint = HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self, intersectPoints, point, isCurrentArea);
        IOSDoubleArray *coords = isCurrentArea ? self->coords_ : area->coords_;
        IOSIntArray *offsets = isCurrentArea ? self->offsets_ : area->offsets_;
        IOSIntArray *rules = isCurrentArea ? self->rules_ : area->rules_;
        jint offset = [point getRuleIndexWithBoolean:isCurrentArea];
        jboolean isCopyUntilZero = false;
        
#line 527
        if ([point getRuleIndexWithBoolean:isCurrentArea] > [((ComIntersectPoint *) nil_chk(nextPoint)) getRuleIndexWithBoolean:isCurrentArea]) {
          jint rulesSize = isCurrentArea ? self->rulesSize_ : area->rulesSize_;
          resultCoordPos = HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(self, offset + 1, rulesSize, rules, offsets, resultRules,
#line 530
          resultOffsets, resultCoords, coords, resultRulesPos, resultCoordPos, point, isCurrentArea,
#line 531
          false, 1);
          resultRulesPos += rulesSize - offset - 1;
          offset = 1;
          isCopyUntilZero = true;
        }
        
#line 537
        jint length = [nextPoint getRuleIndexWithBoolean:isCurrentArea] - offset + 1;
        
#line 539
        if (isCopyUntilZero) {
          offset = 0;
          isCopyUntilZero = false;
        }
        if (length == offset && [nextPoint getRuleWithBoolean:isCurrentArea] != HarmonyJavaAwtGeomPathIterator_SEG_LINETO &&
#line 544
        [nextPoint getRuleWithBoolean:isCurrentArea] != HarmonyJavaAwtGeomPathIterator_SEG_CLOSE &&
#line 545
        [point getRuleWithBoolean:isCurrentArea] != HarmonyJavaAwtGeomPathIterator_SEG_LINETO &&
#line 546
        [point getRuleWithBoolean:isCurrentArea] != HarmonyJavaAwtGeomPathIterator_SEG_CLOSE) {
          
#line 548
          isCopyUntilZero = true;
          length++;
        }
        
#line 552
        resultCoordPos = HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(self, offset, length, rules, offsets, resultRules, resultOffsets,
#line 553
        resultCoords, coords, resultRulesPos, resultCoordPos, nextPoint, isCurrentArea, true, 1);
        resultRulesPos = length <= offset || isCopyUntilZero ? resultRulesPos + 1 : resultRulesPos + length;
        
#line 556
        point = nextPoint;
      }
      while (!JreObjectEqualsEquals(
#line 557
      point, IOSObjectArray_Get(intersectPoints, 0)));
      
#line 559
      if (IOSIntArray_Get(resultRules, resultRulesPos - 1) == HarmonyJavaAwtGeomPathIterator_SEG_LINETO) {
        *IOSIntArray_GetRef(resultRules, resultRulesPos - 1) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
      }
      else {
        
#line 562
        *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [nextPoint getX];
        *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [nextPoint getY];
        *IOSIntArray_GetRef(resultRules, resultRulesPos++) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
      }
      
#line 567
      *IOSIntArray_GetRef(resultOffsets, resultRulesPos - 1) = resultCoordPos;
      self->coords_ = resultCoords;
      self->rules_ = resultRules;
      self->offsets_ = resultOffsets;
      self->coordsSize_ = resultCoordPos;
      self->rulesSize_ = resultRulesPos;
    }


#line 575
void HarmonyJavaAwtGeomArea_intersectPolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area) {
  ComCrossingHelper *crossHelper = new_ComCrossingHelper_initWithDoubleArray2_withIntArray_([IOSObjectArray newArrayWithObjects:(id[]){ self->coords_, ((HarmonyJavaAwtGeomArea *) nil_chk(area))->coords_ } count:2 type:IOSClass_doubleArray(1)], [IOSIntArray newArrayWithInts:(jint[]){ self->coordsSize_,
#line 577
  area->coordsSize_ } count:2]);
  IOSObjectArray *intersectPoints = [crossHelper findCrossing];
  
#line 580
  if (((IOSObjectArray *) nil_chk(intersectPoints))->size_ == 0) {
    if ([self containsWithHarmonyJavaAwtGeomRectangle2D:[area getBounds2D]]) {
      HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, area, self);
    }
    else
#line 583
    if (![area containsWithHarmonyJavaAwtGeomRectangle2D:[self getBounds2D]]) {
      [self reset];
    }
    return;
  }
  
#line 589
  IOSDoubleArray *resultCoords = [IOSDoubleArray newArrayWithLength:self->coordsSize_ + area->coordsSize_ + intersectPoints->size_];
  IOSIntArray *resultRules = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
  IOSIntArray *resultOffsets = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
  jint resultCoordPos = 0;
  jint resultRulesPos = 0;
  jboolean isCurrentArea = true;
  
#line 596
  ComIntersectPoint *point = IOSObjectArray_Get(intersectPoints, 0);
  *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_MOVETO;
  *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
  
#line 600
  do {
    *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [((ComIntersectPoint *) nil_chk(point)) getX];
    *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [point getY];
    *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
    *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos - 2;
    jint curIndex = [point getEndIndexWithBoolean:true];
    
#line 607
    if (curIndex < 0 || HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1)) == 0) {
      isCurrentArea = !isCurrentArea;
    }
    else
#line 609
    if (HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1)) > 0) {
      isCurrentArea = true;
    }
    else {
      
#line 612
      isCurrentArea = false;
    }
    
#line 615
    ComIntersectPoint *nextPoint = HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self, intersectPoints, point, isCurrentArea);
    IOSDoubleArray *coords = isCurrentArea ? self->coords_ : area->coords_;
    jint offset = 2 * [point getEndIndexWithBoolean:isCurrentArea];
    if (offset >= 0 && [((ComIntersectPoint *) nil_chk(nextPoint)) getBegIndexWithBoolean:isCurrentArea] < [point getEndIndexWithBoolean:isCurrentArea]) {
      jint coordSize = isCurrentArea ? self->coordsSize_ : area->coordsSize_;
      jint length = coordSize - offset;
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, offset, resultCoords, resultCoordPos, length);
      
#line 623
      for (jint i = 0; i < JreIntDiv(length, 2); i++) {
        *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
        *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
        resultCoordPos += 2;
      }
      
#line 629
      offset = 0;
    }
    
#line 632
    if (offset >= 0) {
      jint length = 2 * [((ComIntersectPoint *) nil_chk(nextPoint)) getBegIndexWithBoolean:isCurrentArea] - offset + 2;
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, offset, resultCoords, resultCoordPos, length);
      
#line 636
      for (jint i = 0; i < JreIntDiv(length, 2); i++) {
        *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
        *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    
#line 643
    point = nextPoint;
  }
  while (!JreObjectEqualsEquals(
#line 644
  point, IOSObjectArray_Get(intersectPoints, 0)));
  
#line 646
  *IOSIntArray_GetRef(resultRules, resultRulesPos - 1) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
  *IOSIntArray_GetRef(resultOffsets, resultRulesPos - 1) = resultCoordPos;
  self->coords_ = resultCoords;
  self->rules_ = resultRules;
  self->offsets_ = resultOffsets;
  self->coordsSize_ = resultCoordPos;
  self->rulesSize_ = resultRulesPos;
}


#line 655
void HarmonyJavaAwtGeomArea_subtractCurvePolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area) {
  ComCurveCrossingHelper *crossHelper = new_ComCurveCrossingHelper_initWithDoubleArray2_withIntArray_withIntArray2_withIntArray_withIntArray2_([IOSObjectArray newArrayWithObjects:(id[]){ self->coords_, ((HarmonyJavaAwtGeomArea *) nil_chk(area))->coords_ } count:2 type:IOSClass_doubleArray(1)], [IOSIntArray newArrayWithInts:(jint[]){
#line 657
    self->coordsSize_, area->coordsSize_ } count:2], [IOSObjectArray newArrayWithObjects:(id[]){ self->rules_, area->rules_ } count:2 type:IOSClass_intArray(1)], [IOSIntArray newArrayWithInts:(jint[]){
#line 658
      self->rulesSize_, area->rulesSize_ } count:2], [IOSObjectArray newArrayWithObjects:(id[]){ self->offsets_, area->offsets_ } count:2 type:IOSClass_intArray(1)]);
      IOSObjectArray *intersectPoints = [crossHelper findCrossing];
      
#line 661
      if (((IOSObjectArray *) nil_chk(intersectPoints))->size_ == 0 && [self containsWithHarmonyJavaAwtGeomRectangle2D:[area getBounds2D]]) {
        HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, area, self);
        return;
      }
      
#line 666
      IOSDoubleArray *resultCoords = [IOSDoubleArray newArrayWithLength:self->coordsSize_ + area->coordsSize_ + intersectPoints->size_];
      IOSIntArray *resultRules = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
      IOSIntArray *resultOffsets = [IOSIntArray newArrayWithLength:self->rulesSize_ + area->rulesSize_ + intersectPoints->size_];
      jint resultCoordPos = 0;
      jint resultRulesPos = 0;
      jboolean isCurrentArea = true;
      
#line 673
      ComIntersectPoint *point = IOSObjectArray_Get(intersectPoints, 0);
      *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_MOVETO;
      *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
      
#line 677
      do {
        *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [((ComIntersectPoint *) nil_chk(point)) getX];
        *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [point getY];
        jint curIndex = JreIntMod(IOSIntArray_Get(nil_chk(self->offsets_), [point getRuleIndexWithBoolean:true]), self->coordsSize_);
        
#line 682
        if (HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), curIndex), IOSDoubleArray_Get(self->coords_, curIndex + 1)) == 0) {
          isCurrentArea = !isCurrentArea;
        }
        else
#line 684
        if (HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), curIndex), IOSDoubleArray_Get(self->coords_, curIndex + 1)) > 0) {
          isCurrentArea = false;
        }
        else {
          
#line 687
          isCurrentArea = true;
        }
        
#line 690
        ComIntersectPoint *nextPoint = isCurrentArea ? HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self, intersectPoints, point, isCurrentArea) : HarmonyJavaAwtGeomArea_getPrevIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self,
#line 691
        intersectPoints, point, isCurrentArea);
        IOSDoubleArray *coords = isCurrentArea ? self->coords_ : area->coords_;
        IOSIntArray *offsets = isCurrentArea ? self->offsets_ : area->offsets_;
        IOSIntArray *rules = isCurrentArea ? self->rules_ : area->rules_;
        jint offset = isCurrentArea ? [point getRuleIndexWithBoolean:isCurrentArea] : [nextPoint getRuleIndexWithBoolean:isCurrentArea];
        jboolean isCopyUntilZero = false;
        
#line 698
        if ((isCurrentArea && [point getRuleIndexWithBoolean:isCurrentArea] > [nextPoint getRuleIndexWithBoolean:isCurrentArea]) || (
#line 699
        !isCurrentArea && [nextPoint getRuleIndexWithBoolean:isCurrentArea] > [nextPoint getRuleIndexWithBoolean:
#line 700
        isCurrentArea])) {
          
#line 702
          jint rulesSize = isCurrentArea ? self->rulesSize_ : area->rulesSize_;
          resultCoordPos = HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(self, offset + 1, rulesSize, rules, offsets, resultRules,
#line 704
          resultOffsets, resultCoords, coords, resultRulesPos, resultCoordPos, point, isCurrentArea,
#line 705
          false, 2);
          resultRulesPos += rulesSize - offset - 1;
          offset = 1;
          isCopyUntilZero = true;
        }
        
#line 711
        jint length = [nextPoint getRuleIndexWithBoolean:isCurrentArea] - offset + 1;
        
#line 713
        if (isCopyUntilZero) {
          offset = 0;
          isCopyUntilZero = false;
        }
        
#line 718
        resultCoordPos = HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(self, offset, length, rules, offsets, resultRules, resultOffsets,
#line 719
        resultCoords, coords, resultRulesPos, resultCoordPos, point, isCurrentArea, true, 2);
        
#line 721
        if (length == offset &&
#line 722
        (IOSIntArray_Get(rules, offset) == HarmonyJavaAwtGeomPathIterator_SEG_QUADTO || IOSIntArray_Get(rules, offset) == HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO)) {
          
#line 724
          resultRulesPos++;
        }
        else {
          
#line 726
          resultRulesPos = length < offset || isCopyUntilZero ? resultRulesPos + 1 : resultRulesPos + length -
#line 727
          offset;
        }
        
#line 730
        point = nextPoint;
      }
      while (!JreObjectEqualsEquals(
#line 731
      point, IOSObjectArray_Get(intersectPoints, 0)));
      
#line 733
      *IOSIntArray_GetRef(resultRules, resultRulesPos++) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
      *IOSIntArray_GetRef(resultOffsets, resultRulesPos - 1) = resultCoordPos;
      self->coords_ = resultCoords;
      self->rules_ = resultRules;
      self->offsets_ = resultOffsets;
      self->coordsSize_ = resultCoordPos;
      self->rulesSize_ = resultRulesPos;
    }


#line 742
void HarmonyJavaAwtGeomArea_subtractPolygonWithHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *area) {
  ComCrossingHelper *crossHelper = new_ComCrossingHelper_initWithDoubleArray2_withIntArray_([IOSObjectArray newArrayWithObjects:(id[]){ self->coords_, ((HarmonyJavaAwtGeomArea *) nil_chk(area))->coords_ } count:2 type:IOSClass_doubleArray(1)], [IOSIntArray newArrayWithInts:(jint[]){ self->coordsSize_,
#line 744
  area->coordsSize_ } count:2]);
  IOSObjectArray *intersectPoints = [crossHelper findCrossing];
  
#line 747
  if (((IOSObjectArray *) nil_chk(intersectPoints))->size_ == 0) {
    if ([self containsWithHarmonyJavaAwtGeomRectangle2D:[area getBounds2D]]) {
      HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, area, self);
      return;
    }
    return;
  }
  
#line 755
  IOSDoubleArray *resultCoords = [IOSDoubleArray newArrayWithLength:2 * (self->coordsSize_ + area->coordsSize_ + intersectPoints->size_)];
  IOSIntArray *resultRules = [IOSIntArray newArrayWithLength:2 * (self->rulesSize_ + area->rulesSize_ + intersectPoints->size_)];
  IOSIntArray *resultOffsets = [IOSIntArray newArrayWithLength:2 * (self->rulesSize_ + area->rulesSize_ + intersectPoints->size_)];
  jint resultCoordPos = 0;
  jint resultRulesPos = 0;
  jboolean isCurrentArea = true;
  jint countPoints = 0;
  jboolean curArea = false;
  jboolean addArea = false;
  
#line 765
  ComIntersectPoint *point = IOSObjectArray_Get(intersectPoints, 0);
  *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_MOVETO;
  *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
  
#line 769
  do {
    *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [((ComIntersectPoint *) nil_chk(point)) getX];
    *IOSDoubleArray_GetRef(resultCoords, resultCoordPos++) = [point getY];
    *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
    *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos - 2;
    jint curIndex = [point getEndIndexWithBoolean:true];
    
#line 776
    if (curIndex < 0 || (
#line 777
    HarmonyJavaAwtGeomArea_isVertexWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1)) &&
#line 778
    [crossHelper containsPointWithDoubleArray:[IOSDoubleArray newArrayWithDoubles:(jdouble[]){ IOSDoubleArray_Get(nil_chk(
#line 779
    self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1) } count:2]] && (IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex) != [point getX] ||
#line 780
    IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex + 1) != [point getY]))) {
      isCurrentArea = !isCurrentArea;
    }
    else
#line 782
    if (HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(area, IOSDoubleArray_Get(nil_chk(self->coords_), 2 * curIndex), IOSDoubleArray_Get(self->coords_, 2 * curIndex + 1)) > 0) {
      isCurrentArea = false;
    }
    else {
      
#line 785
      isCurrentArea = true;
    }
    
#line 788
    if (countPoints >= intersectPoints->size_) {
      isCurrentArea = !isCurrentArea;
    }
    
#line 792
    if (isCurrentArea) {
      curArea = true;
    }
    else {
      
#line 795
      addArea = true;
    }
    
#line 798
    ComIntersectPoint *nextPoint = isCurrentArea ? HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self, intersectPoints, point, isCurrentArea) : HarmonyJavaAwtGeomArea_getPrevIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(self,
#line 799
    intersectPoints, point, isCurrentArea);
    IOSDoubleArray *coords = isCurrentArea ? self->coords_ : area->coords_;
    
#line 802
    jint offset = isCurrentArea ? 2 * [point getEndIndexWithBoolean:isCurrentArea] : 2 * [nextPoint getEndIndexWithBoolean:
#line 803
    isCurrentArea];
    
#line 805
    if (offset > 0 &&
#line 806
    ((isCurrentArea && [nextPoint getBegIndexWithBoolean:isCurrentArea] < [point getEndIndexWithBoolean:isCurrentArea]) || (!isCurrentArea && [nextPoint getEndIndexWithBoolean:
#line 807
    isCurrentArea] < [nextPoint getBegIndexWithBoolean:isCurrentArea]))) {
      
#line 809
      jint coordSize = isCurrentArea ? self->coordsSize_ : area->coordsSize_;
      jint length = coordSize - offset;
      
#line 812
      if (isCurrentArea) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, offset, resultCoords, resultCoordPos, length);
      }
      else {
        
#line 815
        IOSDoubleArray *temp = [IOSDoubleArray newArrayWithLength:length];
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, offset, temp, 0, length);
        HarmonyJavaAwtGeomArea_reverseCopyWithDoubleArray_(self, temp);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(temp, 0, resultCoords, resultCoordPos, length);
      }
      
#line 821
      for (jint i = 0; i < JreIntDiv(length, 2); i++) {
        *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
        *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
        resultCoordPos += 2;
      }
      
#line 827
      offset = 0;
    }
    
#line 830
    if (offset >= 0) {
      jint length = isCurrentArea ? 2 * [nextPoint getBegIndexWithBoolean:isCurrentArea] - offset + 2 : 2 *
#line 832
      [point getBegIndexWithBoolean:isCurrentArea] - offset + 2;
      
#line 834
      if (isCurrentArea) {
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, offset, resultCoords, resultCoordPos, length);
      }
      else {
        
#line 837
        IOSDoubleArray *temp = [IOSDoubleArray newArrayWithLength:length];
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, offset, temp, 0, length);
        HarmonyJavaAwtGeomArea_reverseCopyWithDoubleArray_(self, temp);
        JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(temp, 0, resultCoords, resultCoordPos, length);
      }
      
#line 843
      for (jint i = 0; i < JreIntDiv(length, 2); i++) {
        *IOSIntArray_GetRef(resultRules, resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
        *IOSIntArray_GetRef(resultOffsets, resultRulesPos++) = resultCoordPos;
        resultCoordPos += 2;
      }
    }
    
#line 850
    point = nextPoint;
    countPoints++;
  }
  while (
#line 852
  !JreObjectEqualsEquals(point, IOSObjectArray_Get(intersectPoints, 0)) || !(curArea && addArea));
  
#line 854
  *IOSIntArray_GetRef(resultRules, resultRulesPos - 1) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
  *IOSIntArray_GetRef(resultOffsets, resultRulesPos - 1) = resultCoordPos;
  self->coords_ = resultCoords;
  self->rules_ = resultRules;
  self->offsets_ = resultOffsets;
  self->coordsSize_ = resultCoordPos;
  self->rulesSize_ = resultRulesPos;
}


#line 863
ComIntersectPoint *HarmonyJavaAwtGeomArea_getNextIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(HarmonyJavaAwtGeomArea *self, IOSObjectArray *iPoints, ComIntersectPoint *isectPoint, jboolean isCurrentArea) {
  
#line 865
  jint endIndex = [((ComIntersectPoint *) nil_chk(isectPoint)) getEndIndexWithBoolean:isCurrentArea];
  if (endIndex < 0) {
    return IOSObjectArray_Get(nil_chk(iPoints), JavaLangMath_absWithInt_(endIndex) - 1);
  }
  
#line 870
  ComIntersectPoint *firstIsectPoint = nil;
  ComIntersectPoint *nextIsectPoint = nil;
  {
    IOSObjectArray *a__ =
#line 872
    iPoints;
    ComIntersectPoint * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    ComIntersectPoint * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      ComIntersectPoint *point = *b__++;
      
#line 873
      jint begIndex = [((ComIntersectPoint *) nil_chk(point)) getBegIndexWithBoolean:isCurrentArea];
      
#line 875
      if (begIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else
#line 878
        if (begIndex < [firstIsectPoint getBegIndexWithBoolean:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      
#line 883
      if (endIndex <= begIndex) {
        if (nextIsectPoint == nil) {
          nextIsectPoint = point;
        }
        else
#line 886
        if (begIndex < [nextIsectPoint getBegIndexWithBoolean:isCurrentArea]) {
          nextIsectPoint = point;
        }
      }
    }
  }
  return nextIsectPoint != nil ? nextIsectPoint : firstIsectPoint;
}


#line 895
ComIntersectPoint *HarmonyJavaAwtGeomArea_getPrevIntersectPointWithComIntersectPointArray_withComIntersectPoint_withBoolean_(HarmonyJavaAwtGeomArea *self, IOSObjectArray *iPoints, ComIntersectPoint *isectPoint, jboolean isCurrentArea) {
  
#line 898
  jint begIndex = [((ComIntersectPoint *) nil_chk(isectPoint)) getBegIndexWithBoolean:isCurrentArea];
  
#line 900
  if (begIndex < 0) {
    return IOSObjectArray_Get(nil_chk(iPoints), JavaLangMath_absWithInt_(begIndex) - 1);
  }
  
#line 904
  ComIntersectPoint *firstIsectPoint = nil;
  ComIntersectPoint *predIsectPoint = nil;
  {
    IOSObjectArray *a__ =
#line 906
    iPoints;
    ComIntersectPoint * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    ComIntersectPoint * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      ComIntersectPoint *point = *b__++;
      
#line 907
      jint endIndex = [((ComIntersectPoint *) nil_chk(point)) getEndIndexWithBoolean:isCurrentArea];
      
#line 909
      if (endIndex >= 0) {
        if (firstIsectPoint == nil) {
          firstIsectPoint = point;
        }
        else
#line 912
        if (endIndex < [firstIsectPoint getEndIndexWithBoolean:isCurrentArea]) {
          firstIsectPoint = point;
        }
      }
      
#line 917
      if (endIndex <= begIndex) {
        if (predIsectPoint == nil) {
          predIsectPoint = point;
        }
        else
#line 920
        if (endIndex > [predIsectPoint getEndIndexWithBoolean:isCurrentArea]) {
          predIsectPoint = point;
        }
      }
    }
  }
  return predIsectPoint != nil ? predIsectPoint : firstIsectPoint;
}


#line 929
jint HarmonyJavaAwtGeomArea_includeCoordsAndRulesWithInt_withInt_withIntArray_withIntArray_withIntArray_withIntArray_withDoubleArray_withDoubleArray_withInt_withInt_withComIntersectPoint_withBoolean_withBoolean_withInt_(HarmonyJavaAwtGeomArea *self, jint offset, jint length, IOSIntArray *rules, IOSIntArray *offsets, IOSIntArray *resultRules, IOSIntArray *resultOffsets, IOSDoubleArray *resultCoords, IOSDoubleArray *coords, jint resultRulesPos, jint resultCoordPos, ComIntersectPoint *point, jboolean isCurrentArea, jboolean way, jint operation) {
  
#line 933
  IOSDoubleArray *temp = [IOSDoubleArray newArrayWithLength:8 * length];
  jint coordsCount = 0;
  jboolean isMoveIndex = true;
  jboolean isMoveLength = true;
  jboolean additional = false;
  
#line 939
  if (length <= offset) {
    for (jint i = resultRulesPos; i < resultRulesPos + 1; i++) {
      *IOSIntArray_GetRef(nil_chk(resultRules), i) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
    }
  }
  else {
    
#line 944
    jint j = resultRulesPos;
    for (jint i = offset; i < length; i++) {
      *IOSIntArray_GetRef(nil_chk(resultRules), j++) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
    }
  }
  
#line 950
  if (length == offset &&
#line 951
  (IOSIntArray_Get(nil_chk(rules), offset) == HarmonyJavaAwtGeomPathIterator_SEG_QUADTO || IOSIntArray_Get(rules, offset) == HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO)) {
    length++;
    additional = true;
  }
  for (jint i = offset; i < length; i++) {
    jint index = IOSIntArray_Get(nil_chk(offsets), i);
    
#line 958
    if (!isMoveIndex) {
      index -= 2;
    }
    
#line 962
    if (!isMoveLength) {
      length++;
      isMoveLength = true;
    }
    {
      
#line 976
      jboolean isLeft;
      
#line 986
      IOSDoubleArray *coefs;
      
#line 967
      switch (IOSIntArray_Get(nil_chk(rules), i)) {
        case HarmonyJavaAwtGeomPathIterator_SEG_MOVETO:
        isMoveIndex = false;
        isMoveLength = false;
        break;
        case HarmonyJavaAwtGeomPathIterator_SEG_LINETO:
        case HarmonyJavaAwtGeomPathIterator_SEG_CLOSE:
        *IOSIntArray_GetRef(nil_chk(resultRules), resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
        *IOSIntArray_GetRef(nil_chk(resultOffsets), resultRulesPos++) = resultCoordPos + 2;
        isLeft = (ComCrossingHelper_compareWithDouble_withDouble_withDouble_withDouble_(IOSDoubleArray_Get(nil_chk(coords), index), IOSDoubleArray_Get(coords, index + 1), [((ComIntersectPoint *) nil_chk(point)) getX], [point getY]) > 0);
        
#line 978
        if (way || !isLeft) {
          *IOSDoubleArray_GetRef(temp, coordsCount++) = IOSDoubleArray_Get(coords, index);
          *IOSDoubleArray_GetRef(temp, coordsCount++) = IOSDoubleArray_Get(coords, index + 1);
        }
        break;
        case HarmonyJavaAwtGeomPathIterator_SEG_QUADTO:
        *IOSIntArray_GetRef(nil_chk(resultRules), resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_QUADTO;
        *IOSIntArray_GetRef(nil_chk(resultOffsets), resultRulesPos++) = resultCoordPos + 4;
        coefs = [IOSDoubleArray newArrayWithDoubles:(jdouble[]){ IOSDoubleArray_Get(nil_chk(coords), index - 2), IOSDoubleArray_Get(coords, index - 1), IOSDoubleArray_Get(coords, index), IOSDoubleArray_Get(coords, index + 1), IOSDoubleArray_Get(
#line 987
        coords, index + 2), IOSDoubleArray_Get(coords, index + 3) } count:6];
        isLeft = (ComCrossingHelper_compareWithDouble_withDouble_withDouble_withDouble_(IOSDoubleArray_Get(coords, index - 2), IOSDoubleArray_Get(coords, index - 1), [((ComIntersectPoint *) nil_chk(point)) getX], [point getY]) > 0);
        
#line 990
        if (!additional && (operation == 0 || operation == 2)) {
          isLeft = !isLeft;
          way = false;
        }
        ComGeometryUtil_subQuadWithDoubleArray_withDouble_withBoolean_(coefs, [point getParamWithBoolean:isCurrentArea], isLeft);
        
#line 996
        if (way || isLeft) {
          *IOSDoubleArray_GetRef(temp, coordsCount++) = IOSDoubleArray_Get(coefs, 2);
          *IOSDoubleArray_GetRef(temp, coordsCount++) = IOSDoubleArray_Get(coefs, 3);
        }
        else {
          
#line 1000
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coefs, 2, temp, coordsCount, 4);
          coordsCount += 4;
        }
        break;
        case HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO:
        *IOSIntArray_GetRef(nil_chk(resultRules), resultRulesPos) = HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO;
        *IOSIntArray_GetRef(nil_chk(resultOffsets), resultRulesPos++) = resultCoordPos + 6;
        coefs = [IOSDoubleArray newArrayWithDoubles:(jdouble[]){ IOSDoubleArray_Get(nil_chk(coords), index - 2), IOSDoubleArray_Get(coords, index - 1), IOSDoubleArray_Get(coords, index), IOSDoubleArray_Get(coords, index + 1), IOSDoubleArray_Get(
#line 1008
        coords, index + 2), IOSDoubleArray_Get(coords, index + 3), IOSDoubleArray_Get(coords, index + 4), IOSDoubleArray_Get(coords, index + 5) } count:8];
        isLeft = (ComCrossingHelper_compareWithDouble_withDouble_withDouble_withDouble_(IOSDoubleArray_Get(coords, index - 2), IOSDoubleArray_Get(coords, index - 1), [((ComIntersectPoint *) nil_chk(point)) getX], [point getY]) > 0);
        ComGeometryUtil_subCubicWithDoubleArray_withDouble_withBoolean_(coefs, [point getParamWithBoolean:isCurrentArea], !isLeft);
        
#line 1012
        if (isLeft) {
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coefs, 2, temp, coordsCount, 6);
          coordsCount += 6;
        }
        else {
          
#line 1016
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coefs, 2, temp, coordsCount, 4);
          coordsCount += 4;
        }
        break;
      }
    }
  }
  if (operation == 2 && !isCurrentArea && coordsCount > 2) {
    HarmonyJavaAwtGeomArea_reverseCopyWithDoubleArray_(self, temp);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(temp, 0, resultCoords, resultCoordPos, coordsCount);
  }
  else {
    
#line 1027
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(temp, 0, resultCoords, resultCoordPos, coordsCount);
  }
  
#line 1030
  return resultCoordPos + coordsCount;
}


#line 1034
IOSDoubleArray *HarmonyJavaAwtGeomArea_adjustSizeWithDoubleArray_withInt_(IOSDoubleArray *array, jint newSize) {
  HarmonyJavaAwtGeomArea_initialize();
  
#line 1035
  if (newSize <= ((IOSDoubleArray *) nil_chk(array))->size_) {
    return array;
  }
  IOSDoubleArray *newArray = [IOSDoubleArray newArrayWithLength:2 * newSize];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(array, 0, newArray, 0, array->size_);
  return newArray;
}


#line 1043
IOSIntArray *HarmonyJavaAwtGeomArea_adjustSizeWithIntArray_withInt_(IOSIntArray *array, jint newSize) {
  HarmonyJavaAwtGeomArea_initialize();
  
#line 1044
  if (newSize <= ((IOSIntArray *) nil_chk(array))->size_) {
    return array;
  }
  IOSIntArray *newArray = [IOSIntArray newArrayWithLength:2 * newSize];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(array, 0, newArray, 0, array->size_);
  return newArray;
}


#line 1052
void HarmonyJavaAwtGeomArea_copy__WithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *self, HarmonyJavaAwtGeomArea *src, HarmonyJavaAwtGeomArea *dst) {
  ((HarmonyJavaAwtGeomArea *) nil_chk(dst))->coordsSize_ = ((HarmonyJavaAwtGeomArea *) nil_chk(src))->coordsSize_;
  dst->coords_ = [((IOSDoubleArray *) nil_chk(src->coords_)) java_clone];
  dst->rulesSize_ = src->rulesSize_;
  dst->rules_ = [((IOSIntArray *) nil_chk(src->rules_)) java_clone];
  dst->moveToCount_ = src->moveToCount_;
  dst->offsets_ = [((IOSIntArray *) nil_chk(src->offsets_)) java_clone];
}

jint HarmonyJavaAwtGeomArea_containsExactWithDouble_withDouble_(HarmonyJavaAwtGeomArea *self, jdouble x, jdouble y) {
  id<HarmonyJavaAwtGeomPathIterator> pi = [self getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:nil];
  jint crossCount = ComCrossing_crossPathWithHarmonyJavaAwtGeomPathIterator_withDouble_withDouble_(pi, x, y);
  
#line 1065
  if (ComCrossing_isInsideEvenOddWithInt_(crossCount)) {
    return 1;
  }
  
#line 1069
  IOSDoubleArray *segmentCoords = [IOSDoubleArray newArrayWithLength:6];
  IOSDoubleArray *resultPoints = [IOSDoubleArray newArrayWithLength:6];
  jint rule;
  jdouble curX = -1;
  jdouble curY = -1;
  jdouble moveX = -1;
  jdouble moveY = -1;
  
#line 1077
  for (pi = [self getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:nil]; ![((id<HarmonyJavaAwtGeomPathIterator>) nil_chk(pi)) isDone]; [pi next]) {
    rule = [pi currentSegmentWithDoubleArray:segmentCoords];
    switch (rule) {
      case HarmonyJavaAwtGeomPathIterator_SEG_MOVETO:
      moveX = curX = IOSDoubleArray_Get(segmentCoords, 0);
      moveY = curY = IOSDoubleArray_Get(segmentCoords, 1);
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_LINETO:
      if (ComGeometryUtil_intersectLinesWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDoubleArray_(curX, curY, IOSDoubleArray_Get(segmentCoords, 0), IOSDoubleArray_Get(segmentCoords, 1), x, y, x, y,
#line 1086
      resultPoints) != 0) {
        return 0;
      }
      curX = IOSDoubleArray_Get(segmentCoords, 0);
      curY = IOSDoubleArray_Get(segmentCoords, 1);
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_QUADTO:
      if (ComGeometryUtil_intersectLineAndQuadWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDoubleArray_(x, y, x, y, curX, curY, IOSDoubleArray_Get(segmentCoords, 0), IOSDoubleArray_Get(segmentCoords, 1), IOSDoubleArray_Get(
#line 1094
      segmentCoords, 2), IOSDoubleArray_Get(segmentCoords, 3), resultPoints) > 0) {
        return 0;
      }
      curX = IOSDoubleArray_Get(segmentCoords, 2);
      curY = IOSDoubleArray_Get(segmentCoords, 3);
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO:
      if (ComGeometryUtil_intersectLineAndCubicWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDoubleArray_(x, y, x, y, curX, curY, IOSDoubleArray_Get(segmentCoords, 0), IOSDoubleArray_Get(segmentCoords, 1), IOSDoubleArray_Get(
#line 1102
      segmentCoords, 2), IOSDoubleArray_Get(segmentCoords, 3), IOSDoubleArray_Get(segmentCoords, 4), IOSDoubleArray_Get(segmentCoords, 5), resultPoints) > 0) {
        return 0;
      }
      curX = IOSDoubleArray_Get(segmentCoords, 4);
      curY = IOSDoubleArray_Get(segmentCoords, 5);
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_CLOSE:
      if (ComGeometryUtil_intersectLinesWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDouble_withDoubleArray_(curX, curY, moveX, moveY, x, y, x, y, resultPoints) != 0) {
        return 0;
      }
      curX = moveX;
      curY = moveY;
      break;
    }
  }
  return -1;
}


#line 1120
void HarmonyJavaAwtGeomArea_reverseCopyWithDoubleArray_(HarmonyJavaAwtGeomArea *self, IOSDoubleArray *coords) {
  IOSDoubleArray *temp = [IOSDoubleArray newArrayWithLength:((IOSDoubleArray *) nil_chk(coords))->size_];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(coords, 0, temp, 0, coords->size_);
  
#line 1124
  for (jint i = 0; i < coords->size_; ) {
    *IOSDoubleArray_GetRef(coords, i) = IOSDoubleArray_Get(temp, coords->size_ - i - 2);
    *IOSDoubleArray_GetRef(coords, i + 1) = IOSDoubleArray_Get(temp, coords->size_ - i - 1);
    i = i + 2;
  }
}


#line 1131
jdouble HarmonyJavaAwtGeomArea_getAreaBoundsSquare(HarmonyJavaAwtGeomArea *self) {
  HarmonyJavaAwtGeomRectangle2D *bounds = [self getBounds2D];
  return [((HarmonyJavaAwtGeomRectangle2D *) nil_chk(bounds)) getHeight] * [bounds getWidth];
}

jboolean HarmonyJavaAwtGeomArea_isVertexWithDouble_withDouble_(HarmonyJavaAwtGeomArea *self, jdouble x, jdouble y) {
  for (jint i = 0; i < self->coordsSize_; ) {
    if (x == IOSDoubleArray_Get(nil_chk(self->coords_), i++) && y == IOSDoubleArray_Get(self->coords_, i++)) {
      return true;
    }
  }
  return false;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(HarmonyJavaAwtGeomArea)

#line 1 "/Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/harmony/java/awt/geom/Area.java"


#line 1146
@implementation HarmonyJavaAwtGeomArea_AreaPathIterator


#line 1153
- (instancetype)initWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)outer$
                    withHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area {
  HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(self, outer$, area);
  return self;
}


#line 1157
- (instancetype)initWithHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)outer$
                    withHarmonyJavaAwtGeomArea:(HarmonyJavaAwtGeomArea *)area
         withHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t {
  HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(self, outer$, area, t);
  return self;
}


#line 1162
- (jint)getWindingRule {
  
#line 1164
  return HarmonyJavaAwtGeomPathIterator_WIND_EVEN_ODD;
}


#line 1167
- (jboolean)isDone {
  
#line 1169
  return self->curRuleIndex_ >= this$0_->rulesSize_;
}


#line 1172
- (void)next {
  
#line 1174
  switch (IOSIntArray_Get(nil_chk(this$0_->rules_), self->curRuleIndex_)) {
    case HarmonyJavaAwtGeomPathIterator_SEG_MOVETO:
    case HarmonyJavaAwtGeomPathIterator_SEG_LINETO:
    self->curCoordIndex_ += 2;
    break;
    case HarmonyJavaAwtGeomPathIterator_SEG_QUADTO:
    self->curCoordIndex_ += 4;
    break;
    case HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO:
    self->curCoordIndex_ += 6;
    break;
  }
  self->curRuleIndex_++;
}


#line 1189
- (jint)currentSegmentWithDoubleArray:(IOSDoubleArray *)c {
  
#line 1191
  if ([self isDone]) {
    @throw new_JavaUtilNoSuchElementException_initWithNSString_(ComMessages_getStringWithNSString_(@"awt.4B"));
  }
  
#line 1195
  jint count = 0;
  
#line 1197
  switch (IOSIntArray_Get(nil_chk(this$0_->rules_), self->curRuleIndex_)) {
    case HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO:
    *IOSDoubleArray_GetRef(nil_chk(c), 4) = IOSDoubleArray_Get(nil_chk(this$0_->coords_), self->curCoordIndex_ + 4);
    *IOSDoubleArray_GetRef(c, 5) = IOSDoubleArray_Get(this$0_->coords_, self->curCoordIndex_ + 5);
    count = 1;
    case HarmonyJavaAwtGeomPathIterator_SEG_QUADTO:
    *IOSDoubleArray_GetRef(nil_chk(c), 2) = IOSDoubleArray_Get(nil_chk(this$0_->coords_), self->curCoordIndex_ + 2);
    *IOSDoubleArray_GetRef(c, 3) = IOSDoubleArray_Get(this$0_->coords_, self->curCoordIndex_ + 3);
    count += 1;
    case HarmonyJavaAwtGeomPathIterator_SEG_MOVETO:
    case HarmonyJavaAwtGeomPathIterator_SEG_LINETO:
    *IOSDoubleArray_GetRef(nil_chk(c), 0) = IOSDoubleArray_Get(nil_chk(this$0_->coords_), self->curCoordIndex_);
    *IOSDoubleArray_GetRef(c, 1) = IOSDoubleArray_Get(this$0_->coords_, self->curCoordIndex_ + 1);
    count += 1;
  }
  
#line 1213
  if (self->transform_ != nil) {
    [self->transform_ transformWithDoubleArray:c withInt:0 withDoubleArray:c withInt:0 withInt:count];
  }
  
#line 1217
  return IOSIntArray_Get(nil_chk(this$0_->rules_), self->curRuleIndex_);
}


#line 1220
- (jint)currentSegmentWithFloatArray:(IOSFloatArray *)c {
  
#line 1222
  IOSDoubleArray *doubleCoords = [IOSDoubleArray newArrayWithLength:6];
  jint rule = [self currentSegmentWithDoubleArray:doubleCoords];
  
#line 1225
  for (jint i = 0; i < 6; i++) {
    *IOSFloatArray_GetRef(nil_chk(c), i) = (jfloat) IOSDoubleArray_Get(doubleCoords, i);
  }
  return rule;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 4, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithHarmonyJavaAwtGeomArea:withHarmonyJavaAwtGeomArea:);
  methods[1].selector = @selector(initWithHarmonyJavaAwtGeomArea:withHarmonyJavaAwtGeomArea:withHarmonyJavaAwtGeomAffineTransform:);
  methods[2].selector = @selector(getWindingRule);
  methods[3].selector = @selector(isDone);
  methods[4].selector = @selector(next);
  methods[5].selector = @selector(currentSegmentWithDoubleArray:);
  methods[6].selector = @selector(currentSegmentWithFloatArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", "LHarmonyJavaAwtGeomArea;", .constantValue.asLong = 0, 0x1012, -1, -1, -1, -1 },
    { "transform_", "LHarmonyJavaAwtGeomAffineTransform;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "area_", "LHarmonyJavaAwtGeomArea;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "curRuleIndex_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "curCoordIndex_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LHarmonyJavaAwtGeomArea;LHarmonyJavaAwtGeomArea;", "LHarmonyJavaAwtGeomArea;LHarmonyJavaAwtGeomArea;LHarmonyJavaAwtGeomAffineTransform;", "currentSegment", "[D", "[F", "LHarmonyJavaAwtGeomArea;" };
  static const J2ObjcClassInfo _HarmonyJavaAwtGeomArea_AreaPathIterator = { "AreaPathIterator", "harmony.java.awt.geom", ptrTable, methods, fields, 7, 0x2, 7, 5, 5, -1, -1, -1, -1 };
  return &_HarmonyJavaAwtGeomArea_AreaPathIterator;
}

@end


#line 1153
void HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea_AreaPathIterator *self, HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area) {
  HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(self, outer$, area, nil);
}


#line 1153
HarmonyJavaAwtGeomArea_AreaPathIterator *new_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomArea_AreaPathIterator, initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_, outer$, area)
}


#line 1153
HarmonyJavaAwtGeomArea_AreaPathIterator *create_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_(HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomArea_AreaPathIterator, initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_, outer$, area)
}

void HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomArea_AreaPathIterator *self, HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area, HarmonyJavaAwtGeomAffineTransform *t) {
  self->this$0_ = outer$;
  NSObject_init(self);
  self->curRuleIndex_ =
#line 1150
  0;
  self->curCoordIndex_ = 0;
  
#line 1158
  self->area_ = area;
  self->transform_ = t;
}


#line 1157
HarmonyJavaAwtGeomArea_AreaPathIterator *new_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area, HarmonyJavaAwtGeomAffineTransform *t) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomArea_AreaPathIterator, initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_, outer$, area, t)
}


#line 1157
HarmonyJavaAwtGeomArea_AreaPathIterator *create_HarmonyJavaAwtGeomArea_AreaPathIterator_initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomArea *outer$, HarmonyJavaAwtGeomArea *area, HarmonyJavaAwtGeomAffineTransform *t) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomArea_AreaPathIterator, initWithHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomArea_withHarmonyJavaAwtGeomAffineTransform_, outer$, area, t)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(HarmonyJavaAwtGeomArea_AreaPathIterator)
