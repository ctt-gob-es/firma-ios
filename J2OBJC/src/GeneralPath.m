//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/harmony/java/awt/geom/GeneralPath.java
//

#include "AWTRectangle.h"
#include "AffineTransform.h"
#include "Crossing.h"
#include "FlatteningPathIterator.h"
#include "GeneralPath.h"
#include "IOSPrimitiveArray.h"
#include "IllegalPathStateException.h"
#include "J2ObjC_source.h"
#include "Messages.h"
#include "PathIterator.h"
#include "Point2D.h"
#include "Rectangle2D.h"
#include "Shape.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/InternalError.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/NoSuchElementException.h"

#if !__has_feature(objc_arc)
#error "GeneralPath must be compiled with ARC (-fobjc-arc)"
#endif

/*!
 @brief The buffers size
 */
inline jint HarmonyJavaAwtGeomGeneralPath_get_BUFFER_SIZE(void);
#define HarmonyJavaAwtGeomGeneralPath_BUFFER_SIZE 10
J2OBJC_STATIC_FIELD_CONSTANT(HarmonyJavaAwtGeomGeneralPath, BUFFER_SIZE, jint)

/*!
 @brief The buffers capacity
 */
inline jint HarmonyJavaAwtGeomGeneralPath_get_BUFFER_CAPACITY(void);
#define HarmonyJavaAwtGeomGeneralPath_BUFFER_CAPACITY 10
J2OBJC_STATIC_FIELD_CONSTANT(HarmonyJavaAwtGeomGeneralPath, BUFFER_CAPACITY, jint)

#line 1 "/Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/harmony/java/awt/geom/GeneralPath.java"

J2OBJC_INITIALIZED_DEFN(HarmonyJavaAwtGeomGeneralPath)

IOSIntArray *HarmonyJavaAwtGeomGeneralPath_pointShift;


#line 30
@implementation HarmonyJavaAwtGeomGeneralPath

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 174
- (instancetype)init {
  HarmonyJavaAwtGeomGeneralPath_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 178
- (instancetype)initWithInt:(jint)rule {
  HarmonyJavaAwtGeomGeneralPath_initWithInt_(self, rule);
  return self;
}


#line 182
- (instancetype)initWithInt:(jint)rule
                    withInt:(jint)initialCapacity {
  HarmonyJavaAwtGeomGeneralPath_initWithInt_withInt_(self, rule, initialCapacity);
  return self;
}

- (instancetype)initWithHarmonyJavaAwtShape:(id<HarmonyJavaAwtShape>)shape {
  HarmonyJavaAwtGeomGeneralPath_initWithHarmonyJavaAwtShape_(self, shape);
  return self;
}


#line 195
- (void)setWindingRuleWithInt:(jint)rule {
  if (rule != HarmonyJavaAwtGeomGeneralPath_WIND_EVEN_ODD && rule != HarmonyJavaAwtGeomGeneralPath_WIND_NON_ZERO) {
    
#line 198
    @throw new_JavaLangIllegalArgumentException_initWithNSString_(ComMessages_getStringWithNSString_(@"awt.209"));
  }
  self->rule_ = rule;
}


#line 203
- (jint)getWindingRule {
  return rule_;
}


#line 214
- (void)checkBufWithInt:(jint)pointCount
            withBoolean:(jboolean)checkMove {
  
#line 215
  if (checkMove && typeSize_ == 0) {
    
#line 217
    @throw new_HarmonyJavaAwtGeomIllegalPathStateException_initWithNSString_(ComMessages_getStringWithNSString_(@"awt.20A"));
  }
  if (typeSize_ == ((IOSByteArray *) nil_chk(types_))->size_) {
    IOSByteArray *tmp = [IOSByteArray newArrayWithLength:typeSize_ + HarmonyJavaAwtGeomGeneralPath_BUFFER_CAPACITY];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(types_, 0, tmp, 0, typeSize_);
    types_ = tmp;
  }
  if (pointSize_ + pointCount > ((IOSFloatArray *) nil_chk(points_))->size_) {
    IOSFloatArray *tmp = [IOSFloatArray newArrayWithLength:pointSize_ + JavaLangMath_maxWithInt_withInt_(HarmonyJavaAwtGeomGeneralPath_BUFFER_CAPACITY * 2, pointCount)];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(points_, 0, tmp, 0, pointSize_);
    points_ = tmp;
  }
}


#line 231
- (void)moveToWithFloat:(jfloat)x
              withFloat:(jfloat)y {
  
#line 232
  if (typeSize_ > 0 && IOSByteArray_Get(nil_chk(types_), typeSize_ - 1) == HarmonyJavaAwtGeomPathIterator_SEG_MOVETO) {
    *IOSFloatArray_GetRef(nil_chk(points_), pointSize_ - 2) = x;
    *IOSFloatArray_GetRef(points_, pointSize_ - 1) = y;
  }
  else {
    
#line 236
    [self checkBufWithInt:2 withBoolean:false];
    *IOSByteArray_GetRef(nil_chk(types_), typeSize_++) = HarmonyJavaAwtGeomPathIterator_SEG_MOVETO;
    *IOSFloatArray_GetRef(nil_chk(points_), pointSize_++) = x;
    *IOSFloatArray_GetRef(points_, pointSize_++) = y;
  }
}


#line 243
- (void)lineToWithFloat:(jfloat)x
              withFloat:(jfloat)y {
  
#line 244
  [self checkBufWithInt:2 withBoolean:true];
  *IOSByteArray_GetRef(nil_chk(types_), typeSize_++) = HarmonyJavaAwtGeomPathIterator_SEG_LINETO;
  *IOSFloatArray_GetRef(nil_chk(points_), pointSize_++) = x;
  *IOSFloatArray_GetRef(points_, pointSize_++) = y;
}


#line 250
- (void)quadToWithFloat:(jfloat)x1
              withFloat:(jfloat)y1
              withFloat:(jfloat)x2
              withFloat:(jfloat)y2 {
  
#line 251
  [self checkBufWithInt:4 withBoolean:true];
  *IOSByteArray_GetRef(nil_chk(types_), typeSize_++) = HarmonyJavaAwtGeomPathIterator_SEG_QUADTO;
  *IOSFloatArray_GetRef(nil_chk(points_), pointSize_++) = x1;
  *IOSFloatArray_GetRef(points_, pointSize_++) = y1;
  *IOSFloatArray_GetRef(points_, pointSize_++) = x2;
  *IOSFloatArray_GetRef(points_, pointSize_++) = y2;
}


#line 259
- (void)curveToWithFloat:(jfloat)x1
               withFloat:(jfloat)y1
               withFloat:(jfloat)x2
               withFloat:(jfloat)y2
               withFloat:(jfloat)x3
               withFloat:(jfloat)y3 {
  
#line 260
  [self checkBufWithInt:6 withBoolean:true];
  *IOSByteArray_GetRef(nil_chk(types_), typeSize_++) = HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO;
  *IOSFloatArray_GetRef(nil_chk(points_), pointSize_++) = x1;
  *IOSFloatArray_GetRef(points_, pointSize_++) = y1;
  *IOSFloatArray_GetRef(points_, pointSize_++) = x2;
  *IOSFloatArray_GetRef(points_, pointSize_++) = y2;
  *IOSFloatArray_GetRef(points_, pointSize_++) = x3;
  *IOSFloatArray_GetRef(points_, pointSize_++) = y3;
}


#line 270
- (void)closePath {
  if (typeSize_ == 0 || IOSByteArray_Get(nil_chk(types_), typeSize_ - 1) != HarmonyJavaAwtGeomPathIterator_SEG_CLOSE) {
    [self checkBufWithInt:0 withBoolean:true];
    *IOSByteArray_GetRef(nil_chk(types_), typeSize_++) = HarmonyJavaAwtGeomPathIterator_SEG_CLOSE;
  }
}

- (void)appendWithHarmonyJavaAwtShape:(id<HarmonyJavaAwtShape>)shape
                          withBoolean:(jboolean)connect {
  
#line 278
  id<HarmonyJavaAwtGeomPathIterator> p = [((id<HarmonyJavaAwtShape>) nil_chk(shape)) getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:nil];
  [self appendWithHarmonyJavaAwtGeomPathIterator:p withBoolean:connect];
}


#line 282
- (void)appendWithHarmonyJavaAwtGeomPathIterator:(id<HarmonyJavaAwtGeomPathIterator>)path
                                     withBoolean:(jboolean)connect {
  
#line 283
  while (![((id<HarmonyJavaAwtGeomPathIterator>) nil_chk(path)) isDone]) {
    IOSFloatArray *coords = [IOSFloatArray newArrayWithLength:6];
    switch ([path currentSegmentWithFloatArray:coords]) {
      case HarmonyJavaAwtGeomPathIterator_SEG_MOVETO:
      if (!connect || typeSize_ == 0) {
        [self moveToWithFloat:IOSFloatArray_Get(coords, 0) withFloat:IOSFloatArray_Get(coords, 1)];
        break;
      }
      if (IOSByteArray_Get(nil_chk(types_), typeSize_ - 1) != HarmonyJavaAwtGeomPathIterator_SEG_CLOSE && IOSFloatArray_Get(nil_chk(points_), pointSize_ - 2) == IOSFloatArray_Get(coords, 0) &&
#line 292
      IOSFloatArray_Get(points_, pointSize_ - 1) == IOSFloatArray_Get(coords, 1)) {
        break;
      }
      
#line 296
      case HarmonyJavaAwtGeomPathIterator_SEG_LINETO:
      [self lineToWithFloat:IOSFloatArray_Get(coords, 0) withFloat:IOSFloatArray_Get(coords, 1)];
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_QUADTO:
      [self quadToWithFloat:IOSFloatArray_Get(coords, 0) withFloat:IOSFloatArray_Get(coords, 1) withFloat:IOSFloatArray_Get(coords, 2) withFloat:IOSFloatArray_Get(coords, 3)];
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_CUBICTO:
      [self curveToWithFloat:IOSFloatArray_Get(coords, 0) withFloat:IOSFloatArray_Get(coords, 1) withFloat:IOSFloatArray_Get(coords, 2) withFloat:IOSFloatArray_Get(coords, 3) withFloat:IOSFloatArray_Get(coords, 4) withFloat:IOSFloatArray_Get(coords, 5)];
      break;
      case HarmonyJavaAwtGeomPathIterator_SEG_CLOSE:
      [self closePath];
      break;
    }
    [path next];
    connect = false;
  }
}


#line 314
- (HarmonyJavaAwtGeomPoint2D *)getCurrentPoint {
  if (typeSize_ == 0) {
    return nil;
  }
  jint j = pointSize_ - 2;
  if (IOSByteArray_Get(nil_chk(types_), typeSize_ - 1) == HarmonyJavaAwtGeomPathIterator_SEG_CLOSE) {
    
#line 321
    for (jint i = typeSize_ - 2; i > 0; i--) {
      jint type = IOSByteArray_Get(types_, i);
      if (type == HarmonyJavaAwtGeomPathIterator_SEG_MOVETO) {
        break;
      }
      j -= IOSIntArray_Get(nil_chk(HarmonyJavaAwtGeomGeneralPath_pointShift), type);
    }
  }
  return new_HarmonyJavaAwtGeomPoint2D_Float_initWithFloat_withFloat_(IOSFloatArray_Get(nil_chk(points_), j), IOSFloatArray_Get(points_, j + 1));
}


#line 332
- (void)reset {
  typeSize_ = 0;
  pointSize_ = 0;
}

- (void)transformWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t {
  [((HarmonyJavaAwtGeomAffineTransform *) nil_chk(t)) transformWithFloatArray:points_ withInt:0 withFloatArray:points_ withInt:0 withInt:JreIntDiv(pointSize_, 2)];
}

- (id<HarmonyJavaAwtShape>)createTransformedShapeWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t {
  HarmonyJavaAwtGeomGeneralPath *p = (HarmonyJavaAwtGeomGeneralPath *) cast_chk([self java_clone], [HarmonyJavaAwtGeomGeneralPath class]);
  if (t != nil) {
    [((HarmonyJavaAwtGeomGeneralPath *) nil_chk(p)) transformWithHarmonyJavaAwtGeomAffineTransform:t];
  }
  return p;
}

- (HarmonyJavaAwtGeomRectangle2D *)getBounds2D {
  jfloat rx1;
  
#line 350
  jfloat ry1;
  
#line 350
  jfloat rx2;
  
#line 350
  jfloat ry2;
  if (pointSize_ == 0) {
    rx1 = ry1 = rx2 = ry2 = 0.0f;
  }
  else {
    
#line 354
    jint i = pointSize_ - 1;
    ry1 = ry2 = IOSFloatArray_Get(nil_chk(points_), i--);
    rx1 = rx2 = IOSFloatArray_Get(points_, i--);
    while (i > 0) {
      jfloat y = IOSFloatArray_Get(points_, i--);
      jfloat x = IOSFloatArray_Get(points_, i--);
      if (x < rx1) {
        rx1 = x;
      }
      else
#line 362
      if (x > rx2) {
        rx2 = x;
      }
      if (y < ry1) {
        ry1 = y;
      }
      else
#line 367
      if (y > ry2) {
        ry2 = y;
      }
    }
  }
  return new_HarmonyJavaAwtGeomRectangle2D_Float_initWithFloat_withFloat_withFloat_withFloat_(rx1, ry1, rx2 - rx1, ry2 - ry1);
}


#line 375
- (HarmonyJavaAwtAWTRectangle *)getBounds {
  return [((HarmonyJavaAwtGeomRectangle2D *) nil_chk([self getBounds2D])) getBounds];
}


#line 387
- (jboolean)isInsideWithInt:(jint)cross {
  if (rule_ == HarmonyJavaAwtGeomGeneralPath_WIND_NON_ZERO) {
    return ComCrossing_isInsideNonZeroWithInt_(cross);
  }
  return ComCrossing_isInsideEvenOddWithInt_(cross);
}

- (jboolean)containsWithDouble:(jdouble)px
                    withDouble:(jdouble)py {
  
#line 395
  return [self isInsideWithInt:ComCrossing_crossShapeWithHarmonyJavaAwtShape_withDouble_withDouble_(self, px, py)];
}


#line 398
- (jboolean)containsWithDouble:(jdouble)rx
                    withDouble:(jdouble)ry
                    withDouble:(jdouble)rw
                    withDouble:(jdouble)rh {
  
#line 399
  jint cross = ComCrossing_intersectShapeWithHarmonyJavaAwtShape_withDouble_withDouble_withDouble_withDouble_(self, rx, ry, rw, rh);
  return cross != ComCrossing_CROSSING && [self isInsideWithInt:cross];
}


#line 403
- (jboolean)intersectsWithDouble:(jdouble)rx
                      withDouble:(jdouble)ry
                      withDouble:(jdouble)rw
                      withDouble:(jdouble)rh {
  
#line 404
  jint cross = ComCrossing_intersectShapeWithHarmonyJavaAwtShape_withDouble_withDouble_withDouble_withDouble_(self, rx, ry, rw, rh);
  return cross == ComCrossing_CROSSING || [self isInsideWithInt:cross];
}


#line 408
- (jboolean)containsWithHarmonyJavaAwtGeomPoint2D:(HarmonyJavaAwtGeomPoint2D *)p {
  return [self containsWithDouble:[((HarmonyJavaAwtGeomPoint2D *) nil_chk(p)) getX] withDouble:[p getY]];
}

- (jboolean)containsWithHarmonyJavaAwtGeomRectangle2D:(HarmonyJavaAwtGeomRectangle2D *)r {
  return [self containsWithDouble:[((HarmonyJavaAwtGeomRectangle2D *) nil_chk(r)) getX] withDouble:[r getY] withDouble:[r getWidth] withDouble:[r getHeight]];
}

- (jboolean)intersectsWithHarmonyJavaAwtGeomRectangle2D:(HarmonyJavaAwtGeomRectangle2D *)r {
  return [self intersectsWithDouble:[((HarmonyJavaAwtGeomRectangle2D *) nil_chk(r)) getX] withDouble:[r getY] withDouble:[r getWidth] withDouble:[r getHeight]];
}

- (id<HarmonyJavaAwtGeomPathIterator>)getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t {
  return new_HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomAffineTransform_(self, self, t);
}

- (id<HarmonyJavaAwtGeomPathIterator>)getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)t
                                                                                withDouble:(jdouble)flatness {
  
#line 425
  return new_HarmonyJavaAwtGeomFlatteningPathIterator_initWithHarmonyJavaAwtGeomPathIterator_withDouble_([self getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:t], flatness);
}


#line 428
- (id)java_clone {
  
#line 430
  @try {
    HarmonyJavaAwtGeomGeneralPath *p = (HarmonyJavaAwtGeomGeneralPath *) cast_chk([super java_clone], [HarmonyJavaAwtGeomGeneralPath class]);
    ((HarmonyJavaAwtGeomGeneralPath *) nil_chk(p))->types_ = [((IOSByteArray *) nil_chk(types_)) java_clone];
    p->points_ = [((IOSFloatArray *) nil_chk(points_)) java_clone];
    return p;
  }
  @catch (
#line 435
  JavaLangCloneNotSupportedException *e) {
    @throw new_JavaLangInternalError_init();
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 3, 0, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x0, 4, 5, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 6, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 8, 7, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 9, 10, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 11, 12, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 15, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomPoint2D;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 16, 17, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtShape;", 0x1, 18, 17, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomRectangle2D;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtAWTRectangle;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x0, 19, 0, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 20, 21, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 20, 22, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 23, 22, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 20, 24, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 20, 25, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 23, 25, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomPathIterator;", 0x1, 26, 17, -1, -1, -1, -1 },
    { NULL, "LHarmonyJavaAwtGeomPathIterator;", 0x1, 26, 27, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x1, 28, -1, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(init);
  methods[1].selector = @selector(initWithInt:);
  methods[2].selector = @selector(initWithInt:withInt:);
  methods[3].selector = @selector(initWithHarmonyJavaAwtShape:);
  methods[4].selector = @selector(setWindingRuleWithInt:);
  methods[5].selector = @selector(getWindingRule);
  methods[6].selector = @selector(checkBufWithInt:withBoolean:);
  methods[7].selector = @selector(moveToWithFloat:withFloat:);
  methods[8].selector = @selector(lineToWithFloat:withFloat:);
  methods[9].selector = @selector(quadToWithFloat:withFloat:withFloat:withFloat:);
  methods[10].selector = @selector(curveToWithFloat:withFloat:withFloat:withFloat:withFloat:withFloat:);
  methods[11].selector = @selector(closePath);
  methods[12].selector = @selector(appendWithHarmonyJavaAwtShape:withBoolean:);
  methods[13].selector = @selector(appendWithHarmonyJavaAwtGeomPathIterator:withBoolean:);
  methods[14].selector = @selector(getCurrentPoint);
  methods[15].selector = @selector(reset);
  methods[16].selector = @selector(transformWithHarmonyJavaAwtGeomAffineTransform:);
  methods[17].selector = @selector(createTransformedShapeWithHarmonyJavaAwtGeomAffineTransform:);
  methods[18].selector = @selector(getBounds2D);
  methods[19].selector = @selector(getBounds);
  methods[20].selector = @selector(isInsideWithInt:);
  methods[21].selector = @selector(containsWithDouble:withDouble:);
  methods[22].selector = @selector(containsWithDouble:withDouble:withDouble:withDouble:);
  methods[23].selector = @selector(intersectsWithDouble:withDouble:withDouble:withDouble:);
  methods[24].selector = @selector(containsWithHarmonyJavaAwtGeomPoint2D:);
  methods[25].selector = @selector(containsWithHarmonyJavaAwtGeomRectangle2D:);
  methods[26].selector = @selector(intersectsWithHarmonyJavaAwtGeomRectangle2D:);
  methods[27].selector = @selector(getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:);
  methods[28].selector = @selector(getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:withDouble:);
  methods[29].selector = @selector(java_clone);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "WIND_EVEN_ODD", "I", .constantValue.asInt = HarmonyJavaAwtGeomGeneralPath_WIND_EVEN_ODD, 0x19, -1, -1, -1, -1 },
    { "WIND_NON_ZERO", "I", .constantValue.asInt = HarmonyJavaAwtGeomGeneralPath_WIND_NON_ZERO, 0x19, -1, -1, -1, -1 },
    { "BUFFER_SIZE", "I", .constantValue.asInt = HarmonyJavaAwtGeomGeneralPath_BUFFER_SIZE, 0x1a, -1, -1, -1, -1 },
    { "BUFFER_CAPACITY", "I", .constantValue.asInt = HarmonyJavaAwtGeomGeneralPath_BUFFER_CAPACITY, 0x1a, -1, -1, -1, -1 },
    { "types_", "[B", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "points_", "[F", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "typeSize_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "pointSize_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "rule_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "pointShift", "[I", .constantValue.asLong = 0, 0x8, -1, 29, -1, -1 },
  };
  static const void *ptrTable[] = { "I", "II", "LHarmonyJavaAwtShape;", "setWindingRule", "checkBuf", "IZ", "moveTo", "FF", "lineTo", "quadTo", "FFFF", "curveTo", "FFFFFF", "append", "LHarmonyJavaAwtShape;Z", "LHarmonyJavaAwtGeomPathIterator;Z", "transform", "LHarmonyJavaAwtGeomAffineTransform;", "createTransformedShape", "isInside", "contains", "DD", "DDDD", "intersects", "LHarmonyJavaAwtGeomPoint2D;", "LHarmonyJavaAwtGeomRectangle2D;", "getPathIterator", "LHarmonyJavaAwtGeomAffineTransform;D", "clone", &HarmonyJavaAwtGeomGeneralPath_pointShift, "LHarmonyJavaAwtGeomGeneralPath_Iterator;" };
  static const J2ObjcClassInfo _HarmonyJavaAwtGeomGeneralPath = { "GeneralPath", "harmony.java.awt.geom", ptrTable, methods, fields, 7, 0x11, 30, 10, -1, 30, -1, -1, -1 };
  return &_HarmonyJavaAwtGeomGeneralPath;
}

- (id)copyWithZone:(NSZone *)zone {
  return [self java_clone];
}

+ (void)initialize {
  if (self == [HarmonyJavaAwtGeomGeneralPath class]) {
    HarmonyJavaAwtGeomGeneralPath_pointShift = [IOSIntArray newArrayWithInts:(jint[]){
#line 73
      2,
#line 74
      2,
#line 75
      4,
#line 76
      6,
#line 77
      0 } count:5];
      J2OBJC_SET_INITIALIZED(HarmonyJavaAwtGeomGeneralPath)
    }
  }

@end


#line 174
void HarmonyJavaAwtGeomGeneralPath_init(HarmonyJavaAwtGeomGeneralPath *self) {
  HarmonyJavaAwtGeomGeneralPath_initWithInt_withInt_(self, HarmonyJavaAwtGeomGeneralPath_WIND_NON_ZERO, HarmonyJavaAwtGeomGeneralPath_BUFFER_SIZE);
}


#line 174
HarmonyJavaAwtGeomGeneralPath *new_HarmonyJavaAwtGeomGeneralPath_init() {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomGeneralPath, init)
}


#line 174
HarmonyJavaAwtGeomGeneralPath *create_HarmonyJavaAwtGeomGeneralPath_init() {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomGeneralPath, init)
}

void HarmonyJavaAwtGeomGeneralPath_initWithInt_(HarmonyJavaAwtGeomGeneralPath *self, jint rule) {
  HarmonyJavaAwtGeomGeneralPath_initWithInt_withInt_(self, rule, HarmonyJavaAwtGeomGeneralPath_BUFFER_SIZE);
}


#line 178
HarmonyJavaAwtGeomGeneralPath *new_HarmonyJavaAwtGeomGeneralPath_initWithInt_(jint rule) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomGeneralPath, initWithInt_, rule)
}


#line 178
HarmonyJavaAwtGeomGeneralPath *create_HarmonyJavaAwtGeomGeneralPath_initWithInt_(jint rule) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomGeneralPath, initWithInt_, rule)
}

void HarmonyJavaAwtGeomGeneralPath_initWithInt_withInt_(HarmonyJavaAwtGeomGeneralPath *self, jint rule, jint initialCapacity) {
  NSObject_init(self);
  
#line 183
  [self setWindingRuleWithInt:rule];
  self->types_ = [IOSByteArray newArrayWithLength:initialCapacity];
  self->points_ = [IOSFloatArray newArrayWithLength:initialCapacity * 2];
}


#line 182
HarmonyJavaAwtGeomGeneralPath *new_HarmonyJavaAwtGeomGeneralPath_initWithInt_withInt_(jint rule, jint initialCapacity) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomGeneralPath, initWithInt_withInt_, rule, initialCapacity)
}


#line 182
HarmonyJavaAwtGeomGeneralPath *create_HarmonyJavaAwtGeomGeneralPath_initWithInt_withInt_(jint rule, jint initialCapacity) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomGeneralPath, initWithInt_withInt_, rule, initialCapacity)
}


#line 188
void HarmonyJavaAwtGeomGeneralPath_initWithHarmonyJavaAwtShape_(HarmonyJavaAwtGeomGeneralPath *self, id<HarmonyJavaAwtShape> shape) {
  HarmonyJavaAwtGeomGeneralPath_initWithInt_withInt_(self, HarmonyJavaAwtGeomGeneralPath_WIND_NON_ZERO, HarmonyJavaAwtGeomGeneralPath_BUFFER_SIZE);
  id<HarmonyJavaAwtGeomPathIterator> p = [((id<HarmonyJavaAwtShape>) nil_chk(shape)) getPathIteratorWithHarmonyJavaAwtGeomAffineTransform:nil];
  [self setWindingRuleWithInt:[((id<HarmonyJavaAwtGeomPathIterator>) nil_chk(p)) getWindingRule]];
  [self appendWithHarmonyJavaAwtGeomPathIterator:p withBoolean:false];
}


#line 188
HarmonyJavaAwtGeomGeneralPath *new_HarmonyJavaAwtGeomGeneralPath_initWithHarmonyJavaAwtShape_(id<HarmonyJavaAwtShape> shape) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomGeneralPath, initWithHarmonyJavaAwtShape_, shape)
}


#line 188
HarmonyJavaAwtGeomGeneralPath *create_HarmonyJavaAwtGeomGeneralPath_initWithHarmonyJavaAwtShape_(id<HarmonyJavaAwtShape> shape) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomGeneralPath, initWithHarmonyJavaAwtShape_, shape)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(HarmonyJavaAwtGeomGeneralPath)

#line 1 "/Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/harmony/java/awt/geom/GeneralPath.java"


#line 82
@implementation HarmonyJavaAwtGeomGeneralPath_Iterator


#line 110
- (instancetype)initWithHarmonyJavaAwtGeomGeneralPath:(HarmonyJavaAwtGeomGeneralPath *)outer$
                    withHarmonyJavaAwtGeomGeneralPath:(HarmonyJavaAwtGeomGeneralPath *)path {
  HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_(self, outer$, path);
  return self;
}


#line 123
- (instancetype)initWithHarmonyJavaAwtGeomGeneralPath:(HarmonyJavaAwtGeomGeneralPath *)outer$
                    withHarmonyJavaAwtGeomGeneralPath:(HarmonyJavaAwtGeomGeneralPath *)path
                withHarmonyJavaAwtGeomAffineTransform:(HarmonyJavaAwtGeomAffineTransform *)at {
  HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomAffineTransform_(self, outer$, path, at);
  return self;
}


#line 128
- (jint)getWindingRule {
  return [((HarmonyJavaAwtGeomGeneralPath *) nil_chk(p_)) getWindingRule];
}

- (jboolean)isDone {
  return typeIndex_ >= ((HarmonyJavaAwtGeomGeneralPath *) nil_chk(p_))->typeSize_;
}

- (void)next {
  typeIndex_++;
}

- (jint)currentSegmentWithDoubleArray:(IOSDoubleArray *)coords {
  if ([self isDone]) {
    
#line 143
    @throw new_JavaUtilNoSuchElementException_initWithNSString_(ComMessages_getStringWithNSString_(@"awt.4B"));
  }
  jint type = IOSByteArray_Get(nil_chk(((HarmonyJavaAwtGeomGeneralPath *) nil_chk(p_))->types_), typeIndex_);
  jint count = IOSIntArray_Get(nil_chk(JreLoadStatic(HarmonyJavaAwtGeomGeneralPath, pointShift)), type);
  for (jint i = 0; i < count; i++) {
    *IOSDoubleArray_GetRef(nil_chk(coords), i) = IOSFloatArray_Get(nil_chk(p_->points_), pointIndex_ + i);
  }
  if (t_ != nil) {
    [t_ transformWithDoubleArray:coords withInt:0 withDoubleArray:coords withInt:0 withInt:JreIntDiv(count, 2)];
  }
  pointIndex_ += count;
  return type;
}


#line 157
- (jint)currentSegmentWithFloatArray:(IOSFloatArray *)coords {
  if ([self isDone]) {
    
#line 160
    @throw new_JavaUtilNoSuchElementException_initWithNSString_(ComMessages_getStringWithNSString_(@"awt.4B"));
  }
  jint type = IOSByteArray_Get(nil_chk(((HarmonyJavaAwtGeomGeneralPath *) nil_chk(p_))->types_), typeIndex_);
  jint count = IOSIntArray_Get(nil_chk(JreLoadStatic(HarmonyJavaAwtGeomGeneralPath, pointShift)), type);
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(p_->points_, pointIndex_, coords, 0, count);
  if (t_ != nil) {
    [t_ transformWithFloatArray:coords withInt:0 withFloatArray:coords withInt:0 withInt:JreIntDiv(count, 2)];
  }
  pointIndex_ += count;
  return type;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 3, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 4, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithHarmonyJavaAwtGeomGeneralPath:withHarmonyJavaAwtGeomGeneralPath:);
  methods[1].selector = @selector(initWithHarmonyJavaAwtGeomGeneralPath:withHarmonyJavaAwtGeomGeneralPath:withHarmonyJavaAwtGeomAffineTransform:);
  methods[2].selector = @selector(getWindingRule);
  methods[3].selector = @selector(isDone);
  methods[4].selector = @selector(next);
  methods[5].selector = @selector(currentSegmentWithDoubleArray:);
  methods[6].selector = @selector(currentSegmentWithFloatArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "typeIndex_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "pointIndex_", "I", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "p_", "LHarmonyJavaAwtGeomGeneralPath;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
    { "t_", "LHarmonyJavaAwtGeomAffineTransform;", .constantValue.asLong = 0, 0x0, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LHarmonyJavaAwtGeomGeneralPath;LHarmonyJavaAwtGeomGeneralPath;", "LHarmonyJavaAwtGeomGeneralPath;LHarmonyJavaAwtGeomGeneralPath;LHarmonyJavaAwtGeomAffineTransform;", "currentSegment", "[D", "[F", "LHarmonyJavaAwtGeomGeneralPath;" };
  static const J2ObjcClassInfo _HarmonyJavaAwtGeomGeneralPath_Iterator = { "Iterator", "harmony.java.awt.geom", ptrTable, methods, fields, 7, 0x0, 7, 4, 5, -1, -1, -1, -1 };
  return &_HarmonyJavaAwtGeomGeneralPath_Iterator;
}

@end


#line 110
void HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_(HarmonyJavaAwtGeomGeneralPath_Iterator *self, HarmonyJavaAwtGeomGeneralPath *outer$, HarmonyJavaAwtGeomGeneralPath *path) {
  HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomAffineTransform_(self, outer$, path, nil);
}


#line 110
HarmonyJavaAwtGeomGeneralPath_Iterator *new_HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_(HarmonyJavaAwtGeomGeneralPath *outer$, HarmonyJavaAwtGeomGeneralPath *path) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomGeneralPath_Iterator, initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_, outer$, path)
}


#line 110
HarmonyJavaAwtGeomGeneralPath_Iterator *create_HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_(HarmonyJavaAwtGeomGeneralPath *outer$, HarmonyJavaAwtGeomGeneralPath *path) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomGeneralPath_Iterator, initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_, outer$, path)
}


#line 123
void HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomGeneralPath_Iterator *self, HarmonyJavaAwtGeomGeneralPath *outer$, HarmonyJavaAwtGeomGeneralPath *path, HarmonyJavaAwtGeomAffineTransform *at) {
  NSObject_init(self);
  
#line 124
  self->p_ = path;
  self->t_ = at;
}


#line 123
HarmonyJavaAwtGeomGeneralPath_Iterator *new_HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomGeneralPath *outer$, HarmonyJavaAwtGeomGeneralPath *path, HarmonyJavaAwtGeomAffineTransform *at) {
  J2OBJC_NEW_IMPL(HarmonyJavaAwtGeomGeneralPath_Iterator, initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomAffineTransform_, outer$, path, at)
}


#line 123
HarmonyJavaAwtGeomGeneralPath_Iterator *create_HarmonyJavaAwtGeomGeneralPath_Iterator_initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomAffineTransform_(HarmonyJavaAwtGeomGeneralPath *outer$, HarmonyJavaAwtGeomGeneralPath *path, HarmonyJavaAwtGeomAffineTransform *at) {
  J2OBJC_CREATE_IMPL(HarmonyJavaAwtGeomGeneralPath_Iterator, initWithHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomGeneralPath_withHarmonyJavaAwtGeomAffineTransform_, outer$, path, at)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(HarmonyJavaAwtGeomGeneralPath_Iterator)
