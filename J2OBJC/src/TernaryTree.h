//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Documents/JAVA/pades-ios/src/main/java/com/aowagie/text/pdf/hyphenation/TernaryTree.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_TernaryTree")
#ifdef RESTRICT_TernaryTree
#define INCLUDE_ALL_TernaryTree 0
#else
#define INCLUDE_ALL_TernaryTree 1
#endif
#undef RESTRICT_TernaryTree

#if !defined (ComAowagieTextPdfHyphenationTernaryTree_) && (INCLUDE_ALL_TernaryTree || defined(INCLUDE_ComAowagieTextPdfHyphenationTernaryTree))
#define ComAowagieTextPdfHyphenationTernaryTree_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class ComAowagieTextPdfHyphenationCharVector;
@class IOSCharArray;

/*!
 @brief <h2>Ternary Search Tree.
 </h2>
  
 <p>A ternary search tree is a hybrid between a binary tree and
  a digital search tree (trie). Keys are limited to strings.
  A data value of type char is stored in each leaf node.
  It can be used as an index (or pointer) to the data.
  Branches that only contain one key are compressed to one node
  by storing a pointer to the trailer substring of the key.
  This class is intended to serve as base class or helper class
  to implement Dictionary collections or the like. Ternary trees
  have some nice properties as the following: the tree can be
  traversed in sorted order, partial matches (wildcard) can be
  implemented, retrieval of all keys within a given distance
  from the target, etc. The storage requirements are higher than
  a binary tree but a lot less than a trie. Performance is
  comparable with a hash table, sometimes it outperforms a hash
  function (most of the time can determine a miss faster than a hash).</p>
  
 <p>The main purpose of this java port is to serve as a base for
  implementing TeX's hyphenation algorithm (see The TeXBook,
  appendix H). Each language requires from 5000 to 15000 hyphenation
  patterns which will be keys in this tree. The strings patterns
  are usually small (from 2 to 5 characters), but each char in the
  tree is stored in a node. Thus memory usage is the main concern.
  We will sacrifice 'elegance' to keep memory requirements to the
  minimum. Using java's char type as pointer (yes, I know pointer
  it is a forbidden word in java) we can keep the size of the node
  to be just 8 bytes (3 pointers and the data char). This gives
  room for about 65000 nodes. In my tests the English patterns
  took 7694 nodes and the German patterns 10055 nodes,
  so I think we are safe.</p>
  
 <p>All said, this is a map with strings as keys and char as value.
  Pretty limited!. It can be extended to a general map by
  using the string representation of an object and using the
  char value as an index to an array that contains the object
  values.</p>
 @author cav@@uniscope.co.jp
 */
@interface ComAowagieTextPdfHyphenationTernaryTree : NSObject < NSCopying, JavaIoSerializable > {
 @public
  /*!
   @brief Pointer to low branch and to rest of the key when it is
  stored directly in this node, we don't have unions in java!
   */
  IOSCharArray *lo_;
  /*!
   @brief Pointer to high branch.
   */
  IOSCharArray *hi_;
  /*!
   @brief Pointer to equal branch and to data when this node is a string terminator.
   */
  IOSCharArray *eq_;
  /*!
   @brief <P>The character stored in this node: splitchar.
   Two special values are reserved:</P>
  <ul><li>0x0000 as string terminator</li>
  <li>0xFFFF to indicate that the branch starting at
  this node is compressed</li></ul>
  <p>This shouldn't be a problem if we give the usual semantics to
  strings since 0xFFFF is guaranteed not to be an Unicode character.</p>
   */
  IOSCharArray *sc_;
  /*!
   @brief This vector holds the trailing of the keys when the branch is compressed.
   */
  ComAowagieTextPdfHyphenationCharVector *kv_;
  jchar root_;
}

#pragma mark Public

- (id)java_clone;

- (void)printStats;

#pragma mark Package-Private

- (instancetype)initPackagePrivate;

- (jint)findWithCharArray:(IOSCharArray *)key
                  withInt:(jint)start;

- (jint)findWithNSString:(NSString *)key;

- (void)insertWithCharArray:(IOSCharArray *)key
                    withInt:(jint)start
                   withChar:(jchar)val;

/*!
 @brief Branches are initially compressed, needing
  one node per key plus the size of the string
  key.They are decompressed as needed when
  another key with same prefix
  is inserted.
 This saves a lot of space,
  specially for long keys.
 @param key Key
 @param val Val
 */
- (void)insertWithNSString:(NSString *)key
                  withChar:(jchar)val;

/*!
 @brief Each node stores a character (splitchar) which is part of
  some key(s).In a compressed branch (one that only contain
  a single string key) the trailer of the key which is not
  already in nodes is stored  externally in the kv array.
 As items are inserted, key substrings decrease.
  Some substrings may completely  disappear when the whole
  branch is totally decompressed.
  The tree is traversed to find the key substrings actually
  used. In addition, duplicate substrings are removed using
  a map (implemented with a TernaryTree!).
 */
- (void)trimToSize;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComAowagieTextPdfHyphenationTernaryTree)

J2OBJC_FIELD_SETTER(ComAowagieTextPdfHyphenationTernaryTree, lo_, IOSCharArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfHyphenationTernaryTree, hi_, IOSCharArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfHyphenationTernaryTree, eq_, IOSCharArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfHyphenationTernaryTree, sc_, IOSCharArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfHyphenationTernaryTree, kv_, ComAowagieTextPdfHyphenationCharVector *)

FOUNDATION_EXPORT void ComAowagieTextPdfHyphenationTernaryTree_initPackagePrivate(ComAowagieTextPdfHyphenationTernaryTree *self);

FOUNDATION_EXPORT ComAowagieTextPdfHyphenationTernaryTree *new_ComAowagieTextPdfHyphenationTernaryTree_initPackagePrivate(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComAowagieTextPdfHyphenationTernaryTree *create_ComAowagieTextPdfHyphenationTernaryTree_initPackagePrivate(void);

J2OBJC_TYPE_LITERAL_HEADER(ComAowagieTextPdfHyphenationTernaryTree)

#endif

#pragma pop_macro("INCLUDE_ALL_TernaryTree")
