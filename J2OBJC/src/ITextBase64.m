//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/com/aowagie/text/pdf/codec/ITextBase64.java
//

#include "IOSPrimitiveArray.h"
#include "ITextBase64.h"
#include "J2ObjC_source.h"
#include "java/io/BufferedInputStream.h"
#include "java/io/BufferedOutputStream.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/File.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileOutputStream.h"
#include "java/io/FilterInputStream.h"
#include "java/io/FilterOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/OutputStream.h"
#include "java/io/PrintStream.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/Exception.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/zip/GZIPInputStream.h"
#include "java/util/zip/GZIPOutputStream.h"

#if !__has_feature(objc_arc)
#error "ITextBase64 must be compiled with ARC (-fobjc-arc)"
#endif

@interface ComAowagieTextPdfCodecITextBase64 ()

/*!
 @brief Defeats instantiation.
 */
- (instancetype)init;

/*!
 @brief Encodes up to the first three bytes of array <var>threeBytes</var>
  and returns a four-byte array in Base64 notation.
 The actual number of significant bytes in your array is
  given by <var>numSigBytes</var>.
  The array <var>threeBytes</var> needs only be as big as 
 <var>numSigBytes</var>.
  Code can reuse a byte array by passing a four-byte array as <var>b4</var>.
 @param b4 A reusable byte array to reduce array instantiation
 @param threeBytes the array to convert
 @param numSigBytes the number of significant bytes in your array
 @param options Options
 @return four byte array in Base64 notation.
 @since 1.5.1
 */
+ (IOSByteArray *)encode3to4WithByteArray:(IOSByteArray *)b4
                            withByteArray:(IOSByteArray *)threeBytes
                                  withInt:(jint)numSigBytes
                                  withInt:(jint)options;

/*!
 @brief <p>Encodes up to three bytes of the array <var>source</var>
  and writes the resulting four Base64 bytes to <var>destination</var>.
 The source and destination arrays can be manipulated
  anywhere along their length by specifying 
 <var>srcOffset</var> and <var>destOffset</var>.
  This method does not check to make sure your arrays
  are large enough to accomodate <var>srcOffset</var> + 3 for
  the <var>source</var> array or <var>destOffset</var> + 4 for
  the <var>destination</var> array.
  The actual number of significant bytes in your array is
  given by <var>numSigBytes</var>.</p>
  <p>This is the lowest level of the encoding methods with
  all possible parameters.</p>
 @param source the array to convert
 @param srcOffset the index where conversion begins
 @param numSigBytes the number of significant bytes in your array
 @param destination the array to hold the conversion
 @param destOffset the index where output will be put
 @param options Options
 @return the <var>destination</var> array
 @since 1.3
 */
+ (IOSByteArray *)encode3to4WithByteArray:(IOSByteArray *)source
                                  withInt:(jint)srcOffset
                                  withInt:(jint)numSigBytes
                            withByteArray:(IOSByteArray *)destination
                                  withInt:(jint)destOffset
                                  withInt:(jint)options;

/*!
 @brief Encodes a byte array into Base64 notation.
 <p>
  Valid options:@code

    GZIP: gzip-compresses object before encoding it.
    DONT_BREAK_LINES: don't break lines at 76 characters
          <i>Note: Technically, this makes your encoding non-compliant.</i>
   
@endcode
  <p>
  Example: <code>encodeBytes( myData, Base64.GZIP )</code> or 
 <p>
  Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
 @param source The data to convert
 @param off Offset in array where conversion should begin
 @param len Length of data to convert
 @param options Specified options                 alphabet type is pulled from this (standard, url-safe, ordered)
 @return bytes
 - seealso: ITextBase64#GZIP
 - seealso: ITextBase64#DONT_BREAK_LINES
 @since 2.0
 */
+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source
                               withInt:(jint)off
                               withInt:(jint)len
                               withInt:(jint)options;

/*!
 @brief Decodes four bytes from array <var>source</var>
  and writes the resulting bytes (up to three of them) to 
 <var>destination</var>.
 The source and destination arrays can be manipulated
  anywhere along their length by specifying 
 <var>srcOffset</var> and <var>destOffset</var>.
  This method does not check to make sure your arrays
  are large enough to accomodate <var>srcOffset</var> + 4 for
  the <var>source</var> array or <var>destOffset</var> + 3 for
  the <var>destination</var> array.
  This method returns the actual number of bytes that
  were converted from the Base64 encoding. 
 <p>This is the lowest level of the decoding methods with
  all possible parameters.</p>
 @param source the array to convert
 @param srcOffset the index where conversion begins
 @param destination the array to hold the conversion
 @param destOffset the index where output will be put
 @param options alphabet type is pulled from this (standard, url-safe, ordered)
 @return the number of decoded bytes converted
 @since 1.3
 */
+ (jint)decode4to3WithByteArray:(IOSByteArray *)source
                        withInt:(jint)srcOffset
                  withByteArray:(IOSByteArray *)destination
                        withInt:(jint)destOffset
                        withInt:(jint)options;

/*!
 @brief Very low-level access to decoding ASCII characters in
  the form of a byte array.Does not support automatically
  gunzipping or any other "fancy" features.
 @param source The Base64 encoded data
 @param off The offset of where to begin decoding
 @param len The length of characters to decode
 @param options Options
 @return decoded data
 @since 1.3
 */
+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)source
                              withInt:(jint)off
                              withInt:(jint)len
                              withInt:(jint)options;

/*!
 @brief Decodes data from Base64 notation, automatically
  detecting gzip-compressed data and decompressing it.
 @param s the string to decode
 @param options encode options such as URL_SAFE
 @return the decoded data
 @since 1.4
 */
+ (IOSByteArray *)decodeWithNSString:(NSString *)s
                             withInt:(jint)options;

/*!
 @brief Convenience method for reading a base64-encoded
  file and decoding it.
 @param filename Filename for reading encoded data
 @return decoded byte array or null if unsuccessful
 @since 2.1
 */
+ (IOSByteArray *)decodeFromFileWithNSString:(NSString *)filename;

/*!
 @brief Convenience method for reading a binary file
  and base64-encoding it.
 @param filename Filename for reading binary data
 @return base64-encoded string or null if unsuccessful
 @since 2.1
 */
+ (NSString *)encodeFromFileWithNSString:(NSString *)filename;

/*!
 @brief Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.
 @param infile Input file
 @param outfile Output file
 @since 2.2
 */
+ (void)encodeFileToFileWithNSString:(NSString *)infile
                        withNSString:(NSString *)outfile;

/*!
 @brief Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.
 @param infile Input file
 @param outfile Output file
 @since 2.2
 */
+ (void)decodeFileToFileWithNSString:(NSString *)infile
                        withNSString:(NSString *)outfile;

@end

/*!
 @brief No options specified.Value is zero.
 */
inline jint ComAowagieTextPdfCodecITextBase64_get_NO_OPTIONS(void);
#define ComAowagieTextPdfCodecITextBase64_NO_OPTIONS 0
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, NO_OPTIONS, jint)

/*!
 @brief Specify encoding.
 */
inline jint ComAowagieTextPdfCodecITextBase64_get_ENCODE(void);
#define ComAowagieTextPdfCodecITextBase64_ENCODE 1
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, ENCODE, jint)

/*!
 @brief Specify decoding.
 */
inline jint ComAowagieTextPdfCodecITextBase64_get_DECODE(void);
#define ComAowagieTextPdfCodecITextBase64_DECODE 0
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, DECODE, jint)

/*!
 @brief Specify that data should be gzip-compressed.
 */
inline jint ComAowagieTextPdfCodecITextBase64_get_GZIP(void);
#define ComAowagieTextPdfCodecITextBase64_GZIP 2
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, GZIP, jint)

/*!
 @brief Don't break lines when encoding (violates strict Base64 specification)
 */
inline jint ComAowagieTextPdfCodecITextBase64_get_DONT_BREAK_LINES(void);
#define ComAowagieTextPdfCodecITextBase64_DONT_BREAK_LINES 8
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, DONT_BREAK_LINES, jint)

/*!
 @brief Encode using Base64-like encoding that is URL- and Filename-safe as described
  in Section 4 of RFC3548: 
 <a href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</a>.
 It is important to note that data encoded this way is <em>not</em> officially valid Base64,
  or at the very least should not be called Base64 without also specifying that is
  was encoded using the URL- and Filename-safe dialect.
 */
inline jint ComAowagieTextPdfCodecITextBase64_get_URL_SAFE(void);
#define ComAowagieTextPdfCodecITextBase64_URL_SAFE 16
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, URL_SAFE, jint)

/*!
 @brief Encode using the special "ordered" dialect of Base64 described here: 
 <a href="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</a>.
 */
inline jint ComAowagieTextPdfCodecITextBase64_get_ORDERED(void);
#define ComAowagieTextPdfCodecITextBase64_ORDERED 32
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, ORDERED, jint)

/*!
 @brief Maximum line length (76) of Base64 output.
 */
inline jint ComAowagieTextPdfCodecITextBase64_get_MAX_LINE_LENGTH(void);
#define ComAowagieTextPdfCodecITextBase64_MAX_LINE_LENGTH 76
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, MAX_LINE_LENGTH, jint)

/*!
 @brief The equals sign (=) as a byte.
 */
inline jbyte ComAowagieTextPdfCodecITextBase64_get_EQUALS_SIGN(void);
#define ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN 61
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, EQUALS_SIGN, jbyte)

/*!
 @brief The new line character (\n) as a byte.
 */
inline jbyte ComAowagieTextPdfCodecITextBase64_get_NEW_LINE(void);
#define ComAowagieTextPdfCodecITextBase64_NEW_LINE 10
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, NEW_LINE, jbyte)

/*!
 @brief Preferred encoding.
 */
inline NSString *ComAowagieTextPdfCodecITextBase64_get_PREFERRED_ENCODING(void);
static NSString *ComAowagieTextPdfCodecITextBase64_PREFERRED_ENCODING = @"UTF-8";
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfCodecITextBase64, PREFERRED_ENCODING, NSString *)

inline jbyte ComAowagieTextPdfCodecITextBase64_get_WHITE_SPACE_ENC(void);
#define ComAowagieTextPdfCodecITextBase64_WHITE_SPACE_ENC -5
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, WHITE_SPACE_ENC, jbyte)

inline jbyte ComAowagieTextPdfCodecITextBase64_get_EQUALS_SIGN_ENC(void);
#define ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN_ENC -1
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfCodecITextBase64, EQUALS_SIGN_ENC, jbyte)

/*!
 @brief The 64 valid Base64 values.
 */
inline IOSByteArray *ComAowagieTextPdfCodecITextBase64_get__STANDARD_ALPHABET(void);
static IOSByteArray *ComAowagieTextPdfCodecITextBase64__STANDARD_ALPHABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfCodecITextBase64, _STANDARD_ALPHABET, IOSByteArray *)

/*!
 @brief Translates a Base64 value to either its 6-bit reconstruction value
  or a negative number indicating some other meaning.
 */
inline IOSByteArray *ComAowagieTextPdfCodecITextBase64_get__STANDARD_DECODABET(void);
static IOSByteArray *ComAowagieTextPdfCodecITextBase64__STANDARD_DECODABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfCodecITextBase64, _STANDARD_DECODABET, IOSByteArray *)

/*!
 @brief Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: 
 <a href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</a>.
 Notice that the last two bytes become "hyphen" and "underscore" instead of "plus" and "slash."
 */
inline IOSByteArray *ComAowagieTextPdfCodecITextBase64_get__URL_SAFE_ALPHABET(void);
static IOSByteArray *ComAowagieTextPdfCodecITextBase64__URL_SAFE_ALPHABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfCodecITextBase64, _URL_SAFE_ALPHABET, IOSByteArray *)

/*!
 @brief Used in decoding URL- and Filename-safe dialects of Base64.
 */
inline IOSByteArray *ComAowagieTextPdfCodecITextBase64_get__URL_SAFE_DECODABET(void);
static IOSByteArray *ComAowagieTextPdfCodecITextBase64__URL_SAFE_DECODABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfCodecITextBase64, _URL_SAFE_DECODABET, IOSByteArray *)

/*!
 @brief I don't get the point of this technique, but it is described here: 
 <a href="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</a>.
 */
inline IOSByteArray *ComAowagieTextPdfCodecITextBase64_get__ORDERED_ALPHABET(void);
static IOSByteArray *ComAowagieTextPdfCodecITextBase64__ORDERED_ALPHABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfCodecITextBase64, _ORDERED_ALPHABET, IOSByteArray *)

/*!
 @brief Used in decoding the "ordered" dialect of Base64.
 */
inline IOSByteArray *ComAowagieTextPdfCodecITextBase64_get__ORDERED_DECODABET(void);
static IOSByteArray *ComAowagieTextPdfCodecITextBase64__ORDERED_DECODABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfCodecITextBase64, _ORDERED_DECODABET, IOSByteArray *)

__attribute__((unused)) static void ComAowagieTextPdfCodecITextBase64_init(ComAowagieTextPdfCodecITextBase64 *self);

__attribute__((unused)) static ComAowagieTextPdfCodecITextBase64 *new_ComAowagieTextPdfCodecITextBase64_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static ComAowagieTextPdfCodecITextBase64 *create_ComAowagieTextPdfCodecITextBase64_init(void);

__attribute__((unused)) static IOSByteArray *ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(IOSByteArray *b4, IOSByteArray *threeBytes, jint numSigBytes, jint options);

__attribute__((unused)) static IOSByteArray *ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(IOSByteArray *source, jint srcOffset, jint numSigBytes, IOSByteArray *destination, jint destOffset, jint options);

__attribute__((unused)) static NSString *ComAowagieTextPdfCodecITextBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(IOSByteArray *source, jint off, jint len, jint options);

__attribute__((unused)) static jint ComAowagieTextPdfCodecITextBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(IOSByteArray *source, jint srcOffset, IOSByteArray *destination, jint destOffset, jint options);

__attribute__((unused)) static IOSByteArray *ComAowagieTextPdfCodecITextBase64_decodeWithByteArray_withInt_withInt_withInt_(IOSByteArray *source, jint off, jint len, jint options);

__attribute__((unused)) static IOSByteArray *ComAowagieTextPdfCodecITextBase64_decodeWithNSString_withInt_(NSString *s, jint options);

__attribute__((unused)) static IOSByteArray *ComAowagieTextPdfCodecITextBase64_decodeFromFileWithNSString_(NSString *filename);

__attribute__((unused)) static NSString *ComAowagieTextPdfCodecITextBase64_encodeFromFileWithNSString_(NSString *filename);

__attribute__((unused)) static void ComAowagieTextPdfCodecITextBase64_encodeFileToFileWithNSString_withNSString_(NSString *infile, NSString *outfile);

__attribute__((unused)) static void ComAowagieTextPdfCodecITextBase64_decodeFileToFileWithNSString_withNSString_(NSString *infile, NSString *outfile);

/*!
 @brief A <code>ITextBase64.InputStream</code> will read data from another 
 <tt>java.io.InputStream</tt>, given in the constructor,
  and encode/decode to/from Base64 notation on the fly.
 - seealso: ITextBase64
 @since 1.3
 */
@interface ComAowagieTextPdfCodecITextBase64_InputStream : JavaIoFilterInputStream {
 @public
  jboolean encode_;
  jint position_;
  IOSByteArray *buffer_;
  jint bufferLength_;
  jint numSigBytes_;
  jint lineLength_;
  jboolean breakLines_;
  jint options_;
  IOSByteArray *alphabet_;
  IOSByteArray *decodabet_;
}

/*!
 @brief Constructs a <code>ITextBase64.InputStream</code> in
  either ENCODE or DECODE mode.
 <p>
  Valid options:@code

    ENCODE or DECODE: Encode or Decode as data is read.
    DONT_BREAK_LINES: don't break lines at 76 characters
      (only meaningful when encoding)     
     <i>Note: Technically, this makes your encoding non-compliant.</i>
   
@endcode
  <p>
  Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>
 @param inArg the  <tt> java.io.InputStream </tt>  from which to read data.
 @param options Specified options
 - seealso: ITextBase64#ENCODE
 - seealso: ITextBase64#DECODE
 - seealso: ITextBase64#DONT_BREAK_LINES
 @since 2.0
 */
- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inArg
                                  withInt:(jint)options;

/*!
 @brief Reads enough of the input stream to convert
  to/from Base64 and returns the next byte.
 @return next byte
 @since 1.3
 */
- (jint)read;

/*!
 @brief Calls <code>read()</code> repeatedly until the end of stream
  is reached or <var>len</var> bytes are read.
 Returns number of bytes read into array or -1 if
  end of stream is encountered.
 @param dest array to hold values
 @param off offset for array
 @param len max number of bytes to read into array
 @return bytes read into array or -1 if end of stream is encountered.
 @since 1.3
 */
- (jint)readWithByteArray:(IOSByteArray *)dest
                  withInt:(jint)off
                  withInt:(jint)len;

@end

J2OBJC_EMPTY_STATIC_INIT(ComAowagieTextPdfCodecITextBase64_InputStream)

J2OBJC_FIELD_SETTER(ComAowagieTextPdfCodecITextBase64_InputStream, buffer_, IOSByteArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfCodecITextBase64_InputStream, alphabet_, IOSByteArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfCodecITextBase64_InputStream, decodabet_, IOSByteArray *)

__attribute__((unused)) static void ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(ComAowagieTextPdfCodecITextBase64_InputStream *self, JavaIoInputStream *inArg, jint options);

__attribute__((unused)) static ComAowagieTextPdfCodecITextBase64_InputStream *new_ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint options) NS_RETURNS_RETAINED;

__attribute__((unused)) static ComAowagieTextPdfCodecITextBase64_InputStream *create_ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint options);

J2OBJC_TYPE_LITERAL_HEADER(ComAowagieTextPdfCodecITextBase64_InputStream)

/*!
 @brief A <code>ITextBase64.OutputStream</code> will write data to another 
 <tt>java.io.OutputStream</tt>, given in the constructor,
  and encode/decode to/from Base64 notation on the fly.
 - seealso: ITextBase64
 @since 1.3
 */
@interface ComAowagieTextPdfCodecITextBase64_OutputStream : JavaIoFilterOutputStream {
 @public
  jboolean encode_;
  jint position_;
  IOSByteArray *buffer_;
  jint bufferLength_;
  jint lineLength_;
  jboolean breakLines_;
  IOSByteArray *b4_;
  jboolean suspendEncoding_;
  jint options_;
  IOSByteArray *alphabet_;
  IOSByteArray *decodabet_;
}

/*!
 @brief Constructs a <code>ITextBase64.OutputStream</code> in
  either ENCODE or DECODE mode.
 <p>
  Valid options:@code

    ENCODE or DECODE: Encode or Decode as data is read.
    DONT_BREAK_LINES: don't break lines at 76 characters
      (only meaningful when encoding)     
     <i>Note: Technically, this makes your encoding non-compliant.</i>
   
@endcode
  <p>
  Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>
 @param outArg the  <tt> java.io.OutputStream </tt>  to which data will be written.
 @param options Specified options.
 - seealso: ITextBase64#ENCODE
 - seealso: ITextBase64#DECODE
 - seealso: ITextBase64#DONT_BREAK_LINES
 @since 1.3
 */
- (instancetype)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                   withInt:(jint)options;

/*!
 @brief Writes the byte to the output stream after
  converting to/from Base64 notation.
 When encoding, bytes are buffered three
  at a time before the output stream actually
  gets a write() call.
  When decoding, bytes are buffered four
  at a time.
 @param theByte the byte to write
 @since 1.3
 */
- (void)writeWithInt:(jint)theByte;

/*!
 @brief Calls <code>write(int)</code> repeatedly until <var>len</var>
  bytes are written.
 @param theBytes array from which to read bytes
 @param off offset for array
 @param len max number of bytes to read into array
 @since 1.3
 */
- (void)writeWithByteArray:(IOSByteArray *)theBytes
                   withInt:(jint)off
                   withInt:(jint)len;

/*!
 @brief Method added by PHIL.
 [Thanks, PHIL. -Rob]
  This pads the buffer without closing the stream.
 @throw IOExceptionon error
 */
- (void)flushBase64;

/*!
 @brief Flushes and closes (I think, in the superclass) the stream.
 @since 1.3
 */
- (void)close;

@end

J2OBJC_EMPTY_STATIC_INIT(ComAowagieTextPdfCodecITextBase64_OutputStream)

J2OBJC_FIELD_SETTER(ComAowagieTextPdfCodecITextBase64_OutputStream, buffer_, IOSByteArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfCodecITextBase64_OutputStream, b4_, IOSByteArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfCodecITextBase64_OutputStream, alphabet_, IOSByteArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfCodecITextBase64_OutputStream, decodabet_, IOSByteArray *)

__attribute__((unused)) static void ComAowagieTextPdfCodecITextBase64_OutputStream_initWithJavaIoOutputStream_withInt_(ComAowagieTextPdfCodecITextBase64_OutputStream *self, JavaIoOutputStream *outArg, jint options);

__attribute__((unused)) static ComAowagieTextPdfCodecITextBase64_OutputStream *new_ComAowagieTextPdfCodecITextBase64_OutputStream_initWithJavaIoOutputStream_withInt_(JavaIoOutputStream *outArg, jint options) NS_RETURNS_RETAINED;

__attribute__((unused)) static ComAowagieTextPdfCodecITextBase64_OutputStream *create_ComAowagieTextPdfCodecITextBase64_OutputStream_initWithJavaIoOutputStream_withInt_(JavaIoOutputStream *outArg, jint options);

__attribute__((unused)) static void ComAowagieTextPdfCodecITextBase64_OutputStream_flushBase64(ComAowagieTextPdfCodecITextBase64_OutputStream *self);

J2OBJC_TYPE_LITERAL_HEADER(ComAowagieTextPdfCodecITextBase64_OutputStream)

#line 1 "/Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/com/aowagie/text/pdf/codec/ITextBase64.java"

J2OBJC_INITIALIZED_DEFN(ComAowagieTextPdfCodecITextBase64)


#line 71
@implementation ComAowagieTextPdfCodecITextBase64


#line 339
+ (IOSByteArray *)getAlphabetWithInt:(jint)options {
  return ComAowagieTextPdfCodecITextBase64_getAlphabetWithInt_(options);
}


#line 360
+ (IOSByteArray *)getDecodabetWithInt:(jint)options {
  return ComAowagieTextPdfCodecITextBase64_getDecodabetWithInt_(options);
}

J2OBJC_IGNORE_DESIGNATED_BEGIN

#line 374
- (instancetype)init {
  ComAowagieTextPdfCodecITextBase64_init(self);
  return self;
}
J2OBJC_IGNORE_DESIGNATED_END


#line 396
+ (IOSByteArray *)encode3to4WithByteArray:(IOSByteArray *)b4
                            withByteArray:(IOSByteArray *)threeBytes
                                  withInt:(jint)numSigBytes
                                  withInt:(jint)options {
  return ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(b4, threeBytes, numSigBytes, options);
}


#line 426
+ (IOSByteArray *)encode3to4WithByteArray:(IOSByteArray *)source
                                  withInt:(jint)srcOffset
                                  withInt:(jint)numSigBytes
                            withByteArray:(IOSByteArray *)destination
                                  withInt:(jint)destOffset
                                  withInt:(jint)options {
  return ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(source, srcOffset, numSigBytes, destination, destOffset, options);
}


#line 490
+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source {
  return ComAowagieTextPdfCodecITextBase64_encodeBytesWithByteArray_(source);
}


#line 527
+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source
                               withInt:(jint)off
                               withInt:(jint)len
                               withInt:(jint)options {
  return ComAowagieTextPdfCodecITextBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(source, off, len, options);
}


#line 641
+ (jint)decode4to3WithByteArray:(IOSByteArray *)source
                        withInt:(jint)srcOffset
                  withByteArray:(IOSByteArray *)destination
                        withInt:(jint)destOffset
                        withInt:(jint)options {
  return ComAowagieTextPdfCodecITextBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(source, srcOffset, destination, destOffset, options);
}


#line 715
+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)source
                              withInt:(jint)off
                              withInt:(jint)len
                              withInt:(jint)options {
  return ComAowagieTextPdfCodecITextBase64_decodeWithByteArray_withInt_withInt_withInt_(source, off, len, options);
}


#line 770
+ (IOSByteArray *)decodeWithNSString:(NSString *)s {
  return ComAowagieTextPdfCodecITextBase64_decodeWithNSString_(s);
}


#line 784
+ (IOSByteArray *)decodeWithNSString:(NSString *)s
                             withInt:(jint)options {
  return ComAowagieTextPdfCodecITextBase64_decodeWithNSString_withInt_(s, options);
}


#line 862
+ (IOSByteArray *)decodeFromFileWithNSString:(NSString *)filename {
  return ComAowagieTextPdfCodecITextBase64_decodeFromFileWithNSString_(filename);
}


#line 915
+ (NSString *)encodeFromFileWithNSString:(NSString *)filename {
  return ComAowagieTextPdfCodecITextBase64_encodeFromFileWithNSString_(filename);
}


#line 956
+ (void)encodeFileToFileWithNSString:(NSString *)infile
                        withNSString:(NSString *)outfile {
  ComAowagieTextPdfCodecITextBase64_encodeFileToFileWithNSString_withNSString_(infile, outfile);
}


#line 980
+ (void)decodeFileToFileWithNSString:(NSString *)infile
                        withNSString:(NSString *)outfile {
  ComAowagieTextPdfCodecITextBase64_decodeFileToFileWithNSString_withNSString_(infile, outfile);
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "[B", 0x18, 0, 1, -1, -1, -1, -1 },
    { NULL, "[B", 0x18, 2, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 3, 4, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 3, 5, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x9, 6, 7, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xa, 6, 8, -1, -1, -1, -1 },
    { NULL, "I", 0xa, 9, 10, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 11, 8, -1, -1, -1, -1 },
    { NULL, "[B", 0x9, 11, 12, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 11, 13, -1, -1, -1, -1 },
    { NULL, "[B", 0xa, 14, 12, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0xa, 15, 12, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 16, 17, -1, -1, -1, -1 },
    { NULL, "V", 0xa, 18, 17, -1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(getAlphabetWithInt:);
  methods[1].selector = @selector(getDecodabetWithInt:);
  methods[2].selector = @selector(init);
  methods[3].selector = @selector(encode3to4WithByteArray:withByteArray:withInt:withInt:);
  methods[4].selector = @selector(encode3to4WithByteArray:withInt:withInt:withByteArray:withInt:withInt:);
  methods[5].selector = @selector(encodeBytesWithByteArray:);
  methods[6].selector = @selector(encodeBytesWithByteArray:withInt:withInt:withInt:);
  methods[7].selector = @selector(decode4to3WithByteArray:withInt:withByteArray:withInt:withInt:);
  methods[8].selector = @selector(decodeWithByteArray:withInt:withInt:withInt:);
  methods[9].selector = @selector(decodeWithNSString:);
  methods[10].selector = @selector(decodeWithNSString:withInt:);
  methods[11].selector = @selector(decodeFromFileWithNSString:);
  methods[12].selector = @selector(encodeFromFileWithNSString:);
  methods[13].selector = @selector(encodeFileToFileWithNSString:withNSString:);
  methods[14].selector = @selector(decodeFileToFileWithNSString:withNSString:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "NO_OPTIONS", "I", .constantValue.asInt = ComAowagieTextPdfCodecITextBase64_NO_OPTIONS, 0x1a, -1, -1, -1, -1 },
    { "ENCODE", "I", .constantValue.asInt = ComAowagieTextPdfCodecITextBase64_ENCODE, 0x1a, -1, -1, -1, -1 },
    { "DECODE", "I", .constantValue.asInt = ComAowagieTextPdfCodecITextBase64_DECODE, 0x1a, -1, -1, -1, -1 },
    { "GZIP", "I", .constantValue.asInt = ComAowagieTextPdfCodecITextBase64_GZIP, 0x1a, -1, -1, -1, -1 },
    { "DONT_BREAK_LINES", "I", .constantValue.asInt = ComAowagieTextPdfCodecITextBase64_DONT_BREAK_LINES, 0x1a, -1, -1, -1, -1 },
    { "URL_SAFE", "I", .constantValue.asInt = ComAowagieTextPdfCodecITextBase64_URL_SAFE, 0x1a, -1, -1, -1, -1 },
    { "ORDERED", "I", .constantValue.asInt = ComAowagieTextPdfCodecITextBase64_ORDERED, 0x1a, -1, -1, -1, -1 },
    { "MAX_LINE_LENGTH", "I", .constantValue.asInt = ComAowagieTextPdfCodecITextBase64_MAX_LINE_LENGTH, 0x1a, -1, -1, -1, -1 },
    { "EQUALS_SIGN", "B", .constantValue.asChar = ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN, 0x1a, -1, -1, -1, -1 },
    { "NEW_LINE", "B", .constantValue.asChar = ComAowagieTextPdfCodecITextBase64_NEW_LINE, 0x1a, -1, -1, -1, -1 },
    { "PREFERRED_ENCODING", "LNSString;", .constantValue.asLong = 0, 0x1a, -1, 19, -1, -1 },
    { "WHITE_SPACE_ENC", "B", .constantValue.asChar = ComAowagieTextPdfCodecITextBase64_WHITE_SPACE_ENC, 0x1a, -1, -1, -1, -1 },
    { "EQUALS_SIGN_ENC", "B", .constantValue.asChar = ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN_ENC, 0x1a, -1, -1, -1, -1 },
    { "_STANDARD_ALPHABET", "[B", .constantValue.asLong = 0, 0x1a, -1, 20, -1, -1 },
    { "_STANDARD_DECODABET", "[B", .constantValue.asLong = 0, 0x1a, -1, 21, -1, -1 },
    { "_URL_SAFE_ALPHABET", "[B", .constantValue.asLong = 0, 0x1a, -1, 22, -1, -1 },
    { "_URL_SAFE_DECODABET", "[B", .constantValue.asLong = 0, 0x1a, -1, 23, -1, -1 },
    { "_ORDERED_ALPHABET", "[B", .constantValue.asLong = 0, 0x1a, -1, 24, -1, -1 },
    { "_ORDERED_DECODABET", "[B", .constantValue.asLong = 0, 0x1a, -1, 25, -1, -1 },
  };
  static const void *ptrTable[] = { "getAlphabet", "I", "getDecodabet", "encode3to4", "[B[BII", "[BII[BII", "encodeBytes", "[B", "[BIII", "decode4to3", "[BI[BII", "decode", "LNSString;", "LNSString;I", "decodeFromFile", "encodeFromFile", "encodeFileToFile", "LNSString;LNSString;", "decodeFileToFile", &ComAowagieTextPdfCodecITextBase64_PREFERRED_ENCODING, &ComAowagieTextPdfCodecITextBase64__STANDARD_ALPHABET, &ComAowagieTextPdfCodecITextBase64__STANDARD_DECODABET, &ComAowagieTextPdfCodecITextBase64__URL_SAFE_ALPHABET, &ComAowagieTextPdfCodecITextBase64__URL_SAFE_DECODABET, &ComAowagieTextPdfCodecITextBase64__ORDERED_ALPHABET, &ComAowagieTextPdfCodecITextBase64__ORDERED_DECODABET, "LComAowagieTextPdfCodecITextBase64_InputStream;LComAowagieTextPdfCodecITextBase64_OutputStream;" };
  static const J2ObjcClassInfo _ComAowagieTextPdfCodecITextBase64 = { "ITextBase64", "com.aowagie.text.pdf.codec", ptrTable, methods, fields, 7, 0x1, 15, 19, -1, 26, -1, -1, -1 };
  return &_ComAowagieTextPdfCodecITextBase64;
}

+ (void)initialize {
  if (self == [ComAowagieTextPdfCodecITextBase64 class]) {
    ComAowagieTextPdfCodecITextBase64__STANDARD_ALPHABET = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 144
      (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G',
#line 145
      (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N',
#line 146
      (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U',
#line 147
      (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z',
#line 148
      (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g',
#line 149
      (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n',
#line 150
      (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u',
#line 151
      (jbyte) 'v', (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z',
#line 152
      (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5',
#line 153
      (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9', (jbyte) '+', (jbyte) '/' } count:64];
      ComAowagieTextPdfCodecITextBase64__STANDARD_DECODABET = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 163
        -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 164
        -5, -5,
#line 165
        -9, -9,
#line 166
        -5,
#line 167
        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 168
        -9, -9, -9, -9, -9,
#line 169
        -5,
#line 170
        -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 171
        62,
#line 172
        -9, -9, -9,
#line 173
        63,
#line 174
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
#line 175
        -9, -9, -9,
#line 176
        -1,
#line 177
        -9, -9, -9,
#line 178
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
#line 179
        14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
#line 180
        -9, -9, -9, -9, -9, -9,
#line 181
        26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
#line 182
        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
#line 183
        -9, -9, -9, -9 } count:127];
        ComAowagieTextPdfCodecITextBase64__URL_SAFE_ALPHABET = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 206
          (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G',
#line 207
          (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N',
#line 208
          (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U',
#line 209
          (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z',
#line 210
          (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g',
#line 211
          (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n',
#line 212
          (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u',
#line 213
          (jbyte) 'v', (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z',
#line 214
          (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5',
#line 215
          (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9', (jbyte) '-', (jbyte) '_' } count:64];
          ComAowagieTextPdfCodecITextBase64__URL_SAFE_DECODABET = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 223
            -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 224
            -5, -5,
#line 225
            -9, -9,
#line 226
            -5,
#line 227
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 228
            -9, -9, -9, -9, -9,
#line 229
            -5,
#line 230
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 231
            -9,
#line 232
            -9,
#line 233
            62,
#line 234
            -9,
#line 235
            -9,
#line 236
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
#line 237
            -9, -9, -9,
#line 238
            -1,
#line 239
            -9, -9, -9,
#line 240
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
#line 241
            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
#line 242
            -9, -9, -9, -9,
#line 243
            63,
#line 244
            -9,
#line 245
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
#line 246
            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
#line 247
            -9, -9, -9, -9 } count:127];
            ComAowagieTextPdfCodecITextBase64__ORDERED_ALPHABET = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 270
              (jbyte) '-',
#line 271
              (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4',
#line 272
              (jbyte) '5', (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9',
#line 273
              (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G',
#line 274
              (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N',
#line 275
              (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U',
#line 276
              (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z',
#line 277
              (jbyte) '_',
#line 278
              (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g',
#line 279
              (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n',
#line 280
              (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u',
#line 281
              (jbyte) 'v', (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z' } count:64];
              ComAowagieTextPdfCodecITextBase64__ORDERED_DECODABET = [IOSByteArray newArrayWithBytes:(jbyte[]){
#line 289
                -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 290
                -5, -5,
#line 291
                -9, -9,
#line 292
                -5,
#line 293
                -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 294
                -9, -9, -9, -9, -9,
#line 295
                -5,
#line 296
                -9, -9, -9, -9, -9, -9, -9, -9, -9, -9,
#line 297
                -9,
#line 298
                -9,
#line 299
                0,
#line 300
                -9,
#line 301
                -9,
#line 302
                1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
#line 303
                -9, -9, -9,
#line 304
                -1,
#line 305
                -9, -9, -9,
#line 306
                11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
#line 307
                24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
#line 308
                -9, -9, -9, -9,
#line 309
                37,
#line 310
                -9,
#line 311
                38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
#line 312
                51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
#line 313
                -9, -9, -9, -9 } count:127];
                J2OBJC_SET_INITIALIZED(ComAowagieTextPdfCodecITextBase64)
              }
            }

@end


#line 339
IOSByteArray *ComAowagieTextPdfCodecITextBase64_getAlphabetWithInt_(jint options) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 340
  if ((options & ComAowagieTextPdfCodecITextBase64_URL_SAFE) == ComAowagieTextPdfCodecITextBase64_URL_SAFE) {
    return ComAowagieTextPdfCodecITextBase64__URL_SAFE_ALPHABET;
  }
  else
#line 342
  if ((options & ComAowagieTextPdfCodecITextBase64_ORDERED) == ComAowagieTextPdfCodecITextBase64_ORDERED) {
    return ComAowagieTextPdfCodecITextBase64__ORDERED_ALPHABET;
  }
  else {
    
#line 345
    return ComAowagieTextPdfCodecITextBase64__STANDARD_ALPHABET;
  }
}


#line 360
IOSByteArray *ComAowagieTextPdfCodecITextBase64_getDecodabetWithInt_(jint options) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 361
  if ((options & ComAowagieTextPdfCodecITextBase64_URL_SAFE) == ComAowagieTextPdfCodecITextBase64_URL_SAFE) {
    return ComAowagieTextPdfCodecITextBase64__URL_SAFE_DECODABET;
  }
  else
#line 363
  if ((options & ComAowagieTextPdfCodecITextBase64_ORDERED) == ComAowagieTextPdfCodecITextBase64_ORDERED) {
    return ComAowagieTextPdfCodecITextBase64__ORDERED_DECODABET;
  }
  else {
    
#line 366
    return ComAowagieTextPdfCodecITextBase64__STANDARD_DECODABET;
  }
}


#line 374
void ComAowagieTextPdfCodecITextBase64_init(ComAowagieTextPdfCodecITextBase64 *self) {
  NSObject_init(self);
}


#line 374
ComAowagieTextPdfCodecITextBase64 *new_ComAowagieTextPdfCodecITextBase64_init() {
  J2OBJC_NEW_IMPL(ComAowagieTextPdfCodecITextBase64, init)
}


#line 374
ComAowagieTextPdfCodecITextBase64 *create_ComAowagieTextPdfCodecITextBase64_init() {
  J2OBJC_CREATE_IMPL(ComAowagieTextPdfCodecITextBase64, init)
}


#line 396
IOSByteArray *ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(IOSByteArray *b4, IOSByteArray *threeBytes, jint numSigBytes, jint options) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 397
  (void) ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(threeBytes, 0, numSigBytes, b4, 0, options);
  return b4;
}


#line 426
IOSByteArray *ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(IOSByteArray *source, jint srcOffset, jint numSigBytes, IOSByteArray *destination, jint destOffset, jint options) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 429
  IOSByteArray *ALPHABET = ComAowagieTextPdfCodecITextBase64_getAlphabetWithInt_(options);
  
#line 442
  jint inBuff = (numSigBytes > 0 ? JreURShift32(JreLShift32(IOSByteArray_Get(nil_chk(source), srcOffset), 24), 8) : 0) |
#line 443
  (numSigBytes > 1 ? JreURShift32(JreLShift32(IOSByteArray_Get(nil_chk(source), srcOffset + 1), 24), 16) : 0) |
#line 444
  (numSigBytes > 2 ? JreURShift32(JreLShift32(IOSByteArray_Get(nil_chk(source), srcOffset + 2), 24), 24) : 0);
  
#line 446
  switch (numSigBytes) {
    case 3:
    *IOSByteArray_GetRef(nil_chk(destination), destOffset) = IOSByteArray_Get(nil_chk(ALPHABET), JreURShift32(inBuff, 18));
    *IOSByteArray_GetRef(destination, destOffset + 1) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 12)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 2) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 6)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 3) = IOSByteArray_Get(ALPHABET, inBuff & (jint) 0x3f);
    return destination;
    
#line 454
    case 2:
    *IOSByteArray_GetRef(nil_chk(destination), destOffset) = IOSByteArray_Get(nil_chk(ALPHABET), JreURShift32(inBuff, 18));
    *IOSByteArray_GetRef(destination, destOffset + 1) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 12)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 2) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 6)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 3) = ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN;
    return destination;
    
#line 461
    case 1:
    *IOSByteArray_GetRef(nil_chk(destination), destOffset) = IOSByteArray_Get(nil_chk(ALPHABET), JreURShift32(inBuff, 18));
    *IOSByteArray_GetRef(destination, destOffset + 1) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 12)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 2) = ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN;
    *IOSByteArray_GetRef(destination, destOffset + 3) = ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN;
    return destination;
    
#line 468
    default:
    return destination;
  }
}


#line 490
NSString *ComAowagieTextPdfCodecITextBase64_encodeBytesWithByteArray_(IOSByteArray *source) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 491
  return ComAowagieTextPdfCodecITextBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(source, 0, ((IOSByteArray *) nil_chk(source))->size_, ComAowagieTextPdfCodecITextBase64_NO_OPTIONS);
}


#line 527
NSString *ComAowagieTextPdfCodecITextBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(IOSByteArray *source, jint off, jint len, jint options) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  jint dontBreakLines = options & ComAowagieTextPdfCodecITextBase64_DONT_BREAK_LINES;
  jint gzip = options & ComAowagieTextPdfCodecITextBase64_GZIP;
  
#line 533
  if (gzip == ComAowagieTextPdfCodecITextBase64_GZIP) {
    JavaIoByteArrayOutputStream *baos = nil;
    JavaUtilZipGZIPOutputStream *gzos = nil;
    ComAowagieTextPdfCodecITextBase64_OutputStream *b64os = nil;
    
#line 539
    @try {
      
#line 541
      baos = new_JavaIoByteArrayOutputStream_init();
      b64os = new_ComAowagieTextPdfCodecITextBase64_OutputStream_initWithJavaIoOutputStream_withInt_(baos, ComAowagieTextPdfCodecITextBase64_ENCODE | options);
      gzos = new_JavaUtilZipGZIPOutputStream_initWithJavaIoOutputStream_(b64os);
      
#line 545
      [gzos writeWithByteArray:source withInt:off withInt:len];
      [gzos close];
    }
    @catch (JavaIoIOException *e) {
      [e printStackTrace];
      return nil;
    }
    @finally {
      @try {
        
#line 553
        [((JavaUtilZipGZIPOutputStream *) nil_chk(gzos)) close];
      }
      @catch (
#line 553
      JavaLangException *e) {
      }
      
#line 554
      @try {
        
#line 554
        [((ComAowagieTextPdfCodecITextBase64_OutputStream *) nil_chk(b64os)) close];
      }
      @catch (
#line 554
      JavaLangException *e) {
      }
      
#line 555
      @try {
        
#line 555
        [((JavaIoByteArrayOutputStream *) nil_chk(baos)) close];
      }
      @catch (
#line 555
      JavaLangException *e) {
      }
    }
    
#line 559
    @try {
      return [NSString java_stringWithBytes:[baos toByteArray] charsetName:ComAowagieTextPdfCodecITextBase64_PREFERRED_ENCODING];
    }
    @catch (JavaIoUnsupportedEncodingException *uue) {
      return [NSString java_stringWithBytes:[baos toByteArray]];
    }
  }
  else {
    
#line 570
    jboolean breakLines = dontBreakLines == 0;
    
#line 572
    jint len43 = JreIntDiv(len * 4, 3);
    IOSByteArray *outBuff = [IOSByteArray newArrayWithLength:len43 +
#line 574
    (JreIntMod(len, 3) > 0 ? 4 : 0) +
#line 575
    (breakLines ? JreIntDiv(len43, ComAowagieTextPdfCodecITextBase64_MAX_LINE_LENGTH) : 0)];
    jint d = 0;
    jint e = 0;
    jint len2 = len - 2;
    jint lineLength = 0;
    for (; d < len2; d += 3, e += 4) {
      (void) ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(source, d + off, 3, outBuff, e, options);
      
#line 583
      lineLength += 4;
      if (breakLines && lineLength == ComAowagieTextPdfCodecITextBase64_MAX_LINE_LENGTH) {
        *IOSByteArray_GetRef(outBuff, e + 4) = ComAowagieTextPdfCodecITextBase64_NEW_LINE;
        e++;
        lineLength = 0;
      }
    }
    
#line 591
    if (d < len) {
      (void) ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(source, d + off, len - d, outBuff, e, options);
      e += 4;
    }
    
#line 598
    @try {
      return [NSString java_stringWithBytes:outBuff offset:0 length:e charsetName:ComAowagieTextPdfCodecITextBase64_PREFERRED_ENCODING];
    }
    @catch (JavaIoUnsupportedEncodingException *uue) {
      return [NSString java_stringWithBytes:outBuff offset:0 length:e];
    }
  }
}


#line 641
jint ComAowagieTextPdfCodecITextBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(IOSByteArray *source, jint srcOffset, IOSByteArray *destination, jint destOffset, jint options) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 642
  IOSByteArray *DECODABET = ComAowagieTextPdfCodecITextBase64_getDecodabetWithInt_(options);
  
#line 645
  if (IOSByteArray_Get(nil_chk(source), srcOffset + 2) == ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN) {
    
#line 649
    jint outBuff = (JreLShift32((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (jint) 0xFF), 18)) | (JreLShift32(
#line 650
    (IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (jint) 0xFF), 12));
    
#line 652
    *IOSByteArray_GetRef(nil_chk(destination), destOffset) = (jbyte) (JreURShift32(outBuff, 16));
    return 1;
  }
  else
#line 657
  if (IOSByteArray_Get(source, srcOffset + 3) == ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN) {
    
#line 662
    jint outBuff = (JreLShift32((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (jint) 0xFF), 18)) | (JreLShift32(
#line 663
    (IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (jint) 0xFF), 12)) | (JreLShift32(
#line 664
    (IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 2)) & (jint) 0xFF), 6));
    
#line 666
    *IOSByteArray_GetRef(nil_chk(destination), destOffset) = (jbyte) (JreURShift32(outBuff, 16));
    *IOSByteArray_GetRef(destination, destOffset + 1) = (jbyte) (JreURShift32(outBuff, 8));
    return 2;
  }
  else {
    
#line 673
    @try {
      
#line 679
      jint outBuff = (JreLShift32((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (jint) 0xFF), 18)) | (JreLShift32(
#line 680
      (IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (jint) 0xFF), 12)) | (JreLShift32(
#line 681
      (IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 2)) & (jint) 0xFF), 6)) | (
#line 682
      IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 3)) & (jint) 0xFF);
      
#line 685
      *IOSByteArray_GetRef(nil_chk(destination), destOffset) = (jbyte) (JreRShift32(outBuff, 16));
      *IOSByteArray_GetRef(destination, destOffset + 1) = (jbyte) (JreRShift32(outBuff, 8));
      *IOSByteArray_GetRef(destination, destOffset + 2) = (jbyte) outBuff;
      
#line 689
      return 3;
    }
    @catch (
#line 690
    JavaLangException *e) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("B$B", IOSByteArray_Get(source, srcOffset), @": ", IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)))];
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("B$B", IOSByteArray_Get(source, srcOffset + 1), @": ", IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)))];
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("B$B", IOSByteArray_Get(source, srcOffset + 2), @": ", IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 2)))];
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, out))) printlnWithNSString:JreStrcat("B$B", IOSByteArray_Get(source, srcOffset + 3), @": ", IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 3)))];
      return -1;
    }
  }
}


#line 715
IOSByteArray *ComAowagieTextPdfCodecITextBase64_decodeWithByteArray_withInt_withInt_withInt_(IOSByteArray *source, jint off, jint len, jint options) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 716
  IOSByteArray *DECODABET = ComAowagieTextPdfCodecITextBase64_getDecodabetWithInt_(options);
  
#line 718
  jint len34 = JreIntDiv(len * 3, 4);
  IOSByteArray *outBuff = [IOSByteArray newArrayWithLength:len34];
  jint outBuffPosn = 0;
  
#line 722
  IOSByteArray *b4 = [IOSByteArray newArrayWithLength:4];
  jint b4Posn = 0;
  jint i = 0;
  jbyte sbiCrop = 0;
  jbyte sbiDecode = 0;
  for (i = off; i < off + len; i++) {
    sbiCrop = (jbyte) (IOSByteArray_Get(nil_chk(source), i) & (jint) 0x7f);
    sbiDecode = IOSByteArray_Get(nil_chk(DECODABET), sbiCrop);
    
#line 731
    if (sbiDecode >= ComAowagieTextPdfCodecITextBase64_WHITE_SPACE_ENC) {
      
#line 733
      if (sbiDecode >= ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN_ENC) {
        *IOSByteArray_GetRef(b4, b4Posn++) = sbiCrop;
        if (b4Posn > 3) {
          outBuffPosn += ComAowagieTextPdfCodecITextBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(b4, 0, outBuff, outBuffPosn, options);
          b4Posn = 0;
          
#line 740
          if (sbiCrop == ComAowagieTextPdfCodecITextBase64_EQUALS_SIGN) {
            break;
          }
        }
      }
    }
    else {
      
#line 749
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$I$B$", @"Bad Base64 input character at ", i, @": ", IOSByteArray_Get(source, i), @"(decimal)")];
      return nil;
    }
  }
  
#line 754
  IOSByteArray *out = [IOSByteArray newArrayWithLength:outBuffPosn];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(outBuff, 0, out, 0, outBuffPosn);
  return out;
}


#line 770
IOSByteArray *ComAowagieTextPdfCodecITextBase64_decodeWithNSString_(NSString *s) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 771
  return ComAowagieTextPdfCodecITextBase64_decodeWithNSString_withInt_(s, ComAowagieTextPdfCodecITextBase64_NO_OPTIONS);
}


#line 784
IOSByteArray *ComAowagieTextPdfCodecITextBase64_decodeWithNSString_withInt_(NSString *s, jint options) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 785
  IOSByteArray *bytes;
  @try {
    bytes = [((NSString *) nil_chk(s)) java_getBytesWithCharsetName:ComAowagieTextPdfCodecITextBase64_PREFERRED_ENCODING];
  }
  @catch (JavaIoUnsupportedEncodingException *uee) {
    bytes = [s java_getBytes];
  }
  
#line 795
  bytes = ComAowagieTextPdfCodecITextBase64_decodeWithByteArray_withInt_withInt_withInt_(bytes, 0, ((IOSByteArray *) nil_chk(bytes))->size_, options);
  
#line 800
  if (bytes != nil && bytes->size_ >= 4) {
    
#line 802
    jint head = (IOSByteArray_Get(bytes, 0) & (jint) 0xff) | ((JreLShift32(IOSByteArray_Get(bytes, 1), 8)) & (jint) 0xff00);
    if (JavaUtilZipGZIPInputStream_GZIP_MAGIC == head) {
      JavaIoByteArrayInputStream *bais = nil;
      JavaUtilZipGZIPInputStream *gzis = nil;
      JavaIoByteArrayOutputStream *baos = nil;
      IOSByteArray *buffer = [IOSByteArray newArrayWithLength:2048];
      jint length = 0;
      
#line 810
      @try {
        baos = new_JavaIoByteArrayOutputStream_init();
        bais = new_JavaIoByteArrayInputStream_initWithByteArray_(bytes);
        gzis = new_JavaUtilZipGZIPInputStream_initWithJavaIoInputStream_(bais);
        
#line 815
        while ((length = [gzis readWithByteArray:buffer]) >= 0) {
          [baos writeWithByteArray:buffer withInt:0 withInt:length];
        }
        
#line 820
        bytes = [baos toByteArray];
      }
      @catch (
#line 823
      JavaIoIOException *e) {
      }
      @finally {
        
#line 827
        @try {
          
#line 827
          [((JavaIoByteArrayOutputStream *) nil_chk(baos)) close];
        }
        @catch (
#line 827
        JavaLangException *e) {
        }
        
#line 828
        @try {
          
#line 828
          [((JavaUtilZipGZIPInputStream *) nil_chk(gzis)) close];
        }
        @catch (
#line 828
        JavaLangException *e) {
        }
        
#line 829
        @try {
          
#line 829
          [((JavaIoByteArrayInputStream *) nil_chk(bais)) close];
        }
        @catch (
#line 829
        JavaLangException *e) {
        }
      }
    }
  }
  
#line 835
  return bytes;
}


#line 862
IOSByteArray *ComAowagieTextPdfCodecITextBase64_decodeFromFileWithNSString_(NSString *filename) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 863
  IOSByteArray *decodedData = nil;
  ComAowagieTextPdfCodecITextBase64_InputStream *bis = nil;
  @try {
    
#line 867
    JavaIoFile *file = new_JavaIoFile_initWithNSString_(filename);
    IOSByteArray *buffer = nil;
    jint length = 0;
    jint numBytes = 0;
    
#line 873
    if ([file length] > JavaLangInteger_MAX_VALUE) {
      [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$J$", @"File is too big for this convenience method (", [file length], @" bytes).")];
      return nil;
    }
    buffer = [IOSByteArray newArrayWithLength:(jint) [file length]];
    
#line 880
    bis = new_ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(new_JavaIoBufferedInputStream_initWithJavaIoInputStream_(new_JavaIoFileInputStream_initWithJavaIoFile_(
#line 882
    file)), ComAowagieTextPdfCodecITextBase64_DECODE);
    
#line 885
    while ((numBytes = [bis readWithByteArray:buffer withInt:length withInt:4096]) >= 0) {
      length += numBytes;
    }
    
#line 890
    decodedData = [IOSByteArray newArrayWithLength:length];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buffer, 0, decodedData, 0, length);
  }
  @catch (
#line 894
  JavaIoIOException *e) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$$", @"Error decoding from file ", filename)];
  }
  @finally {
    @try {
      
#line 898
      [((ComAowagieTextPdfCodecITextBase64_InputStream *) nil_chk(bis)) close];
    }
    @catch (
#line 898
    JavaLangException *e) {
    }
  }
  return decodedData;
}


#line 915
NSString *ComAowagieTextPdfCodecITextBase64_encodeFromFileWithNSString_(NSString *filename) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 916
  NSString *encodedData = nil;
  ComAowagieTextPdfCodecITextBase64_InputStream *bis = nil;
  @try {
    
#line 920
    JavaIoFile *file = new_JavaIoFile_initWithNSString_(filename);
    IOSByteArray *buffer = [IOSByteArray newArrayWithLength:JavaLangMath_maxWithInt_withInt_(JreFpToInt(([file length] * 1.4)), 40)];
    jint length = 0;
    jint numBytes = 0;
    
#line 926
    bis = new_ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(new_JavaIoBufferedInputStream_initWithJavaIoInputStream_(new_JavaIoFileInputStream_initWithJavaIoFile_(
#line 928
    file)), ComAowagieTextPdfCodecITextBase64_ENCODE);
    
#line 931
    while ((numBytes = [bis readWithByteArray:buffer withInt:length withInt:4096]) >= 0) {
      length += numBytes;
    }
    
#line 936
    encodedData = [NSString java_stringWithBytes:buffer offset:0 length:length charsetName:ComAowagieTextPdfCodecITextBase64_PREFERRED_ENCODING];
  }
  @catch (
#line 939
  JavaIoIOException *e) {
    [((JavaIoPrintStream *) nil_chk(JreLoadStatic(JavaLangSystem, err))) printlnWithNSString:JreStrcat("$$", @"Error encoding from file ", filename)];
  }
  @finally {
    @try {
      
#line 943
      [((ComAowagieTextPdfCodecITextBase64_InputStream *) nil_chk(bis)) close];
    }
    @catch (
#line 943
    JavaLangException *e) {
    }
  }
  return encodedData;
}


#line 956
void ComAowagieTextPdfCodecITextBase64_encodeFileToFileWithNSString_withNSString_(NSString *infile, NSString *outfile) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 957
  NSString *encoded = ComAowagieTextPdfCodecITextBase64_encodeFromFileWithNSString_(infile);
  JavaIoOutputStream *out = nil;
  @try {
    out = new_JavaIoBufferedOutputStream_initWithJavaIoOutputStream_(new_JavaIoFileOutputStream_initWithNSString_(
#line 961
    outfile));
    [out writeWithByteArray:[((NSString *) nil_chk(encoded)) java_getBytesWithCharsetName:@"US-ASCII"]];
  }
  @catch (JavaIoIOException *ex) {
    [ex printStackTrace];
  }
  @finally {
    @try {
      
#line 968
      [((JavaIoOutputStream *) nil_chk(out)) close];
    }
    @catch (
#line 968
    JavaLangException *ex) {
    }
  }
}


#line 980
void ComAowagieTextPdfCodecITextBase64_decodeFileToFileWithNSString_withNSString_(NSString *infile, NSString *outfile) {
  ComAowagieTextPdfCodecITextBase64_initialize();
  
#line 981
  IOSByteArray *decoded = ComAowagieTextPdfCodecITextBase64_decodeFromFileWithNSString_(infile);
  JavaIoOutputStream *out = nil;
  @try {
    out = new_JavaIoBufferedOutputStream_initWithJavaIoOutputStream_(new_JavaIoFileOutputStream_initWithNSString_(
#line 985
    outfile));
    [out writeWithByteArray:decoded];
  }
  @catch (JavaIoIOException *ex) {
    [ex printStackTrace];
  }
  @finally {
    @try {
      
#line 992
      [((JavaIoOutputStream *) nil_chk(out)) close];
    }
    @catch (
#line 992
    JavaLangException *ex) {
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComAowagieTextPdfCodecITextBase64)

#line 1 "/Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/com/aowagie/text/pdf/codec/ITextBase64.java"


#line 1009
@implementation ComAowagieTextPdfCodecITextBase64_InputStream


#line 1046
- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inArg
                                  withInt:(jint)options {
  ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(self, inArg, options);
  return self;
}


#line 1066
- (jint)read {
  
#line 1069
  if (self->position_ < 0) {
    if (self->encode_) {
      IOSByteArray *b3 = [IOSByteArray newArrayWithLength:3];
      jint numBinaryBytes = 0;
      for (jint i = 0; i < 3; i++) {
        @try {
          jint b = [((JavaIoInputStream *) nil_chk(JreLoadVolatileId(&self->in_))) read];
          
#line 1078
          if (b >= 0) {
            *IOSByteArray_GetRef(b3, i) = (jbyte) b;
            numBinaryBytes++;
          }
        }
        @catch (
#line 1084
        JavaIoIOException *e) {
          
#line 1086
          if (i == 0) {
            @throw e;
          }
        }
      }
      
#line 1093
      if (numBinaryBytes > 0) {
        (void) ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(b3, 0, numBinaryBytes, self->buffer_, 0, self->options_);
        self->position_ = 0;
        self->numSigBytes_ = 4;
      }
      else {
        return -1;
      }
    }
    else {
      
#line 1105
      IOSByteArray *b4 = [IOSByteArray newArrayWithLength:4];
      jint i = 0;
      for (i = 0; i < 4; i++) {
        
#line 1109
        jint b = 0;
        do {
          
#line 1110
          b = [((JavaIoInputStream *) nil_chk(JreLoadVolatileId(&self->in_))) read];
        }
        while (
#line 1111
        b >= 0 && IOSByteArray_Get(nil_chk(self->decodabet_), b & (jint) 0x7f) <= ComAowagieTextPdfCodecITextBase64_WHITE_SPACE_ENC);
        
#line 1113
        if (b < 0) {
          
#line 1115
          break;
        }
        
#line 1118
        *IOSByteArray_GetRef(b4, i) = (jbyte) b;
      }
      
#line 1121
      if (i == 4) {
        self->numSigBytes_ = ComAowagieTextPdfCodecITextBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(b4, 0, self->buffer_, 0, self->options_);
        self->position_ = 0;
      }
      else if (i == 0) {
        return -1;
      }
      else {
        
#line 1130
        @throw new_JavaIoIOException_initWithNSString_(@"Improperly padded Base64 input.");
      }
    }
  }
  
#line 1137
  if (self->position_ >= 0) {
    
#line 1139
    if (self->position_ >= self->numSigBytes_) {
      return -1;
    }
    
#line 1143
    if (self->encode_ && self->breakLines_ && self->lineLength_ >= ComAowagieTextPdfCodecITextBase64_MAX_LINE_LENGTH) {
      self->lineLength_ = 0;
      return 0x000a;
    }
    else {
      self->lineLength_++;
      
#line 1152
      jint b = IOSByteArray_Get(nil_chk(self->buffer_), self->position_++);
      
#line 1154
      if (self->position_ >= self->bufferLength_) {
        self->position_ = -1;
      }
      
#line 1158
      return b & (jint) 0xFF;
    }
  }
  else {
    
#line 1166
    @throw new_JavaIoIOException_initWithNSString_(@"Error in Base64 code reading stream.");
  }
}


#line 1183
- (jint)readWithByteArray:(IOSByteArray *)dest
                  withInt:(jint)off
                  withInt:(jint)len {
  
#line 1185
  jint i;
  jint b;
  for (i = 0; i < len; i++) {
    b = [self read];
    
#line 1193
    if (b >= 0) {
      *IOSByteArray_GetRef(nil_chk(dest), off + i) = (jbyte) b;
    }
    else
#line 1195
    if (i == 0) {
      return -1;
    }
    else {
      break;
    }
  }
  return i;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, 1, -1, -1, -1 },
    { NULL, "I", 0x1, 2, 3, 1, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoInputStream:withInt:);
  methods[1].selector = @selector(read);
  methods[2].selector = @selector(readWithByteArray:withInt:withInt:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "encode_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "position_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "bufferLength_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "numSigBytes_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "lineLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "breakLines_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "options_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "alphabet_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "decodabet_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoInputStream;I", "LJavaIoIOException;", "read", "[BII", "LComAowagieTextPdfCodecITextBase64;" };
  static const J2ObjcClassInfo _ComAowagieTextPdfCodecITextBase64_InputStream = { "InputStream", "com.aowagie.text.pdf.codec", ptrTable, methods, fields, 7, 0xa, 3, 10, 4, -1, -1, -1, -1 };
  return &_ComAowagieTextPdfCodecITextBase64_InputStream;
}

@end


#line 1046
void ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(ComAowagieTextPdfCodecITextBase64_InputStream *self, JavaIoInputStream *inArg, jint options) {
  JavaIoFilterInputStream_initWithJavaIoInputStream_(self, inArg);
  self->breakLines_ = ((options & ComAowagieTextPdfCodecITextBase64_DONT_BREAK_LINES) != ComAowagieTextPdfCodecITextBase64_DONT_BREAK_LINES);
  self->encode_ = ((options & ComAowagieTextPdfCodecITextBase64_ENCODE) == ComAowagieTextPdfCodecITextBase64_ENCODE);
  self->bufferLength_ = self->encode_ ? 4 : 3;
  self->buffer_ = [IOSByteArray newArrayWithLength:self->bufferLength_];
  self->position_ = -1;
  self->lineLength_ = 0;
  self->options_ = options;
  self->alphabet_ = ComAowagieTextPdfCodecITextBase64_getAlphabetWithInt_(options);
  self->decodabet_ = ComAowagieTextPdfCodecITextBase64_getDecodabetWithInt_(options);
}


#line 1046
ComAowagieTextPdfCodecITextBase64_InputStream *new_ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint options) {
  J2OBJC_NEW_IMPL(ComAowagieTextPdfCodecITextBase64_InputStream, initWithJavaIoInputStream_withInt_, inArg, options)
}


#line 1046
ComAowagieTextPdfCodecITextBase64_InputStream *create_ComAowagieTextPdfCodecITextBase64_InputStream_initWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint options) {
  J2OBJC_CREATE_IMPL(ComAowagieTextPdfCodecITextBase64_InputStream, initWithJavaIoInputStream_withInt_, inArg, options)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComAowagieTextPdfCodecITextBase64_InputStream)

#line 1 "/Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/com/aowagie/text/pdf/codec/ITextBase64.java"


#line 1224
@implementation ComAowagieTextPdfCodecITextBase64_OutputStream


#line 1260
- (instancetype)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                   withInt:(jint)options {
  ComAowagieTextPdfCodecITextBase64_OutputStream_initWithJavaIoOutputStream_withInt_(self, outArg, options);
  return self;
}


#line 1288
- (void)writeWithInt:(jint)theByte {
  
#line 1291
  if (self->suspendEncoding_) {
    [((JavaIoOutputStream *) nil_chk(out_)) writeWithInt:theByte];
    return;
  }
  
#line 1297
  if (self->encode_) {
    *IOSByteArray_GetRef(nil_chk(self->buffer_), self->position_++) = (jbyte) theByte;
    if (self->position_ >= self->bufferLength_) {
      
#line 1301
      [((JavaIoOutputStream *) nil_chk(self->out_)) writeWithByteArray:ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(self->b4_, self->buffer_, self->bufferLength_, self->options_)];
      
#line 1303
      self->lineLength_ += 4;
      if (self->breakLines_ && self->lineLength_ >= ComAowagieTextPdfCodecITextBase64_MAX_LINE_LENGTH) {
        [((JavaIoOutputStream *) nil_chk(self->out_)) writeWithInt:ComAowagieTextPdfCodecITextBase64_NEW_LINE];
        self->lineLength_ = 0;
      }
      
#line 1309
      self->position_ = 0;
    }
  }
  else {
    
#line 1316
    if (IOSByteArray_Get(nil_chk(self->decodabet_), theByte & (jint) 0x7f) > ComAowagieTextPdfCodecITextBase64_WHITE_SPACE_ENC) {
      *IOSByteArray_GetRef(nil_chk(self->buffer_), self->position_++) = (jbyte) theByte;
      if (self->position_ >= self->bufferLength_) {
        
#line 1320
        jint len = ComAowagieTextPdfCodecITextBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(self->buffer_, 0, self->b4_, 0, self->options_);
        [((JavaIoOutputStream *) nil_chk(self->out_)) writeWithByteArray:self->b4_ withInt:0 withInt:len];
        
#line 1323
        self->position_ = 0;
      }
    }
    else if (IOSByteArray_Get(self->decodabet_, theByte & (jint) 0x7f) != ComAowagieTextPdfCodecITextBase64_WHITE_SPACE_ENC) {
      @throw new_JavaIoIOException_initWithNSString_(@"Invalid character in Base64 data.");
    }
  }
}


#line 1343
- (void)writeWithByteArray:(IOSByteArray *)theBytes
                   withInt:(jint)off
                   withInt:(jint)len {
  if (self->suspendEncoding_) {
    [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:theBytes withInt:off withInt:len];
    return;
  }
  
#line 1351
  for (jint i = 0; i < len; i++) {
    [self writeWithInt:IOSByteArray_Get(nil_chk(theBytes), off + i)];
  }
}


#line 1364
- (void)flushBase64 {
  ComAowagieTextPdfCodecITextBase64_OutputStream_flushBase64(self);
}


#line 1383
- (void)close {
  
#line 1386
  ComAowagieTextPdfCodecITextBase64_OutputStream_flushBase64(self);
  
#line 1390
  [super close];
  
#line 1392
  self->buffer_ = nil;
  self->out_ = nil;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x0, -1, 0, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 2, 3, -1, -1, -1 },
    { NULL, "V", 0x1, 1, 4, 3, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 3, -1, -1, -1 },
    { NULL, "V", 0x1, -1, -1, 3, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithJavaIoOutputStream:withInt:);
  methods[1].selector = @selector(writeWithInt:);
  methods[2].selector = @selector(writeWithByteArray:withInt:withInt:);
  methods[3].selector = @selector(flushBase64);
  methods[4].selector = @selector(close);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "encode_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "position_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "buffer_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "bufferLength_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "lineLength_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "breakLines_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "b4_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "suspendEncoding_", "Z", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "options_", "I", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "alphabet_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
    { "decodabet_", "[B", .constantValue.asLong = 0, 0x12, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LJavaIoOutputStream;I", "write", "I", "LJavaIoIOException;", "[BII", "LComAowagieTextPdfCodecITextBase64;" };
  static const J2ObjcClassInfo _ComAowagieTextPdfCodecITextBase64_OutputStream = { "OutputStream", "com.aowagie.text.pdf.codec", ptrTable, methods, fields, 7, 0xa, 5, 11, 5, -1, -1, -1, -1 };
  return &_ComAowagieTextPdfCodecITextBase64_OutputStream;
}

@end


#line 1260
void ComAowagieTextPdfCodecITextBase64_OutputStream_initWithJavaIoOutputStream_withInt_(ComAowagieTextPdfCodecITextBase64_OutputStream *self, JavaIoOutputStream *outArg, jint options) {
  JavaIoFilterOutputStream_initWithJavaIoOutputStream_(self, outArg);
  self->breakLines_ = ((options & ComAowagieTextPdfCodecITextBase64_DONT_BREAK_LINES) != ComAowagieTextPdfCodecITextBase64_DONT_BREAK_LINES);
  self->encode_ = ((options & ComAowagieTextPdfCodecITextBase64_ENCODE) == ComAowagieTextPdfCodecITextBase64_ENCODE);
  self->bufferLength_ = self->encode_ ? 3 : 4;
  self->buffer_ = [IOSByteArray newArrayWithLength:self->bufferLength_];
  self->position_ = 0;
  self->lineLength_ = 0;
  self->suspendEncoding_ = false;
  self->b4_ = [IOSByteArray newArrayWithLength:4];
  self->options_ = options;
  self->alphabet_ = ComAowagieTextPdfCodecITextBase64_getAlphabetWithInt_(options);
  self->decodabet_ = ComAowagieTextPdfCodecITextBase64_getDecodabetWithInt_(options);
}


#line 1260
ComAowagieTextPdfCodecITextBase64_OutputStream *new_ComAowagieTextPdfCodecITextBase64_OutputStream_initWithJavaIoOutputStream_withInt_(JavaIoOutputStream *outArg, jint options) {
  J2OBJC_NEW_IMPL(ComAowagieTextPdfCodecITextBase64_OutputStream, initWithJavaIoOutputStream_withInt_, outArg, options)
}


#line 1260
ComAowagieTextPdfCodecITextBase64_OutputStream *create_ComAowagieTextPdfCodecITextBase64_OutputStream_initWithJavaIoOutputStream_withInt_(JavaIoOutputStream *outArg, jint options) {
  J2OBJC_CREATE_IMPL(ComAowagieTextPdfCodecITextBase64_OutputStream, initWithJavaIoOutputStream_withInt_, outArg, options)
}


#line 1364
void ComAowagieTextPdfCodecITextBase64_OutputStream_flushBase64(ComAowagieTextPdfCodecITextBase64_OutputStream *self) {
  if (self->position_ > 0) {
    if (self->encode_) {
      [((JavaIoOutputStream *) nil_chk(self->out_)) writeWithByteArray:ComAowagieTextPdfCodecITextBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(self->b4_, self->buffer_, self->position_, self->options_)];
      self->position_ = 0;
    }
    else {
      @throw new_JavaIoIOException_initWithNSString_(@"Base64 input not properly padded.");
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComAowagieTextPdfCodecITextBase64_OutputStream)
