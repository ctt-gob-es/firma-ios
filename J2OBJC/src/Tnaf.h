//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/org/spongycastle/math/ec/Tnaf.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_Tnaf")
#ifdef RESTRICT_Tnaf
#define INCLUDE_ALL_Tnaf 0
#else
#define INCLUDE_ALL_Tnaf 1
#endif
#undef RESTRICT_Tnaf

#if !defined (OrgSpongycastleMathEcTnaf_) && (INCLUDE_ALL_Tnaf || defined(INCLUDE_OrgSpongycastleMathEcTnaf))
#define OrgSpongycastleMathEcTnaf_

@class IOSByteArray;
@class IOSObjectArray;
@class JavaMathBigInteger;
@class OrgSpongycastleMathEcECCurve_AbstractF2m;
@class OrgSpongycastleMathEcECFieldElement;
@class OrgSpongycastleMathEcECPoint_AbstractF2m;
@class OrgSpongycastleMathEcSimpleBigDecimal;
@class OrgSpongycastleMathEcZTauElement;

/*!
 @brief Class holding methods for point multiplication based on the window 
 &tau;-adic nonadjacent form (WTNAF).The algorithms are based on the
  paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
  by Jerome A.
 Solinas. The paper first appeared in the Proceedings of
  Crypto 1997.
 */
@interface OrgSpongycastleMathEcTnaf : NSObject

#pragma mark Public

/*!
 @brief Approximate division by <code>n</code>.For an integer 
 <code>k</code>, the value <code>&lambda; = s k / n</code> is
  computed to <code>c</code> bits of accuracy.
 @param k The parameter  <code> k </code>
  .
 @param s The curve parameter  <code> s <sub> 0 </sub> </code>
   or   <code> s <sub> 1 </sub> </code>
  .
 @param vm The Lucas Sequence element  <code> V <sub> m </sub> </code>
  .
 @param a The parameter  <code> a </code>  of the elliptic curve.
 @param m The bit length of the finite field  
  <code> <b> F </b> <sub> m </sub> </code>
  .
 @param c The number of bits of accuracy, i.e. the scale of the returned  
  <code> SimpleBigDecimal </code> .
 @return The value <code>&lambda; = s k / n</code> computed to 
 <code>c</code> bits of accuracy.
 */
+ (OrgSpongycastleMathEcSimpleBigDecimal *)approximateDivisionByNWithJavaMathBigInteger:(JavaMathBigInteger *)k
                                                                 withJavaMathBigInteger:(JavaMathBigInteger *)s
                                                                 withJavaMathBigInteger:(JavaMathBigInteger *)vm
                                                                               withByte:(jbyte)a
                                                                                withInt:(jint)m
                                                                                withInt:(jint)c;

/*!
 @brief Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and 
 <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and 
 <code>V<sub>k</sub></code>.
 @param mu The parameter  <code> &mu; </code>  of the elliptic curve.
 @param k The index of the second element of the Lucas Sequence to be  returned.
 @param doV If set to true, computes  <code> V <sub> k-1 </sub> </code>
   and   <code> V <sub> k </sub> </code> , otherwise  <code> U <sub> k-1 </sub>
  </code>  and   <code> U <sub> k </sub>
  </code> .
 @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
  and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
  and <code>V<sub>k</sub></code>.
 */
+ (IOSObjectArray *)getLucasWithByte:(jbyte)mu
                             withInt:(jint)k
                         withBoolean:(jboolean)doV;

/*!
 @brief Returns the parameter <code>&mu;</code> of the elliptic curve.
 @param curve The elliptic curve from which to obtain  <code> &mu; </code> .  The curve must be a Koblitz curve, i.e.  <code> a </code>  equals   <code> 0 </code>  or  <code> 1 </code>  and  <code> b </code>  equals   <code> 1 </code> .
 @return <code>&mu;</code> of the elliptic curve.
 @throw IllegalArgumentExceptionif the given ECCurve is not a Koblitz
  curve.
 */
+ (jbyte)getMuWithOrgSpongycastleMathEcECCurve_AbstractF2m:(OrgSpongycastleMathEcECCurve_AbstractF2m *)curve;

+ (jbyte)getMuWithOrgSpongycastleMathEcECFieldElement:(OrgSpongycastleMathEcECFieldElement *)curveA;

+ (jbyte)getMuWithInt:(jint)curveA;

/*!
 @brief Does the precomputation for WTNAF multiplication.
 @param p The  <code> ECPoint </code>  for which to do the precomputation.
 @param a The parameter  <code> a </code>  of the elliptic curve.
 @return The precomputation array for <code>p</code>.
 */
+ (IOSObjectArray *)getPreCompWithOrgSpongycastleMathEcECPoint_AbstractF2m:(OrgSpongycastleMathEcECPoint_AbstractF2m *)p
                                                                  withByte:(jbyte)a;

/*!
 @brief Computes the auxiliary values <code>s<sub>0</sub></code> and 
 <code>s<sub>1</sub></code> used for partial modular reduction.
 @param curve The elliptic curve for which to compute  
  <code> s <sub> 0 </sub> </code>  and  <code> s <sub> 1 </sub> </code>
  .
 @throw IllegalArgumentExceptionif <code>curve</code> is not a
  Koblitz curve (Anomalous Binary Curve, ABC).
 */
+ (IOSObjectArray *)getSiWithOrgSpongycastleMathEcECCurve_AbstractF2m:(OrgSpongycastleMathEcECCurve_AbstractF2m *)curve;

+ (IOSObjectArray *)getSiWithInt:(jint)fieldSize
                         withInt:(jint)curveA
          withJavaMathBigInteger:(JavaMathBigInteger *)cofactor;

/*!
 @brief Computes the auxiliary value <code>t<sub>w</sub></code>.If the width is
  4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for 
 <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code>
 @param mu The parameter  <code> &mu; </code>  of the elliptic curve.
 @param w The window width of the WTNAF.
 @return the auxiliary value <code>t<sub>w</sub></code>
 */
+ (JavaMathBigInteger *)getTwWithByte:(jbyte)mu
                              withInt:(jint)w;

/*!
 @brief Multiplies a <code>ECPoint.AbstractF2m</code>
  by an element <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>
  using the <code>&tau;</code>-adic NAF (TNAF) method, given the TNAF
  of <code>&lambda;</code>.
 @param p The ECPoint.AbstractF2m to multiply.
 @param u The the TNAF of  <code> &lambda; </code> ..
 @return <code>&lambda; * p</code>
 */
+ (OrgSpongycastleMathEcECPoint_AbstractF2m *)multiplyFromTnafWithOrgSpongycastleMathEcECPoint_AbstractF2m:(OrgSpongycastleMathEcECPoint_AbstractF2m *)p
                                                                                             withByteArray:(IOSByteArray *)u;

/*!
 @brief Multiplies a <code>ECPoint.AbstractF2m</code>
  by a <code>BigInteger</code> using the reduced <code>&tau;</code>-adic
  NAF (RTNAF) method.
 @param p The ECPoint.AbstractF2m to multiply.
 @param k The  <code> BigInteger </code>  by which to multiply  <code> p </code>
  .
 @return <code>k * p</code>
 */
+ (OrgSpongycastleMathEcECPoint_AbstractF2m *)multiplyRTnafWithOrgSpongycastleMathEcECPoint_AbstractF2m:(OrgSpongycastleMathEcECPoint_AbstractF2m *)p
                                                                                 withJavaMathBigInteger:(JavaMathBigInteger *)k;

/*!
 @brief Multiplies a <code>ECPoint.AbstractF2m</code>
  by an element <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>
  using the <code>&tau;</code>-adic NAF (TNAF) method.
 @param p The ECPoint.AbstractF2m to multiply.
 @param lambda The element  <code> &lambda; </code>  of   <code> <b> Z </b> [ &tau; ] </code> .
 @return <code>&lambda; * p</code>
 */
+ (OrgSpongycastleMathEcECPoint_AbstractF2m *)multiplyTnafWithOrgSpongycastleMathEcECPoint_AbstractF2m:(OrgSpongycastleMathEcECPoint_AbstractF2m *)p
                                                                  withOrgSpongycastleMathEcZTauElement:(OrgSpongycastleMathEcZTauElement *)lambda;

/*!
 @brief Computes the norm of an element <code>&lambda;</code> of 
 <code><b>R</b>[&tau;]</code>, where <code>&lambda; = u + v&tau;</code>
  and <code>u</code> and <code>u</code> are real numbers (elements of 
 <code><b>R</b></code>).
 @param mu The parameter  <code> &mu; </code>  of the elliptic curve.
 @param u The real part of the element  <code> &lambda; </code>  of   <code> <b> R </b> [ &tau; ] </code> .
 @param v The  <code> &tau; </code> -adic part of the element   <code> &lambda; </code>  of  <code> <b> R </b> [ &tau; ] </code> .
 @return The norm of <code>&lambda;</code>.
 */
+ (OrgSpongycastleMathEcSimpleBigDecimal *)normWithByte:(jbyte)mu
              withOrgSpongycastleMathEcSimpleBigDecimal:(OrgSpongycastleMathEcSimpleBigDecimal *)u
              withOrgSpongycastleMathEcSimpleBigDecimal:(OrgSpongycastleMathEcSimpleBigDecimal *)v;

/*!
 @brief Computes the norm of an element <code>&lambda;</code> of 
 <code><b>Z</b>[&tau;]</code>.
 @param mu The parameter  <code> &mu; </code>  of the elliptic curve.
 @param lambda The element  <code> &lambda; </code>  of   <code> <b> Z </b> [ &tau; ] </code> .
 @return The norm of <code>&lambda;</code>.
 */
+ (JavaMathBigInteger *)normWithByte:(jbyte)mu
withOrgSpongycastleMathEcZTauElement:(OrgSpongycastleMathEcZTauElement *)lambda;

/*!
 @brief Partial modular reduction modulo 
 <code>(&tau;<sup>m</sup> - 1)/(&tau; - 1)</code>.
 @param k The integer to be reduced.
 @param m The bitlength of the underlying finite field.
 @param a The parameter  <code> a </code>  of the elliptic curve.
 @param s The auxiliary values  <code> s <sub> 0 </sub> </code>
   and   <code> s <sub> 1 </sub> </code>
  .
 @param mu The parameter  &mu;  of the elliptic curve.
 @param c The precision (number of bits of accuracy) of the partial  modular reduction.
 @return <code>&rho; := k partmod (&tau;<sup>m</sup> - 1)/(&tau; - 1)</code>
 */
+ (OrgSpongycastleMathEcZTauElement *)partModReductionWithJavaMathBigInteger:(JavaMathBigInteger *)k
                                                                     withInt:(jint)m
                                                                    withByte:(jbyte)a
                                                 withJavaMathBigIntegerArray:(IOSObjectArray *)s
                                                                    withByte:(jbyte)mu
                                                                    withByte:(jbyte)c;

/*!
 @brief Rounds an element <code>&lambda;</code> of <code><b>R</b>[&tau;]</code>
  to an element of <code><b>Z</b>[&tau;]</code>, such that their difference
  has minimal norm.
 <code>&lambda;</code> is given as 
 <code>&lambda; = &lambda;<sub>0</sub> + &lambda;<sub>1</sub>&tau;</code>.
 @param lambda0 The component  <code> &lambda; <sub> 0 </sub> </code> .
 @param lambda1 The component  <code> &lambda; <sub> 1 </sub> </code> .
 @param mu The parameter  <code> &mu; </code>  of the elliptic curve. Must  equal 1 or -1.
 @return The rounded element of <code><b>Z</b>[&tau;]</code>.
 @throw IllegalArgumentExceptionif <code>lambda0</code> and 
 <code>lambda1</code> do not have same scale.
 */
+ (OrgSpongycastleMathEcZTauElement *)roundWithOrgSpongycastleMathEcSimpleBigDecimal:(OrgSpongycastleMathEcSimpleBigDecimal *)lambda0
                                           withOrgSpongycastleMathEcSimpleBigDecimal:(OrgSpongycastleMathEcSimpleBigDecimal *)lambda1
                                                                            withByte:(jbyte)mu;

/*!
 @brief Applies the operation <code>&tau;()</code> to an 
 <code>ECPoint.AbstractF2m</code>.
 @param p The ECPoint.AbstractF2m to which  <code> &tau; () </code>  is applied.
 @return <code>&tau;(p)</code>
 */
+ (OrgSpongycastleMathEcECPoint_AbstractF2m *)tauWithOrgSpongycastleMathEcECPoint_AbstractF2m:(OrgSpongycastleMathEcECPoint_AbstractF2m *)p;

/*!
 @brief Computes the <code>&tau;</code>-adic NAF (non-adjacent form) of an
  element <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>.
 @param mu The parameter  <code> &mu; </code>  of the elliptic curve.
 @param lambda The element  <code> &lambda; </code>  of   <code> <b> Z </b> [ &tau; ] </code> .
 @return The <code>&tau;</code>-adic NAF of <code>&lambda;</code>.
 */
+ (IOSByteArray *)tauAdicNafWithByte:(jbyte)mu
withOrgSpongycastleMathEcZTauElement:(OrgSpongycastleMathEcZTauElement *)lambda;

/*!
 @brief Computes the <code>[&tau;]</code>-adic window NAF of an element 
 <code>&lambda;</code> of <code><b>Z</b>[&tau;]</code>.
 @param mu The parameter  &mu;  of the elliptic curve.
 @param lambda The element  <code> &lambda; </code>  of   <code> <b> Z </b> [ &tau; ] </code>  of which to compute the   <code> [ &tau; ] </code> -adic NAF.
 @param width The window width of the resulting WNAF.
 @param pow2w 2 <sup> width </sup>
  .
 @param tw The auxiliary value  <code> t <sub> w </sub> </code>
  .
 @param alpha The  <code> &alpha; <sub> u </sub> </code> 's for the window width.
 @return The <code>[&tau;]</code>-adic window NAF of 
 <code>&lambda;</code>.
 */
+ (IOSByteArray *)tauAdicWNafWithByte:(jbyte)mu
 withOrgSpongycastleMathEcZTauElement:(OrgSpongycastleMathEcZTauElement *)lambda
                             withByte:(jbyte)width
               withJavaMathBigInteger:(JavaMathBigInteger *)pow2w
               withJavaMathBigInteger:(JavaMathBigInteger *)tw
withOrgSpongycastleMathEcZTauElementArray:(IOSObjectArray *)alpha;

#pragma mark Protected

+ (jint)getShiftsForCofactorWithJavaMathBigInteger:(JavaMathBigInteger *)h;

#pragma mark Package-Private

- (instancetype)initPackagePrivate;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(OrgSpongycastleMathEcTnaf)

/*!
 @brief The window width of WTNAF.The standard value of 4 is slightly less
  than optimal for running time, but keeps space requirements for
  precomputation low.
 For typical curves, a value of 5 or 6 results in
  a better running time. When changing this value, the 
 <code>&alpha;<sub>u</sub></code>'s must be computed differently, see
  e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
  Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
  p. 121-122
 */
inline jbyte OrgSpongycastleMathEcTnaf_get_WIDTH(void);
#define OrgSpongycastleMathEcTnaf_WIDTH 4
J2OBJC_STATIC_FIELD_CONSTANT(OrgSpongycastleMathEcTnaf, WIDTH, jbyte)

/*!
 @brief 2<sup>4</sup>
 */
inline jbyte OrgSpongycastleMathEcTnaf_get_POW_2_WIDTH(void);
#define OrgSpongycastleMathEcTnaf_POW_2_WIDTH 16
J2OBJC_STATIC_FIELD_CONSTANT(OrgSpongycastleMathEcTnaf, POW_2_WIDTH, jbyte)

/*!
 @brief The <code>&alpha;<sub>u</sub></code>'s for <code>a=0</code> as an array
  of <code>ZTauElement</code>s.
 */
inline IOSObjectArray *OrgSpongycastleMathEcTnaf_get_alpha0(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *OrgSpongycastleMathEcTnaf_alpha0;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgSpongycastleMathEcTnaf, alpha0, IOSObjectArray *)

/*!
 @brief The <code>&alpha;<sub>u</sub></code>'s for <code>a=0</code> as an array
  of TNAFs.
 */
inline IOSObjectArray *OrgSpongycastleMathEcTnaf_get_alpha0Tnaf(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *OrgSpongycastleMathEcTnaf_alpha0Tnaf;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgSpongycastleMathEcTnaf, alpha0Tnaf, IOSObjectArray *)

/*!
 @brief The <code>&alpha;<sub>u</sub></code>'s for <code>a=1</code> as an array
  of <code>ZTauElement</code>s.
 */
inline IOSObjectArray *OrgSpongycastleMathEcTnaf_get_alpha1(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *OrgSpongycastleMathEcTnaf_alpha1;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgSpongycastleMathEcTnaf, alpha1, IOSObjectArray *)

/*!
 @brief The <code>&alpha;<sub>u</sub></code>'s for <code>a=1</code> as an array
  of TNAFs.
 */
inline IOSObjectArray *OrgSpongycastleMathEcTnaf_get_alpha1Tnaf(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *OrgSpongycastleMathEcTnaf_alpha1Tnaf;
J2OBJC_STATIC_FIELD_OBJ_FINAL(OrgSpongycastleMathEcTnaf, alpha1Tnaf, IOSObjectArray *)

FOUNDATION_EXPORT void OrgSpongycastleMathEcTnaf_initPackagePrivate(OrgSpongycastleMathEcTnaf *self);

FOUNDATION_EXPORT OrgSpongycastleMathEcTnaf *new_OrgSpongycastleMathEcTnaf_initPackagePrivate(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT OrgSpongycastleMathEcTnaf *create_OrgSpongycastleMathEcTnaf_initPackagePrivate(void);

FOUNDATION_EXPORT JavaMathBigInteger *OrgSpongycastleMathEcTnaf_normWithByte_withOrgSpongycastleMathEcZTauElement_(jbyte mu, OrgSpongycastleMathEcZTauElement *lambda);

FOUNDATION_EXPORT OrgSpongycastleMathEcSimpleBigDecimal *OrgSpongycastleMathEcTnaf_normWithByte_withOrgSpongycastleMathEcSimpleBigDecimal_withOrgSpongycastleMathEcSimpleBigDecimal_(jbyte mu, OrgSpongycastleMathEcSimpleBigDecimal *u, OrgSpongycastleMathEcSimpleBigDecimal *v);

FOUNDATION_EXPORT OrgSpongycastleMathEcZTauElement *OrgSpongycastleMathEcTnaf_roundWithOrgSpongycastleMathEcSimpleBigDecimal_withOrgSpongycastleMathEcSimpleBigDecimal_withByte_(OrgSpongycastleMathEcSimpleBigDecimal *lambda0, OrgSpongycastleMathEcSimpleBigDecimal *lambda1, jbyte mu);

FOUNDATION_EXPORT OrgSpongycastleMathEcSimpleBigDecimal *OrgSpongycastleMathEcTnaf_approximateDivisionByNWithJavaMathBigInteger_withJavaMathBigInteger_withJavaMathBigInteger_withByte_withInt_withInt_(JavaMathBigInteger *k, JavaMathBigInteger *s, JavaMathBigInteger *vm, jbyte a, jint m, jint c);

FOUNDATION_EXPORT IOSByteArray *OrgSpongycastleMathEcTnaf_tauAdicNafWithByte_withOrgSpongycastleMathEcZTauElement_(jbyte mu, OrgSpongycastleMathEcZTauElement *lambda);

FOUNDATION_EXPORT OrgSpongycastleMathEcECPoint_AbstractF2m *OrgSpongycastleMathEcTnaf_tauWithOrgSpongycastleMathEcECPoint_AbstractF2m_(OrgSpongycastleMathEcECPoint_AbstractF2m *p);

FOUNDATION_EXPORT jbyte OrgSpongycastleMathEcTnaf_getMuWithOrgSpongycastleMathEcECCurve_AbstractF2m_(OrgSpongycastleMathEcECCurve_AbstractF2m *curve);

FOUNDATION_EXPORT jbyte OrgSpongycastleMathEcTnaf_getMuWithOrgSpongycastleMathEcECFieldElement_(OrgSpongycastleMathEcECFieldElement *curveA);

FOUNDATION_EXPORT jbyte OrgSpongycastleMathEcTnaf_getMuWithInt_(jint curveA);

FOUNDATION_EXPORT IOSObjectArray *OrgSpongycastleMathEcTnaf_getLucasWithByte_withInt_withBoolean_(jbyte mu, jint k, jboolean doV);

FOUNDATION_EXPORT JavaMathBigInteger *OrgSpongycastleMathEcTnaf_getTwWithByte_withInt_(jbyte mu, jint w);

FOUNDATION_EXPORT IOSObjectArray *OrgSpongycastleMathEcTnaf_getSiWithOrgSpongycastleMathEcECCurve_AbstractF2m_(OrgSpongycastleMathEcECCurve_AbstractF2m *curve);

FOUNDATION_EXPORT IOSObjectArray *OrgSpongycastleMathEcTnaf_getSiWithInt_withInt_withJavaMathBigInteger_(jint fieldSize, jint curveA, JavaMathBigInteger *cofactor);

FOUNDATION_EXPORT jint OrgSpongycastleMathEcTnaf_getShiftsForCofactorWithJavaMathBigInteger_(JavaMathBigInteger *h);

FOUNDATION_EXPORT OrgSpongycastleMathEcZTauElement *OrgSpongycastleMathEcTnaf_partModReductionWithJavaMathBigInteger_withInt_withByte_withJavaMathBigIntegerArray_withByte_withByte_(JavaMathBigInteger *k, jint m, jbyte a, IOSObjectArray *s, jbyte mu, jbyte c);

FOUNDATION_EXPORT OrgSpongycastleMathEcECPoint_AbstractF2m *OrgSpongycastleMathEcTnaf_multiplyRTnafWithOrgSpongycastleMathEcECPoint_AbstractF2m_withJavaMathBigInteger_(OrgSpongycastleMathEcECPoint_AbstractF2m *p, JavaMathBigInteger *k);

FOUNDATION_EXPORT OrgSpongycastleMathEcECPoint_AbstractF2m *OrgSpongycastleMathEcTnaf_multiplyTnafWithOrgSpongycastleMathEcECPoint_AbstractF2m_withOrgSpongycastleMathEcZTauElement_(OrgSpongycastleMathEcECPoint_AbstractF2m *p, OrgSpongycastleMathEcZTauElement *lambda);

FOUNDATION_EXPORT OrgSpongycastleMathEcECPoint_AbstractF2m *OrgSpongycastleMathEcTnaf_multiplyFromTnafWithOrgSpongycastleMathEcECPoint_AbstractF2m_withByteArray_(OrgSpongycastleMathEcECPoint_AbstractF2m *p, IOSByteArray *u);

FOUNDATION_EXPORT IOSByteArray *OrgSpongycastleMathEcTnaf_tauAdicWNafWithByte_withOrgSpongycastleMathEcZTauElement_withByte_withJavaMathBigInteger_withJavaMathBigInteger_withOrgSpongycastleMathEcZTauElementArray_(jbyte mu, OrgSpongycastleMathEcZTauElement *lambda, jbyte width, JavaMathBigInteger *pow2w, JavaMathBigInteger *tw, IOSObjectArray *alpha);

FOUNDATION_EXPORT IOSObjectArray *OrgSpongycastleMathEcTnaf_getPreCompWithOrgSpongycastleMathEcECPoint_AbstractF2m_withByte_(OrgSpongycastleMathEcECPoint_AbstractF2m *p, jbyte a);

J2OBJC_TYPE_LITERAL_HEADER(OrgSpongycastleMathEcTnaf)

#endif

#pragma pop_macro("INCLUDE_ALL_Tnaf")
