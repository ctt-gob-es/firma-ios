//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/es/gob/afirma/core/signers/der/DerIndefLenConverter.java
//

#include "DerIndefLenConverter.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/IOException.h"
#include "java/lang/IndexOutOfBoundsException.h"
#include "java/lang/Integer.h"
#include "java/lang/System.h"
#include "java/util/ArrayList.h"

#if !__has_feature(objc_arc)
#error "DerIndefLenConverter must be compiled with ARC (-fobjc-arc)"
#endif

@interface EsGobAfirmaCoreSignersDerDerIndefLenConverter () {
 @public
  IOSByteArray *data_;
  IOSByteArray *newData_;
  jint newDataPos_;
  jint dataPos_;
  jint dataSize_;
  jint index_;
  jint unresolved_;
  JavaUtilArrayList *ndefsList_;
  jint numOfTotalLenBytes_;
}

- (jboolean)isEOCWithInt:(jint)tag;

/*!
 @brief Parse the tag and if it is an end-of-contents tag then
  add the current position to the <code>eocList</code> vector.
 */
- (void)parseTag;

/*!
 @brief Write the tag and if it is an end-of-contents tag
  then skip the tag and its 1 byte length of zero.
 */
- (void)writeTag;

/*!
 @brief Parse the length and if it is an indefinite length then add
  the current position to the <code>ndefsList</code> vector.
 */
- (jint)parseLength;

/*!
 @brief Write the length and if it is an indefinite length
  then calculate the definite length from the positions
  of the indefinite length and its matching EOC terminator.
 Then, write the value.
 */
- (void)writeLengthAndValue;

- (void)writeLengthWithInt:(jint)curLen;

- (IOSByteArray *)getLengthBytesWithInt:(jint)curLen;

- (jint)getNumOfLenBytesWithInt:(jint)len;

/*!
 @brief Parse the value;
 */
- (void)parseValueWithInt:(jint)curLen;

/*!
 @brief Write the value;
 */
- (void)writeValueWithInt:(jint)curLen;

@end

J2OBJC_FIELD_SETTER(EsGobAfirmaCoreSignersDerDerIndefLenConverter, data_, IOSByteArray *)
J2OBJC_FIELD_SETTER(EsGobAfirmaCoreSignersDerDerIndefLenConverter, newData_, IOSByteArray *)
J2OBJC_FIELD_SETTER(EsGobAfirmaCoreSignersDerDerIndefLenConverter, ndefsList_, JavaUtilArrayList *)

inline jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_get_TAG_MASK(void);
#define EsGobAfirmaCoreSignersDerDerIndefLenConverter_TAG_MASK 31
J2OBJC_STATIC_FIELD_CONSTANT(EsGobAfirmaCoreSignersDerDerIndefLenConverter, TAG_MASK, jint)

inline jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_get_FORM_MASK(void);
#define EsGobAfirmaCoreSignersDerDerIndefLenConverter_FORM_MASK 32
J2OBJC_STATIC_FIELD_CONSTANT(EsGobAfirmaCoreSignersDerDerIndefLenConverter, FORM_MASK, jint)

inline jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_get_CLASS_MASK(void);
#define EsGobAfirmaCoreSignersDerDerIndefLenConverter_CLASS_MASK 192
J2OBJC_STATIC_FIELD_CONSTANT(EsGobAfirmaCoreSignersDerDerIndefLenConverter, CLASS_MASK, jint)

inline jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_get_LEN_LONG(void);
#define EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_LONG 128
J2OBJC_STATIC_FIELD_CONSTANT(EsGobAfirmaCoreSignersDerDerIndefLenConverter, LEN_LONG, jint)

inline jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_get_LEN_MASK(void);
#define EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_MASK 127
J2OBJC_STATIC_FIELD_CONSTANT(EsGobAfirmaCoreSignersDerDerIndefLenConverter, LEN_MASK, jint)

inline jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_get_SKIP_EOC_BYTES(void);
#define EsGobAfirmaCoreSignersDerDerIndefLenConverter_SKIP_EOC_BYTES 2
J2OBJC_STATIC_FIELD_CONSTANT(EsGobAfirmaCoreSignersDerDerIndefLenConverter, SKIP_EOC_BYTES, jint)

__attribute__((unused)) static jboolean EsGobAfirmaCoreSignersDerDerIndefLenConverter_isEOCWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint tag);

__attribute__((unused)) static void EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseTag(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self);

__attribute__((unused)) static void EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeTag(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self);

__attribute__((unused)) static jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseLength(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self);

__attribute__((unused)) static void EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeLengthAndValue(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self);

__attribute__((unused)) static void EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeLengthWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint curLen);

__attribute__((unused)) static IOSByteArray *EsGobAfirmaCoreSignersDerDerIndefLenConverter_getLengthBytesWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint curLen);

__attribute__((unused)) static jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_getNumOfLenBytesWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint len);

__attribute__((unused)) static void EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseValueWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint curLen);

__attribute__((unused)) static void EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeValueWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint curLen);

#line 1 "/Users/desarrolloabamobile/Downloads/pades-ios-mini/src/main/java/es/gob/afirma/core/signers/der/DerIndefLenConverter.java"


#line 41
@implementation EsGobAfirmaCoreSignersDerDerIndefLenConverter


#line 59
- (jboolean)isEOCWithInt:(jint)tag {
  return EsGobAfirmaCoreSignersDerDerIndefLenConverter_isEOCWithInt_(self, tag);
}


#line 66
+ (jboolean)isLongFormWithInt:(jint)lengthByte {
  return EsGobAfirmaCoreSignersDerDerIndefLenConverter_isLongFormWithInt_(lengthByte);
}


#line 73
- (instancetype)initPackagePrivate {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_initPackagePrivate(self);
  return self;
}


#line 84
+ (jboolean)isIndefiniteWithInt:(jint)lengthByte {
  return EsGobAfirmaCoreSignersDerDerIndefLenConverter_isIndefiniteWithInt_(lengthByte);
}


#line 92
- (void)parseTag {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseTag(self);
}


#line 137
- (void)writeTag {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeTag(self);
}


#line 154
- (jint)parseLength {
  return EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseLength(self);
}


#line 191
- (void)writeLengthAndValue {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeLengthAndValue(self);
}


#line 219
- (void)writeLengthWithInt:(jint)curLen {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeLengthWithInt_(self, curLen);
}


#line 247
- (IOSByteArray *)getLengthBytesWithInt:(jint)curLen {
  return EsGobAfirmaCoreSignersDerDerIndefLenConverter_getLengthBytesWithInt_(self, curLen);
}


#line 287
- (jint)getNumOfLenBytesWithInt:(jint)len {
  return EsGobAfirmaCoreSignersDerDerIndefLenConverter_getNumOfLenBytesWithInt_(self, len);
}


#line 307
- (void)parseValueWithInt:(jint)curLen {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseValueWithInt_(self, curLen);
}


#line 314
- (void)writeValueWithInt:(jint)curLen {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeValueWithInt_(self, curLen);
}


#line 330
- (IOSByteArray *)convertWithByteArray:(IOSByteArray *)indefData {
  self->data_ = indefData;
  self->dataPos_ = 0;
  
#line 332
  self->index_ = 0;
  self->dataSize_ = ((IOSByteArray *) nil_chk(self->data_))->size_;
  jint len = 0;
  __unused jint unused = 0;
  
#line 338
  while (self->dataPos_ < self->dataSize_) {
    EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseTag(self);
    len = EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseLength(self);
    EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseValueWithInt_(self, len);
    if (self->unresolved_ == 0) {
      unused = self->dataSize_ - self->dataPos_;
      self->dataSize_ = self->dataPos_;
      break;
    }
  }
  
#line 349
  if (self->unresolved_ != 0) {
    @throw new_JavaIoIOException_initWithNSString_(@"not all indef len BER resolved");
  }
  
#line 353
  self->newData_ = [IOSByteArray newArrayWithLength:self->dataSize_ + self->numOfTotalLenBytes_ + unused];
  self->dataPos_ = 0;
  
#line 354
  self->newDataPos_ = 0;
  
#line 354
  self->index_ = 0;
  
#line 358
  while (self->dataPos_ < self->dataSize_) {
    EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeTag(self);
    EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeLengthAndValue(self);
  }
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(indefData, self->dataSize_,
#line 363
  self->newData_, self->dataSize_ + self->numOfTotalLenBytes_, unused);
  
#line 365
  return self->newData_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, "Z", 0x2, 0, 1, -1, -1, -1, -1 },
    { NULL, "Z", 0x8, 2, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x0, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x8, 3, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x2, -1, -1, 4, -1, -1, -1 },
    { NULL, "V", 0x2, 5, 1, -1, -1, -1, -1 },
    { NULL, "[B", 0x2, 6, 1, -1, -1, -1, -1 },
    { NULL, "I", 0x2, 7, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 8, 1, -1, -1, -1, -1 },
    { NULL, "V", 0x2, 9, 1, -1, -1, -1, -1 },
    { NULL, "[B", 0x0, 10, 11, 4, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(isEOCWithInt:);
  methods[1].selector = @selector(isLongFormWithInt:);
  methods[2].selector = @selector(initPackagePrivate);
  methods[3].selector = @selector(isIndefiniteWithInt:);
  methods[4].selector = @selector(parseTag);
  methods[5].selector = @selector(writeTag);
  methods[6].selector = @selector(parseLength);
  methods[7].selector = @selector(writeLengthAndValue);
  methods[8].selector = @selector(writeLengthWithInt:);
  methods[9].selector = @selector(getLengthBytesWithInt:);
  methods[10].selector = @selector(getNumOfLenBytesWithInt:);
  methods[11].selector = @selector(parseValueWithInt:);
  methods[12].selector = @selector(writeValueWithInt:);
  methods[13].selector = @selector(convertWithByteArray:);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "TAG_MASK", "I", .constantValue.asInt = EsGobAfirmaCoreSignersDerDerIndefLenConverter_TAG_MASK, 0x1a, -1, -1, -1, -1 },
    { "FORM_MASK", "I", .constantValue.asInt = EsGobAfirmaCoreSignersDerDerIndefLenConverter_FORM_MASK, 0x1a, -1, -1, -1, -1 },
    { "CLASS_MASK", "I", .constantValue.asInt = EsGobAfirmaCoreSignersDerDerIndefLenConverter_CLASS_MASK, 0x1a, -1, -1, -1, -1 },
    { "LEN_LONG", "I", .constantValue.asInt = EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_LONG, 0x1a, -1, -1, -1, -1 },
    { "LEN_MASK", "I", .constantValue.asInt = EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_MASK, 0x1a, -1, -1, -1, -1 },
    { "SKIP_EOC_BYTES", "I", .constantValue.asInt = EsGobAfirmaCoreSignersDerDerIndefLenConverter_SKIP_EOC_BYTES, 0x1a, -1, -1, -1, -1 },
    { "data_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "newData_", "[B", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "newDataPos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "dataPos_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "dataSize_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "index_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "unresolved_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
    { "ndefsList_", "LJavaUtilArrayList;", .constantValue.asLong = 0, 0x12, -1, -1, 12, -1 },
    { "numOfTotalLenBytes_", "I", .constantValue.asLong = 0, 0x2, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "isEOC", "I", "isLongForm", "isIndefinite", "LJavaIoIOException;", "writeLength", "getLengthBytes", "getNumOfLenBytes", "parseValue", "writeValue", "convert", "[B", "Ljava/util/ArrayList<Ljava/lang/Object;>;" };
  static const J2ObjcClassInfo _EsGobAfirmaCoreSignersDerDerIndefLenConverter = { "DerIndefLenConverter", "es.gob.afirma.core.signers.der", ptrTable, methods, fields, 7, 0x0, 14, 15, -1, -1, -1, -1, -1 };
  return &_EsGobAfirmaCoreSignersDerDerIndefLenConverter;
}

@end


#line 59
jboolean EsGobAfirmaCoreSignersDerDerIndefLenConverter_isEOCWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint tag) {
  return (tag & EsGobAfirmaCoreSignersDerDerIndefLenConverter_TAG_MASK) == (jint) 0x00 &&
#line 61
  (tag & EsGobAfirmaCoreSignersDerDerIndefLenConverter_FORM_MASK) == (jint) 0x00 &&
#line 62
  (tag & EsGobAfirmaCoreSignersDerDerIndefLenConverter_CLASS_MASK) == (jint) 0x00;
}


#line 66
jboolean EsGobAfirmaCoreSignersDerDerIndefLenConverter_isLongFormWithInt_(jint lengthByte) {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_initialize();
  
#line 67
  return (lengthByte & EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_LONG) == EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_LONG;
}

void EsGobAfirmaCoreSignersDerDerIndefLenConverter_initPackagePrivate(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self) {
  NSObject_init(self);
  self->unresolved_ =
#line 53
  0;
  self->ndefsList_ = new_JavaUtilArrayList_init();
  self->numOfTotalLenBytes_ =
#line 57
  0;
}


#line 73
EsGobAfirmaCoreSignersDerDerIndefLenConverter *new_EsGobAfirmaCoreSignersDerDerIndefLenConverter_initPackagePrivate() {
  J2OBJC_NEW_IMPL(EsGobAfirmaCoreSignersDerDerIndefLenConverter, initPackagePrivate)
}


#line 73
EsGobAfirmaCoreSignersDerDerIndefLenConverter *create_EsGobAfirmaCoreSignersDerDerIndefLenConverter_initPackagePrivate() {
  J2OBJC_CREATE_IMPL(EsGobAfirmaCoreSignersDerDerIndefLenConverter, initPackagePrivate)
}


#line 84
jboolean EsGobAfirmaCoreSignersDerDerIndefLenConverter_isIndefiniteWithInt_(jint lengthByte) {
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_initialize();
  
#line 85
  return EsGobAfirmaCoreSignersDerDerIndefLenConverter_isLongFormWithInt_(lengthByte) && (lengthByte & EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_MASK) == 0;
}


#line 92
void EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseTag(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self) {
  if (self->dataPos_ == self->dataSize_) {
    return;
  }
  @try {
    if (EsGobAfirmaCoreSignersDerDerIndefLenConverter_isEOCWithInt_(self, IOSByteArray_Get(nil_chk(self->data_), self->dataPos_)) && IOSByteArray_Get(nil_chk(self->data_), self->dataPos_ + 1) == 0) {
      jint numOfEncapsulatedLenBytes = 0;
      id elem = nil;
      jint index;
      for (index = [((JavaUtilArrayList *) nil_chk(self->ndefsList_)) size] - 1; index >= 0; index--) {
        
#line 104
        elem = [self->ndefsList_ getWithInt:index];
        if ([elem isKindOfClass:[JavaLangInteger class]]) {
          break;
        }
        else {
          
#line 108
          numOfEncapsulatedLenBytes += ((IOSByteArray *) nil_chk(((IOSByteArray *) cast_chk(elem, [IOSByteArray class]))))->size_ - 3;
        }
      }
      if (index < 0) {
        @throw new_JavaIoIOException_initWithNSString_(@"EOC does not have matching indefinite-length tag");
      }
      
#line 115
      jint sectionLen = self->dataPos_ - [((JavaLangInteger *) nil_chk(((JavaLangInteger *) cast_chk(elem, [JavaLangInteger class])))) intValue] +
#line 116
      numOfEncapsulatedLenBytes;
      IOSByteArray *sectionLenBytes = EsGobAfirmaCoreSignersDerDerIndefLenConverter_getLengthBytesWithInt_(self, sectionLen);
      (void) [self->ndefsList_ setWithInt:index withId:sectionLenBytes];
      self->unresolved_--;
      
#line 125
      self->numOfTotalLenBytes_ += ((IOSByteArray *) nil_chk(sectionLenBytes))->size_ - 3;
    }
    self->dataPos_++;
  }
  @catch (
#line 128
  JavaLangIndexOutOfBoundsException *iobe) {
    @throw new_JavaIoIOException_initWithJavaLangThrowable_(iobe);
  }
}


#line 137
void EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeTag(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self) {
  if (self->dataPos_ == self->dataSize_) {
    return;
  }
  jint tag = IOSByteArray_Get(nil_chk(self->data_), self->dataPos_++);
  if (EsGobAfirmaCoreSignersDerDerIndefLenConverter_isEOCWithInt_(self, tag) && IOSByteArray_Get(nil_chk(self->data_), self->dataPos_) == 0) {
    self->dataPos_++;
    EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeTag(self);
  }
  else {
    
#line 146
    *IOSByteArray_GetRef(nil_chk(self->newData_), self->newDataPos_++) = (jbyte) tag;
  }
}


#line 154
jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseLength(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self) {
  jint curLen = 0;
  if (self->dataPos_ == self->dataSize_) {
    return curLen;
  }
  jint lenByte = IOSByteArray_Get(nil_chk(self->data_), self->dataPos_++) & (jint) 0xff;
  if (EsGobAfirmaCoreSignersDerDerIndefLenConverter_isIndefiniteWithInt_(lenByte)) {
    [((JavaUtilArrayList *) nil_chk(self->ndefsList_)) addWithId:new_JavaLangInteger_initWithInt_(self->dataPos_)];
    self->unresolved_++;
    return curLen;
  }
  if (EsGobAfirmaCoreSignersDerDerIndefLenConverter_isLongFormWithInt_(lenByte)) {
    lenByte &= EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_MASK;
    if (lenByte > 4) {
      @throw new_JavaIoIOException_initWithNSString_(@"Too much data");
    }
    if (self->dataSize_ - self->dataPos_ < lenByte + 1) {
      @throw new_JavaIoIOException_initWithNSString_(@"Too little data");
    }
    for (jint i = 0; i < lenByte; i++) {
      curLen = (JreLShift32(curLen, 8)) + (IOSByteArray_Get(nil_chk(self->data_), self->dataPos_++) & (jint) 0xff);
    }
    if (curLen < 0) {
      @throw new_JavaIoIOException_initWithNSString_(@"Invalid length bytes");
    }
  }
  else {
    
#line 180
    curLen = lenByte & EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_MASK;
  }
  return curLen;
}


#line 191
void EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeLengthAndValue(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self) {
  if (self->dataPos_ == self->dataSize_) {
    return;
  }
  jint curLen = 0;
  jint lenByte = IOSByteArray_Get(nil_chk(self->data_), self->dataPos_++) & (jint) 0xff;
  if (EsGobAfirmaCoreSignersDerDerIndefLenConverter_isIndefiniteWithInt_(lenByte)) {
    IOSByteArray *lenBytes = (IOSByteArray *) cast_chk([((JavaUtilArrayList *) nil_chk(self->ndefsList_)) getWithInt:self->index_++], [IOSByteArray class]);
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(lenBytes, 0, self->newData_, self->newDataPos_, ((IOSByteArray *) nil_chk(
#line 200
    lenBytes))->size_);
    self->newDataPos_ += lenBytes->size_;
    return;
  }
  if (EsGobAfirmaCoreSignersDerDerIndefLenConverter_isLongFormWithInt_(lenByte)) {
    lenByte &= EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_MASK;
    for (jint i = 0; i < lenByte; i++) {
      curLen = (JreLShift32(curLen, 8)) + (IOSByteArray_Get(nil_chk(self->data_), self->dataPos_++) & (jint) 0xff);
    }
    if (curLen < 0) {
      @throw new_JavaIoIOException_initWithNSString_(@"Invalid length bytes");
    }
  }
  else {
    
#line 213
    curLen = lenByte & EsGobAfirmaCoreSignersDerDerIndefLenConverter_LEN_MASK;
  }
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeLengthWithInt_(self, curLen);
  EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeValueWithInt_(self, curLen);
}


#line 219
void EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeLengthWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint curLen) {
  if (curLen < 128) {
    *IOSByteArray_GetRef(nil_chk(self->newData_), self->newDataPos_++) = (jbyte) curLen;
  }
  else if (curLen < JreLShift32(1, 8)) {
    *IOSByteArray_GetRef(nil_chk(self->newData_), self->newDataPos_++) = (jbyte) (jint) 0x81;
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) curLen;
  }
  else if (curLen < JreLShift32(1, 16)) {
    *IOSByteArray_GetRef(nil_chk(self->newData_), self->newDataPos_++) = (jbyte) (jint) 0x82;
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) (JreRShift32(curLen, 8));
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) curLen;
  }
  else if (curLen < JreLShift32(1, 24)) {
    *IOSByteArray_GetRef(nil_chk(self->newData_), self->newDataPos_++) = (jbyte) (jint) 0x83;
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) (JreRShift32(curLen, 16));
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) (JreRShift32(curLen, 8));
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) curLen;
  }
  else {
    *IOSByteArray_GetRef(nil_chk(self->newData_), self->newDataPos_++) = (jbyte) (jint) 0x84;
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) (JreRShift32(curLen, 24));
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) (JreRShift32(curLen, 16));
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) (JreRShift32(curLen, 8));
    *IOSByteArray_GetRef(self->newData_, self->newDataPos_++) = (jbyte) curLen;
  }
}

IOSByteArray *EsGobAfirmaCoreSignersDerDerIndefLenConverter_getLengthBytesWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint curLen) {
  IOSByteArray *lenBytes;
  jint index = 0;
  
#line 251
  if (curLen < 128) {
    lenBytes = [IOSByteArray newArrayWithLength:1];
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) curLen;
  }
  else if (curLen < JreLShift32(1, 8)) {
    lenBytes = [IOSByteArray newArrayWithLength:2];
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (jint) 0x81;
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) curLen;
  }
  else if (curLen < JreLShift32(1, 16)) {
    lenBytes = [IOSByteArray newArrayWithLength:3];
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (jint) 0x82;
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (JreRShift32(curLen, 8));
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) curLen;
  }
  else if (curLen < JreLShift32(1, 24)) {
    lenBytes = [IOSByteArray newArrayWithLength:4];
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (jint) 0x83;
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (JreRShift32(curLen, 16));
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (JreRShift32(curLen, 8));
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) curLen;
  }
  else {
    lenBytes = [IOSByteArray newArrayWithLength:5];
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (jint) 0x84;
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (JreRShift32(curLen, 24));
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (JreRShift32(curLen, 16));
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) (JreRShift32(curLen, 8));
    *IOSByteArray_GetRef(lenBytes, index++) = (jbyte) curLen;
  }
  
#line 282
  return lenBytes;
}

jint EsGobAfirmaCoreSignersDerDerIndefLenConverter_getNumOfLenBytesWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint len) {
  jint numOfLenBytes = 0;
  
#line 290
  if (len < 128) {
    numOfLenBytes = 1;
  }
  else
#line 292
  if (len < JreLShift32(1, 8)) {
    numOfLenBytes = 2;
  }
  else
#line 294
  if (len < JreLShift32(1, 16)) {
    numOfLenBytes = 3;
  }
  else
#line 296
  if (len < JreLShift32(1, 24)) {
    numOfLenBytes = 4;
  }
  else {
    
#line 299
    numOfLenBytes = 5;
  }
  return numOfLenBytes;
}


#line 307
void EsGobAfirmaCoreSignersDerDerIndefLenConverter_parseValueWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint curLen) {
  self->dataPos_ += curLen;
}


#line 314
void EsGobAfirmaCoreSignersDerDerIndefLenConverter_writeValueWithInt_(EsGobAfirmaCoreSignersDerDerIndefLenConverter *self, jint curLen) {
  for (jint i = 0; i < curLen; i++) {
    *IOSByteArray_GetRef(nil_chk(self->newData_), self->newDataPos_++) = IOSByteArray_Get(nil_chk(self->data_), self->dataPos_++);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EsGobAfirmaCoreSignersDerDerIndefLenConverter)
