//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/desarrolloabamobile/Documents/JAVA/pades-ios/src/main/java/com/aowagie/text/pdf/BaseFont.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_BaseFont")
#ifdef RESTRICT_BaseFont
#define INCLUDE_ALL_BaseFont 0
#else
#define INCLUDE_ALL_BaseFont 1
#endif
#undef RESTRICT_BaseFont

#if !defined (ComAowagieTextPdfBaseFont_) && (INCLUDE_ALL_BaseFont || defined(INCLUDE_ComAowagieTextPdfBaseFont))
#define ComAowagieTextPdfBaseFont_

@class ComAowagieTextPdfIntHashtable;
@class ComAowagieTextPdfPRIndirectReference;
@class ComAowagieTextPdfPdfIndirectReference;
@class ComAowagieTextPdfPdfReader;
@class ComAowagieTextPdfPdfStream;
@class ComAowagieTextPdfPdfWriter;
@class IOSByteArray;
@class IOSCharArray;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaIoInputStream;
@class JavaLangClassLoader;
@class JavaUtilArrayList;
@class JavaUtilHashMap;

/*!
 @brief Base class for the several font types supported
 @author Paulo Soares (psoares@@consiste.pt)
 */
@interface ComAowagieTextPdfBaseFont : NSObject {
 @public
  JavaUtilArrayList *subsetRanges_;
  /*!
   @brief The font type.
   */
  jint fontType_;
  /*!
   @brief table of characters widths for this encoding
   */
  IOSIntArray *widths_;
  /*!
   @brief encoding names
   */
  IOSObjectArray *differences_;
  /*!
   @brief same as differences but with the unicode codes
   */
  IOSCharArray *unicodeDifferences_;
  IOSObjectArray *charBBoxes_;
  /*!
   @brief encoding used with this font
   */
  NSString *encoding_;
  /*!
   @brief true if the font is to be embedded in the PDF
   */
  jboolean embedded_;
  /*!
   @brief The compression level for the font stream.
   @since 2.1.3
   */
  jint compressionLevel_;
  /*!
   @brief true if the font must use its built in encoding.In that case the 
 <CODE>encoding</CODE> is only used to map a char to the position inside
  the font, not to the expected char name.
   */
  jboolean fontSpecific_;
  /*!
   @brief Forces the output of the width array.Only matters for the 14
  built-in fonts.
   */
  jboolean forceWidthsOutput_;
  /*!
   @brief Converts <CODE>char</CODE> directly to <CODE>byte</CODE>
  by casting.
   */
  jboolean directTextToByte_;
  /*!
   @brief Indicates if all the glyphs and widths for that particular
  encoding should be included in the document.
   */
  jboolean subset_;
  jboolean fastWinansi_;
  /*!
   @brief Custom encodings use this map to key the Unicode character
  to the single byte code.
   */
  ComAowagieTextPdfIntHashtable *specialMap_;
}

#pragma mark Public

/*!
 @brief Adds a character range when subsetting.The range is an <CODE>int</CODE> array
  where the first element is the start range inclusive and the second element is the
  end range inclusive.
 Several ranges are allowed in the same array.
 @param range the character range
 */
- (void)addSubsetRangeWithIntArray:(IOSIntArray *)range;

/*!
 @brief Checks if a character exists in this font.
 @param c the character to check
 @return <CODE>true</CODE> if the character has a glyph, 
 <CODE>false</CODE> otherwise
 */
- (jboolean)charExistsWithInt:(jint)c;

/*!
 @brief iText expects Arabic Diactrics (tashkeel) to have zero advance but some fonts,
  most notably those that come with Windows, like times.ttf, have non-zero
  advance for those characters.This method makes those character to have zero
  width advance and work correctly in the iText Arabic shaping and reordering
  context.
 */
- (void)correctArabicAdvance;

/*!
 @brief Creates a new font.This will always be the default Helvetica font (not embedded).
 This method is introduced because Helvetica is used in many examples.
 @return a BaseFont object (Helvetica, Winansi, not embedded)
 @throw IOExceptionThis shouldn't occur ever
 @throw DocumentExceptionThis shouldn't occur ever
 @since 2.1.1
 */
+ (ComAowagieTextPdfBaseFont *)createFont;

/*!
 @brief Creates a font based on an existing document font.The created font font may not
  behave as expected, depending on the encoding or subset.
 @param fontRef the reference to the document font
 @return the font
 */
+ (ComAowagieTextPdfBaseFont *)createFontWithComAowagieTextPdfPRIndirectReference:(ComAowagieTextPdfPRIndirectReference *)fontRef;

/*!
 @brief Creates a new font.This font can be one of the 14 built in types,
  a Type1 font referred to by an AFM or PFM file, a TrueType font (simple or collection) or a CJK font from the
  Adobe Asian Font Pack.
 TrueType fonts and CJK fonts can have an optional style modifier
  appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
  example would be "STSong-Light,Bold". Note that this modifiers do not work if
  the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
  This would get the second font (indexes start at 0), in this case "MS PGothic". 
 <P>
  The fonts are cached and if they already exist they are extracted from the cache,
  not parsed again. 
 <P>
  Besides the common encodings described by name, custom encodings
  can also be made. These encodings will only work for the single byte fonts
  Type1 and TrueType. The encoding string starts with a '#'
  followed by "simple" or "full". If "simple" there is a decimal for the first character position and then a list
  of hex values representing the Unicode codes that compose that encoding.<br>
  The "simple" encoding is recommended for TrueType fonts
  as the "full" encoding risks not matching the character with the right glyph
  if not done with care.<br>
  The "full" encoding is specially aimed at Type1 fonts where the glyphs have to be
  described by non standard names like the Tex math fonts. Each group of three elements
  compose a code position: the one byte code order in decimal or as 'x' (x cannot be the space), the name and the Unicode character
  used to access the glyph. The space must be assigned to character position 32 otherwise
  text justification will not work. 
 <P>
  Example for a "simple" encoding that includes the Unicode
  character space, A, B and ecyrillic: 
 @code

  "# simple 32 0020 0041 0042 0454" 
  
@endcode
  <P>
  Example for a "full" encoding for a Type1 Tex font: 
 @code

  "# full 'A' nottriangeqlleft 0041 'B' dividemultiply 0042 32 space 0020" 
  
@endcode
  <P>
  This method calls:<br>
  @code

  createFont(name, encoding, embedded, true, null, null); 
  
@endcode
 @param name the name of the font or its location on file
 @param encoding the encoding to be applied to this font
 @param embedded true if the font is to be embedded in the PDF
 @return returns a new font. This font may come from the cache
 @throw DocumentExceptionthe font is invalid
 @throw IOExceptionthe font file could not be read
 */
+ (ComAowagieTextPdfBaseFont *)createFontWithNSString:(NSString *)name
                                         withNSString:(NSString *)encoding
                                          withBoolean:(jboolean)embedded;

/*!
 @brief Creates a new font.This font can be one of the 14 built in types,
  a Type1 font referred to by an AFM or PFM file, a TrueType font (simple or collection) or a CJK font from the
  Adobe Asian Font Pack.
 TrueType fonts and CJK fonts can have an optional style modifier
  appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
  example would be "STSong-Light,Bold". Note that this modifiers do not work if
  the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
  This would get the second font (indexes start at 0), in this case "MS PGothic". 
 <P>
  The fonts are cached and if they already exist they are extracted from the cache,
  not parsed again. 
 <P>
  Besides the common encodings described by name, custom encodings
  can also be made. These encodings will only work for the single byte fonts
  Type1 and TrueType. The encoding string starts with a '#'
  followed by "simple" or "full". If "simple" there is a decimal for the first character position and then a list
  of hex values representing the Unicode codes that compose that encoding.<br>
  The "simple" encoding is recommended for TrueType fonts
  as the "full" encoding risks not matching the character with the right glyph
  if not done with care.<br>
  The "full" encoding is specially aimed at Type1 fonts where the glyphs have to be
  described by non standard names like the Tex math fonts. Each group of three elements
  compose a code position: the one byte code order in decimal or as 'x' (x cannot be the space), the name and the Unicode character
  used to access the glyph. The space must be assigned to character position 32 otherwise
  text justification will not work. 
 <P>
  Example for a "simple" encoding that includes the Unicode
  character space, A, B and ecyrillic: 
 @code

  "# simple 32 0020 0041 0042 0454" 
  
@endcode
  <P>
  Example for a "full" encoding for a Type1 Tex font: 
 @code

  "# full 'A' nottriangeqlleft 0041 'B' dividemultiply 0042 32 space 0020" 
  
@endcode
  <P>
  This method calls:<br>
  @code

  createFont(name, encoding, embedded, true, null, null); 
  
@endcode
 @param name the name of the font or its location on file
 @param encoding the encoding to be applied to this font
 @param embedded true if the font is to be embedded in the PDF
 @param forceRead in some cases (TrueTypeFont, Type1Font), the full font file will be read and kept in memory if forceRead is true
 @return returns a new font. This font may come from the cache
 @throw DocumentExceptionthe font is invalid
 @throw IOExceptionthe font file could not be read
 @since 2.1.5
 */
+ (ComAowagieTextPdfBaseFont *)createFontWithNSString:(NSString *)name
                                         withNSString:(NSString *)encoding
                                          withBoolean:(jboolean)embedded
                                          withBoolean:(jboolean)forceRead;

/*!
 @brief Creates a new font.This font can be one of the 14 built in types,
  a Type1 font referred to by an AFM or PFM file, a TrueType font (simple or collection) or a CJK font from the
  Adobe Asian Font Pack.
 TrueType fonts and CJK fonts can have an optional style modifier
  appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
  example would be "STSong-Light,Bold". Note that this modifiers do not work if
  the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
  This would get the second font (indexes start at 0), in this case "MS PGothic". 
 <P>
  The fonts may or may not be cached depending on the flag <CODE>cached</CODE>.
  If the <CODE>byte</CODE> arrays are present the font will be
  read from them instead of the name. A name is still required to identify
  the font type. 
 <P>
  Besides the common encodings described by name, custom encodings
  can also be made. These encodings will only work for the single byte fonts
  Type1 and TrueType. The encoding string starts with a '#'
  followed by "simple" or "full". If "simple" there is a decimal for the first character position and then a list
  of hex values representing the Unicode codes that compose that encoding.<br>
  The "simple" encoding is recommended for TrueType fonts
  as the "full" encoding risks not matching the character with the right glyph
  if not done with care.<br>
  The "full" encoding is specially aimed at Type1 fonts where the glyphs have to be
  described by non standard names like the Tex math fonts. Each group of three elements
  compose a code position: the one byte code order in decimal or as 'x' (x cannot be the space), the name and the Unicode character
  used to access the glyph. The space must be assigned to character position 32 otherwise
  text justification will not work. 
 <P>
  Example for a "simple" encoding that includes the Unicode
  character space, A, B and ecyrillic: 
 @code

  "# simple 32 0020 0041 0042 0454" 
  
@endcode
  <P>
  Example for a "full" encoding for a Type1 Tex font: 
 @code

  "# full 'A' nottriangeqlleft 0041 'B' dividemultiply 0042 32 space 0020" 
  
@endcode
 @param name the name of the font or its location on file
 @param encoding the encoding to be applied to this font
 @param embedded true if the font is to be embedded in the PDF
 @param cached true if the font comes from the cache or is added to  the cache if new, false if the font is always created new
 @param ttfAfm the true type font or the afm in a byte array
 @param pfb the pfb in a byte array
 @return returns a new font. This font may come from the cache but only if cached
  is true, otherwise it will always be created new
 @throw DocumentExceptionthe font is invalid
 @throw IOExceptionthe font file could not be read
 @since iText 0.80
 */
+ (ComAowagieTextPdfBaseFont *)createFontWithNSString:(NSString *)name
                                         withNSString:(NSString *)encoding
                                          withBoolean:(jboolean)embedded
                                          withBoolean:(jboolean)cached
                                        withByteArray:(IOSByteArray *)ttfAfm
                                        withByteArray:(IOSByteArray *)pfb;

/*!
 @brief Creates a new font.This font can be one of the 14 built in types,
  a Type1 font referred to by an AFM or PFM file, a TrueType font (simple or collection) or a CJK font from the
  Adobe Asian Font Pack.
 TrueType fonts and CJK fonts can have an optional style modifier
  appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
  example would be "STSong-Light,Bold". Note that this modifiers do not work if
  the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
  This would get the second font (indexes start at 0), in this case "MS PGothic". 
 <P>
  The fonts may or may not be cached depending on the flag <CODE>cached</CODE>.
  If the <CODE>byte</CODE> arrays are present the font will be
  read from them instead of the name. A name is still required to identify
  the font type. 
 <P>
  Besides the common encodings described by name, custom encodings
  can also be made. These encodings will only work for the single byte fonts
  Type1 and TrueType. The encoding string starts with a '#'
  followed by "simple" or "full". If "simple" there is a decimal for the first character position and then a list
  of hex values representing the Unicode codes that compose that encoding.<br>
  The "simple" encoding is recommended for TrueType fonts
  as the "full" encoding risks not matching the character with the right glyph
  if not done with care.<br>
  The "full" encoding is specially aimed at Type1 fonts where the glyphs have to be
  described by non standard names like the Tex math fonts. Each group of three elements
  compose a code position: the one byte code order in decimal or as 'x' (x cannot be the space), the name and the Unicode character
  used to access the glyph. The space must be assigned to character position 32 otherwise
  text justification will not work. 
 <P>
  Example for a "simple" encoding that includes the Unicode
  character space, A, B and ecyrillic: 
 @code

  "# simple 32 0020 0041 0042 0454" 
  
@endcode
  <P>
  Example for a "full" encoding for a Type1 Tex font: 
 @code

  "# full 'A' nottriangeqlleft 0041 'B' dividemultiply 0042 32 space 0020" 
  
@endcode
 @param name the name of the font or its location on file
 @param encoding the encoding to be applied to this font
 @param embedded true if the font is to be embedded in the PDF
 @param cached true if the font comes from the cache or is added to  the cache if new, false if the font is always created new
 @param ttfAfm the true type font or the afm in a byte array
 @param pfb the pfb in a byte array
 @param noThrow if true will not throw an exception if the font is not recognized and will return null, if false will throw  an exception if the font is not recognized. Note that even if true an exception may be thrown in some circumstances.
   This parameter is useful for FontFactory that may have to check many invalid font names before finding the right one
 @return returns a new font. This font may come from the cache but only if cached
  is true, otherwise it will always be created new
 @throw DocumentExceptionthe font is invalid
 @throw IOExceptionthe font file could not be read
 @since 2.0.3
 */
+ (ComAowagieTextPdfBaseFont *)createFontWithNSString:(NSString *)name
                                         withNSString:(NSString *)encoding
                                          withBoolean:(jboolean)embedded
                                          withBoolean:(jboolean)cached
                                        withByteArray:(IOSByteArray *)ttfAfm
                                        withByteArray:(IOSByteArray *)pfb
                                          withBoolean:(jboolean)noThrow;

/*!
 @brief Creates a new font.This font can be one of the 14 built in types,
  a Type1 font referred to by an AFM or PFM file, a TrueType font (simple or collection) or a CJK font from the
  Adobe Asian Font Pack.
 TrueType fonts and CJK fonts can have an optional style modifier
  appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
  example would be "STSong-Light,Bold". Note that this modifiers do not work if
  the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
  This would get the second font (indexes start at 0), in this case "MS PGothic". 
 <P>
  The fonts may or may not be cached depending on the flag <CODE>cached</CODE>.
  If the <CODE>byte</CODE> arrays are present the font will be
  read from them instead of the name. A name is still required to identify
  the font type. 
 <P>
  Besides the common encodings described by name, custom encodings
  can also be made. These encodings will only work for the single byte fonts
  Type1 and TrueType. The encoding string starts with a '#'
  followed by "simple" or "full". If "simple" there is a decimal for the first character position and then a list
  of hex values representing the Unicode codes that compose that encoding.<br>
  The "simple" encoding is recommended for TrueType fonts
  as the "full" encoding risks not matching the character with the right glyph
  if not done with care.<br>
  The "full" encoding is specially aimed at Type1 fonts where the glyphs have to be
  described by non standard names like the Tex math fonts. Each group of three elements
  compose a code position: the one byte code order in decimal or as 'x' (x cannot be the space), the name and the Unicode character
  used to access the glyph. The space must be assigned to character position 32 otherwise
  text justification will not work. 
 <P>
  Example for a "simple" encoding that includes the Unicode
  character space, A, B and ecyrillic: 
 @code

  "# simple 32 0020 0041 0042 0454" 
  
@endcode
  <P>
  Example for a "full" encoding for a Type1 Tex font: 
 @code

  "# full 'A' nottriangeqlleft 0041 'B' dividemultiply 0042 32 space 0020" 
  
@endcode
 @param name the name of the font or its location on file
 @param encoding the encoding to be applied to this font
 @param embedded true if the font is to be embedded in the PDF
 @param cached true if the font comes from the cache or is added to  the cache if new, false if the font is always created new
 @param ttfAfm the true type font or the afm in a byte array
 @param pfb the pfb in a byte array
 @param noThrow if true will not throw an exception if the font is not recognized and will return null, if false will throw  an exception if the font is not recognized. Note that even if true an exception may be thrown in some circumstances.
   This parameter is useful for FontFactory that may have to check many invalid font names before finding the right one
 @param forceRead in some cases (TrueTypeFont, Type1Font), the full font file will be read and kept in memory if forceRead is true
 @return returns a new font. This font may come from the cache but only if cached
  is true, otherwise it will always be created new
 @throw DocumentExceptionthe font is invalid
 @throw IOExceptionthe font file could not be read
 @since 2.1.5
 */
+ (ComAowagieTextPdfBaseFont *)createFontWithNSString:(NSString *)name
                                         withNSString:(NSString *)encoding
                                          withBoolean:(jboolean)embedded
                                          withBoolean:(jboolean)cached
                                        withByteArray:(IOSByteArray *)ttfAfm
                                        withByteArray:(IOSByteArray *)pfb
                                          withBoolean:(jboolean)noThrow
                                          withBoolean:(jboolean)forceRead;

/*!
 @brief Creates a unique subset prefix to be added to the font name when the font is embedded and subset.
 @return the subset prefix
 */
+ (NSString *)createSubsetPrefix;

/*!
 @brief Enumerates the postscript font names present inside a
  True Type Collection.
 @param ttcArray the font as a  <CODE> byte </CODE>  array
 @throw DocumentExceptionon error
 @throw IOExceptionon error
 @return the postscript font names
 */
+ (IOSObjectArray *)enumerateTTCNamesWithByteArray:(IOSByteArray *)ttcArray;

/*!
 @brief Enumerates the postscript font names present inside a
  True Type Collection.
 @param ttcFile the file name of the font
 @throw DocumentExceptionon error
 @throw IOExceptionon error
 @return the postscript font names
 */
+ (IOSObjectArray *)enumerateTTCNamesWithNSString:(NSString *)ttcFile;

/*!
 @brief Gets all the names from the font.Only the required tables are read.
 @param name the name of the font
 @param encoding the encoding of the font
 @param ttfAfm the true type font or the afm in a byte array
 @throw DocumentExceptionon error
 @throw IOExceptionon error
 @return an array of Object[] built with {getPostscriptFontName(), getFamilyFontName(), getFullFontName()}
 */
+ (IOSObjectArray *)getAllFontNamesWithNSString:(NSString *)name
                                   withNSString:(NSString *)encoding
                                  withByteArray:(IOSByteArray *)ttfAfm;

/*!
 @brief Gets all the entries of the names-table.If it is a True Type font
  each array element will have {Name ID, Platform ID, Platform Encoding ID,
  Language ID, font name}.
 The interpretation of this values can be
  found in the Open Type specification, chapter 2, in the 'name' table.<br>
  For the other fonts the array has a single element with {"4", "", "", "",
  font name}.
 @return the full name of the font
 @since 2.0.8
 */
- (IOSObjectArray *)getAllNameEntries;

/*!
 @brief Gets all the entries of the namestable from the font.Only the required tables are read.
 @param name the name of the font
 @param encoding the encoding of the font
 @param ttfAfm the true type font or the afm in a byte array
 @throw DocumentExceptionon error
 @throw IOExceptionon error
 @return an array of Object[] built with {getPostscriptFontName(), getFamilyFontName(), getFullFontName()}
 @since 2.0.8
 */
+ (IOSObjectArray *)getAllNameEntriesWithNSString:(NSString *)name
                                     withNSString:(NSString *)encoding
                                    withByteArray:(IOSByteArray *)ttfAfm;

/*!
 @brief Gets the ascent of a <CODE>String</CODE> in normalized 1000 units.The ascent will always be
  greater than or equal to zero even if all the characters have a lower ascent.
 @param text the  <CODE> String </CODE>  to get the ascent of
 @return the ascent in normalized 1000 units
 */
- (jint)getAscentWithNSString:(NSString *)text;

/*!
 @brief Gets the ascent of a <CODE>String</CODE> in points.The ascent will always be
  greater than or equal to zero even if all the characters have a lower ascent.
 @param text the  <CODE> String </CODE>  to get the ascent of
 @param fontSize the size of the font
 @return the ascent in points
 */
- (jfloat)getAscentPointWithNSString:(NSString *)text
                           withFloat:(jfloat)fontSize;

/*!
 @brief Gets the smallest box enclosing the character contours.It will return 
 <CODE>null</CODE> if the font has not the information or the character has no
  contours, as in the case of the space, for example.
 Characters with no contours may
  also return [0,0,0,0].
 @param c the character to get the contour bounding box from
 @return an array of four floats with the bounding box in the format [llx,lly,urx,ury] or 
 <code>null</code>
 */
- (IOSIntArray *)getCharBBoxWithInt:(jint)c;

/*!
 @brief Gets the CID code given an Unicode.
 It has only meaning with CJK fonts.
 @param c the Unicode
 @return the CID equivalent
 */
- (jint)getCidCodeWithInt:(jint)c;

/*!
 @brief Gets the code pages supported by the font.This has only meaning
  with True Type fonts.
 @return the code pages supported by the font
 */
- (IOSObjectArray *)getCodePagesSupported;

/*!
 @brief Returns the compression level used for the font streams.
 @return the compression level (0 = best speed, 9 = best compression, -1 is default)
 @since 2.1.3
 */
- (jint)getCompressionLevel;

/*!
 @brief Gets the descent of a <CODE>String</CODE> in normalized 1000 units.The descent will always be
  less than or equal to zero even if all the characters have an higher descent.
 @param text the  <CODE> String </CODE>  to get the descent of
 @return the descent in normalized 1000 units
 */
- (jint)getDescentWithNSString:(NSString *)text;

/*!
 @brief Gets the descent of a <CODE>String</CODE> in points.The descent will always be
  less than or equal to zero even if all the characters have an higher descent.
 @param text the  <CODE> String </CODE>  to get the descent of
 @param fontSize the size of the font
 @return the descent in points
 */
- (jfloat)getDescentPointWithNSString:(NSString *)text
                            withFloat:(jfloat)fontSize;

/*!
 @brief Gets the array with the names of the characters.
 @return the array with the names of the characters
 */
- (IOSObjectArray *)getDifferences;

/*!
 @brief Gets a list of all document fonts.Each element of the <CODE>ArrayList</CODE>
  contains a <CODE>Object[]{String,PRIndirectReference}</CODE> with the font name
  and the indirect reference to it.
 @param reader the document where the fonts are to be listed from
 @return the list of fonts and references
 */
+ (JavaUtilArrayList *)getDocumentFontsWithComAowagieTextPdfPdfReader:(ComAowagieTextPdfPdfReader *)reader;

/*!
 @brief Gets a list of the document fonts in a particular page.Each element of the <CODE>ArrayList</CODE>
  contains a <CODE>Object[]{String,PRIndirectReference}</CODE> with the font name
  and the indirect reference to it.
 @param reader the document where the fonts are to be listed from
 @param page the page to list the fonts from
 @return the list of fonts and references
 */
+ (JavaUtilArrayList *)getDocumentFontsWithComAowagieTextPdfPdfReader:(ComAowagieTextPdfPdfReader *)reader
                                                              withInt:(jint)page;

/*!
 @brief Gets the encoding used to convert <CODE>String</CODE> into <CODE>byte[]</CODE>.
 @return the encoding name
 */
- (NSString *)getEncoding;

/*!
 @brief Gets the family name of the font.If it is a True Type font
  each array element will have {Platform ID, Platform Encoding ID,
  Language ID, font name}.
 The interpretation of this values can be
  found in the Open Type specification, chapter 2, in the 'name' table.<br>
  For the other fonts the array has a single element with {"", "", "",
  font name}.
 @return the family name of the font
 */
- (IOSObjectArray *)getFamilyFontName;

/*!
 @brief Gets the font parameter identified by <CODE>key</CODE>.Valid values
  for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>AWT_ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>,
  <CODE>DESCENT</CODE>, <CODE>AWT_DESCENT</CODE>,
  <CODE>ITALICANGLE</CODE>, <CODE>BBOXLLX</CODE>, <CODE>BBOXLLY</CODE>, <CODE>BBOXURX</CODE>
  and <CODE>BBOXURY</CODE>.
 @param key the parameter to be extracted
 @param fontSize the font size in points
 @return the parameter in points
 */
- (jfloat)getFontDescriptorWithInt:(jint)key
                         withFloat:(jfloat)fontSize;

/*!
 @brief Gets the font type.The font types can be: FONT_TYPE_T1,
  FONT_TYPE_TT, FONT_TYPE_CJK and FONT_TYPE_TTUNI.
 @return the font type
 */
- (jint)getFontType;

/*!
 @brief Gets the full name of the font.If it is a True Type font
  each array element will have {Platform ID, Platform Encoding ID,
  Language ID, font name}.
 The interpretation of this values can be
  found in the Open Type specification, chapter 2, in the 'name' table.<br>
  For the other fonts the array has a single element with {"", "", "",
  font name}.
 @return the full name of the font
 */
- (IOSObjectArray *)getFullFontName;

/*!
 @brief Gets the full name of the font.If it is a True Type font
  each array element will have {Platform ID, Platform Encoding ID,
  Language ID, font name}.
 The interpretation of this values can be
  found in the Open Type specification, chapter 2, in the 'name' table.<br>
  For the other fonts the array has a single element with {"", "", "",
  font name}.
 @param name the name of the font
 @param encoding the encoding of the font
 @param ttfAfm the true type font or the afm in a byte array
 @throw DocumentExceptionon error
 @throw IOExceptionon error
 @return the full name of the font
 */
+ (IOSObjectArray *)getFullFontNameWithNSString:(NSString *)name
                                   withNSString:(NSString *)encoding
                                  withByteArray:(IOSByteArray *)ttfAfm;

/*!
 @brief Gets the kerning between two Unicode chars.
 @param char1 the first char
 @param char2 the second char
 @return the kerning to be applied in normalized 1000 units
 */
- (jint)getKerningWithInt:(jint)char1
                  withInt:(jint)char2;

/*!
 @brief Gets the postscript font name.
 @return the postscript font name
 */
- (NSString *)getPostscriptFontName;

/*!
 @brief Gets the font resources.
 @param key the full name of the resource
 @return the <CODE>InputStream</CODE> to get the resource or 
 <CODE>null</CODE> if not found
 */
+ (JavaIoInputStream *)getResourceStreamWithNSString:(NSString *)key;

/*!
 @brief Gets the font resources.
 @param key the full name of the resource
 @param loader the ClassLoader to load the resource or null to try the ones available
 @return the <CODE>InputStream</CODE> to get the resource or 
 <CODE>null</CODE> if not found
 */
+ (JavaIoInputStream *)getResourceStreamWithNSString:(NSString *)key
                             withJavaLangClassLoader:(JavaLangClassLoader *)loader;

/*!
 @brief Gets the array with the unicode characters.
 @return the array with the unicode characters
 */
- (IOSCharArray *)getUnicodeDifferences;

/*!
 @brief Gets the Unicode equivalent to a CID.
 The (inexistent) CID &lt;FF00&gt; is translated as '\n'.
  It has only meaning with CJK fonts with Identity encoding.
 @param c the CID code
 @return the Unicode equivalent
 */
- (jint)getUnicodeEquivalentWithInt:(jint)c;

/*!
 @brief Gets the width of a <CODE>char</CODE> in normalized 1000 units.
 @param char1 the unicode  <CODE> char </CODE>  to get the width of
 @return the width in normalized 1000 units
 */
- (jint)getWidthWithInt:(jint)char1;

/*!
 @brief Gets the width of a <CODE>String</CODE> in normalized 1000 units.
 @param text the  <CODE> String </CODE>  to get the width of
 @return the width in normalized 1000 units
 */
- (jint)getWidthWithNSString:(NSString *)text;

/*!
 @brief Gets the width of a <CODE>char</CODE> in points.
 @param char1 the  <CODE> char </CODE>  to get the width of
 @param fontSize the font size
 @return the width in points
 */
- (jfloat)getWidthPointWithInt:(jint)char1
                     withFloat:(jfloat)fontSize;

/*!
 @brief Gets the width of a <CODE>String</CODE> in points.
 @param text the  <CODE> String </CODE>  to get the width of
 @param fontSize the font size
 @return the width in points
 */
- (jfloat)getWidthPointWithNSString:(NSString *)text
                          withFloat:(jfloat)fontSize;

/*!
 @brief Gets the width of a <CODE>String</CODE> in points taking kerning
  into account.
 @param text the  <CODE> String </CODE>  to get the width of
 @param fontSize the font size
 @return the width in points
 */
- (jfloat)getWidthPointKernedWithNSString:(NSString *)text
                                withFloat:(jfloat)fontSize;

/*!
 @brief Gets the font width array.
 @return the font width array
 */
- (IOSIntArray *)getWidths;

/*!
 @brief Checks if the font has any kerning pairs.
 @return <CODE>true</CODE> if the font has any kerning pairs
 */
- (jboolean)hasKernPairs;

/*!
 @brief Gets the direct conversion of <CODE>char</CODE> to <CODE>byte</CODE>.
 @return value of property directTextToByte.
 - seealso: #setDirectTextToByte(boolean directTextToByte)
 */
- (jboolean)isDirectTextToByte;

/*!
 @brief Gets the embedded flag.
 @return <CODE>true</CODE> if the font is embedded.
 */
- (jboolean)isEmbedded;

/*!
 @brief Gets the symbolic flag of the font.
 @return <CODE>true</CODE> if the font is symbolic
 */
- (jboolean)isFontSpecific;

/*!
 @brief Gets the state of the property.
 @return value of property forceWidthsOutput
 */
- (jboolean)isForceWidthsOutput;

/*!
 @brief Indicates if all the glyphs and widths for that particular
  encoding should be included in the document.
 @return <CODE>false</CODE> to include all the glyphs and widths.
 */
- (jboolean)isSubset;

/*!
 @brief Sets the character advance.
 @param c the character
 @param advance the character advance normalized to 1000 units
 @return <CODE>true</CODE> if the advance was set, 
 <CODE>false</CODE> otherwise
 */
- (jboolean)setCharAdvanceWithInt:(jint)c
                          withInt:(jint)advance;

/*!
 @brief Sets the compression level to be used for the font streams.
 @param compressionLevel a value between 0 (best speed) and 9 (best compression)
 @since 2.1.3
 */
- (void)setCompressionLevelWithInt:(jint)compressionLevel;

/*!
 @brief Sets the conversion of <CODE>char</CODE> directly to <CODE>byte</CODE>
  by casting.This is a low level feature to put the bytes directly in
  the content stream without passing through String.getBytes().
 @param directTextToByte New value of property directTextToByte.
 */
- (void)setDirectTextToByteWithBoolean:(jboolean)directTextToByte;

/*!
 @brief Set to <CODE>true</CODE> to force the generation of the
  widths array.
 @param forceWidthsOutput <CODE> true </CODE>  to force the generation of the
   widths array
 */
- (void)setForceWidthsOutputWithBoolean:(jboolean)forceWidthsOutput;

/*!
 @brief Sets the kerning between two Unicode chars.
 @param char1 the first char
 @param char2 the second char
 @param kern the kerning to apply in normalized 1000 units
 @return <code>true</code> if the kerning was applied, <code>false</code> otherwise
 */
- (jboolean)setKerningWithInt:(jint)char1
                      withInt:(jint)char2
                      withInt:(jint)kern;

/*!
 @brief Sets the font name that will appear in the pdf font dictionary.
 Use with care as it can easily make a font unreadable if not embedded.
 @param name the new font name
 */
- (void)setPostscriptFontNameWithNSString:(NSString *)name;

/*!
 @brief Indicates if all the glyphs and widths for that particular
  encoding should be included in the document.When set to <CODE>true</CODE>
  only the glyphs used will be included in the font.
 When set to <CODE>false</CODE>
  and <code>addSubsetRange(int[])</code> was not called the full font will be included
  otherwise just the characters ranges will be included.
 @param subset new value of property subset
 */
- (void)setSubsetWithBoolean:(jboolean)subset;

#pragma mark Protected

/*!
 @brief Creates new BaseFont
 */
- (instancetype)init;

/*!
 @brief Creates the <CODE>widths</CODE> and the <CODE>differences</CODE> arrays
 */
- (void)createEncoding;

/*!
 @brief Gets the name without the modifiers Bold, Italic or BoldItalic.
 @param name the full name of the font
 @return the name without the modifiers Bold, Italic or BoldItalic
 */
+ (NSString *)getBaseNameWithNSString:(NSString *)name;

- (IOSIntArray *)getRawCharBBoxWithInt:(jint)c
                          withNSString:(NSString *)name;

/*!
 @brief Normalize the encoding names."
 winansi" is changed to "Cp1252" and
  "macroman" is changed to "MacRoman".
 @param enc the encoding to be normalized
 @return the normalized encoding
 */
+ (NSString *)normalizeEncodingWithNSString:(NSString *)enc;

#pragma mark Package-Private

/*!
 @brief Converts a <CODE>char</CODE> to a <CODE>byte</CODE> array according
  to the font's encoding.
 @param char1 the  <CODE> char </CODE>  to be converted
 @return an array of <CODE>byte</CODE> representing the conversion according to the font's encoding
 */
- (IOSByteArray *)convertToBytesWithInt:(jint)char1;

/*!
 @brief Converts a <CODE>String</CODE> to a <CODE>byte</CODE> array according
  to the font's encoding.
 @param text the  <CODE> String </CODE>  to be converted
 @return an array of <CODE>byte</CODE> representing the conversion according to the font's encoding
 */
- (IOSByteArray *)convertToBytesWithNSString:(NSString *)text;

/*!
 @brief Returns a PdfStream object with the full font program (if possible).
 This method will return null for some types of fonts (CJKFont, Type3Font)
  or if there is no font program available (standard Type 1 fonts).
 @return a PdfStream with the font program
 @since 2.1.3
 @throw IOExceptionException of a I/O
 @throw DocumentExceptionException of a document
 */
- (ComAowagieTextPdfPdfStream *)getFullFontStream;

/*!
 @brief Gets the width from the font according to the Unicode char <CODE>c</CODE>
  or the <CODE>name</CODE>.If the <CODE>name</CODE> is null it's a symbolic font.
 @param c the unicode char
 @param name the glyph name
 @return the width of the char
 */
- (jint)getRawWidthWithInt:(jint)c
              withNSString:(NSString *)name;

/*!
 @brief Gets the Unicode character corresponding to the byte output to the pdf stream.
 @param index the byte index
 @return the Unicode character
 */
- (jchar)getUnicodeDifferencesWithInt:(jint)index;

/*!
 @brief Outputs to the writer the font dictionaries and streams.
 @param writer the writer for this document
 @param ref the font indirect reference
 @param params several parameters that depend on the font type
 @throw IOExceptionon error
 @throw DocumentExceptionerror in generating the object
 */
- (void)writeFontWithComAowagieTextPdfPdfWriter:(ComAowagieTextPdfPdfWriter *)writer
      withComAowagieTextPdfPdfIndirectReference:(ComAowagieTextPdfPdfIndirectReference *)ref
                              withNSObjectArray:(IOSObjectArray *)params;

@end

J2OBJC_STATIC_INIT(ComAowagieTextPdfBaseFont)

J2OBJC_FIELD_SETTER(ComAowagieTextPdfBaseFont, subsetRanges_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfBaseFont, widths_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfBaseFont, differences_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfBaseFont, unicodeDifferences_, IOSCharArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfBaseFont, charBBoxes_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfBaseFont, encoding_, NSString *)
J2OBJC_FIELD_SETTER(ComAowagieTextPdfBaseFont, specialMap_, ComAowagieTextPdfIntHashtable *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_COURIER(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_COURIER;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, COURIER, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_COURIER_BOLD(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_COURIER_BOLD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, COURIER_BOLD, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_COURIER_OBLIQUE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_COURIER_OBLIQUE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, COURIER_OBLIQUE, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_COURIER_BOLDOBLIQUE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_COURIER_BOLDOBLIQUE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, COURIER_BOLDOBLIQUE, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_HELVETICA(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_HELVETICA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, HELVETICA, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_HELVETICA_BOLD(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_HELVETICA_BOLD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, HELVETICA_BOLD, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_HELVETICA_OBLIQUE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_HELVETICA_OBLIQUE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, HELVETICA_OBLIQUE, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_HELVETICA_BOLDOBLIQUE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_HELVETICA_BOLDOBLIQUE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, HELVETICA_BOLDOBLIQUE, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_SYMBOL(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_SYMBOL;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, SYMBOL, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_TIMES_ROMAN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_TIMES_ROMAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, TIMES_ROMAN, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_TIMES_BOLD(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_TIMES_BOLD;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, TIMES_BOLD, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_TIMES_ITALIC(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_TIMES_ITALIC;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, TIMES_ITALIC, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_TIMES_BOLDITALIC(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_TIMES_BOLDITALIC;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, TIMES_BOLDITALIC, NSString *)

/*!
 @brief This is a possible value of a base 14 type 1 font
 */
inline NSString *ComAowagieTextPdfBaseFont_get_ZAPFDINGBATS(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_ZAPFDINGBATS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, ZAPFDINGBATS, NSString *)

/*!
 @brief The maximum height above the baseline reached by glyphs in this
  font, excluding the height of glyphs for accented characters.
 */
inline jint ComAowagieTextPdfBaseFont_get_ASCENT(void);
#define ComAowagieTextPdfBaseFont_ASCENT 1
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, ASCENT, jint)

/*!
 @brief The y coordinate of the top of flat capital letters, measured from
  the baseline.
 */
inline jint ComAowagieTextPdfBaseFont_get_CAPHEIGHT(void);
#define ComAowagieTextPdfBaseFont_CAPHEIGHT 2
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, CAPHEIGHT, jint)

/*!
 @brief The maximum depth below the baseline reached by glyphs in this
  font.The value is a negative number.
 */
inline jint ComAowagieTextPdfBaseFont_get_DESCENT(void);
#define ComAowagieTextPdfBaseFont_DESCENT 3
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, DESCENT, jint)

/*!
 @brief The angle, expressed in degrees counterclockwise from the vertical,
  of the dominant vertical strokes of the font.The value is
  negative for fonts that slope to the right, as almost all italic fonts do.
 */
inline jint ComAowagieTextPdfBaseFont_get_ITALICANGLE(void);
#define ComAowagieTextPdfBaseFont_ITALICANGLE 4
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, ITALICANGLE, jint)

/*!
 @brief The lower left x glyph coordinate.
 */
inline jint ComAowagieTextPdfBaseFont_get_BBOXLLX(void);
#define ComAowagieTextPdfBaseFont_BBOXLLX 5
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, BBOXLLX, jint)

/*!
 @brief The lower left y glyph coordinate.
 */
inline jint ComAowagieTextPdfBaseFont_get_BBOXLLY(void);
#define ComAowagieTextPdfBaseFont_BBOXLLY 6
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, BBOXLLY, jint)

/*!
 @brief The upper right x glyph coordinate.
 */
inline jint ComAowagieTextPdfBaseFont_get_BBOXURX(void);
#define ComAowagieTextPdfBaseFont_BBOXURX 7
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, BBOXURX, jint)

/*!
 @brief The upper right y glyph coordinate.
 */
inline jint ComAowagieTextPdfBaseFont_get_BBOXURY(void);
#define ComAowagieTextPdfBaseFont_BBOXURY 8
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, BBOXURY, jint)

/*!
 @brief java.awt.Font property
 */
inline jint ComAowagieTextPdfBaseFont_get_AWT_ASCENT(void);
#define ComAowagieTextPdfBaseFont_AWT_ASCENT 9
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, AWT_ASCENT, jint)

/*!
 @brief java.awt.Font property
 */
inline jint ComAowagieTextPdfBaseFont_get_AWT_DESCENT(void);
#define ComAowagieTextPdfBaseFont_AWT_DESCENT 10
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, AWT_DESCENT, jint)

/*!
 @brief java.awt.Font property
 */
inline jint ComAowagieTextPdfBaseFont_get_AWT_LEADING(void);
#define ComAowagieTextPdfBaseFont_AWT_LEADING 11
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, AWT_LEADING, jint)

/*!
 @brief java.awt.Font property
 */
inline jint ComAowagieTextPdfBaseFont_get_AWT_MAXADVANCE(void);
#define ComAowagieTextPdfBaseFont_AWT_MAXADVANCE 12
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, AWT_MAXADVANCE, jint)

/*!
 @brief The underline position.Usually a negative value.
 */
inline jint ComAowagieTextPdfBaseFont_get_UNDERLINE_POSITION(void);
#define ComAowagieTextPdfBaseFont_UNDERLINE_POSITION 13
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, UNDERLINE_POSITION, jint)

/*!
 @brief The underline thickness.
 */
inline jint ComAowagieTextPdfBaseFont_get_UNDERLINE_THICKNESS(void);
#define ComAowagieTextPdfBaseFont_UNDERLINE_THICKNESS 14
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, UNDERLINE_THICKNESS, jint)

/*!
 @brief The strikethrough position.
 */
inline jint ComAowagieTextPdfBaseFont_get_STRIKETHROUGH_POSITION(void);
#define ComAowagieTextPdfBaseFont_STRIKETHROUGH_POSITION 15
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, STRIKETHROUGH_POSITION, jint)

/*!
 @brief The strikethrough thickness.
 */
inline jint ComAowagieTextPdfBaseFont_get_STRIKETHROUGH_THICKNESS(void);
#define ComAowagieTextPdfBaseFont_STRIKETHROUGH_THICKNESS 16
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, STRIKETHROUGH_THICKNESS, jint)

/*!
 @brief The recommended vertical size for subscripts for this font.
 */
inline jint ComAowagieTextPdfBaseFont_get_SUBSCRIPT_SIZE(void);
#define ComAowagieTextPdfBaseFont_SUBSCRIPT_SIZE 17
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, SUBSCRIPT_SIZE, jint)

/*!
 @brief The recommended vertical offset from the baseline for subscripts for this font.Usually a negative value.
 */
inline jint ComAowagieTextPdfBaseFont_get_SUBSCRIPT_OFFSET(void);
#define ComAowagieTextPdfBaseFont_SUBSCRIPT_OFFSET 18
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, SUBSCRIPT_OFFSET, jint)

/*!
 @brief The recommended vertical size for superscripts for this font.
 */
inline jint ComAowagieTextPdfBaseFont_get_SUPERSCRIPT_SIZE(void);
#define ComAowagieTextPdfBaseFont_SUPERSCRIPT_SIZE 19
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, SUPERSCRIPT_SIZE, jint)

/*!
 @brief The recommended vertical offset from the baseline for superscripts for this font.
 */
inline jint ComAowagieTextPdfBaseFont_get_SUPERSCRIPT_OFFSET(void);
#define ComAowagieTextPdfBaseFont_SUPERSCRIPT_OFFSET 20
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, SUPERSCRIPT_OFFSET, jint)

/*!
 @brief The font is Type 1.
 */
inline jint ComAowagieTextPdfBaseFont_get_FONT_TYPE_T1(void);
#define ComAowagieTextPdfBaseFont_FONT_TYPE_T1 0
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, FONT_TYPE_T1, jint)

/*!
 @brief The font is True Type with a standard encoding.
 */
inline jint ComAowagieTextPdfBaseFont_get_FONT_TYPE_TT(void);
#define ComAowagieTextPdfBaseFont_FONT_TYPE_TT 1
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, FONT_TYPE_TT, jint)

/*!
 @brief The font is CJK.
 */
inline jint ComAowagieTextPdfBaseFont_get_FONT_TYPE_CJK(void);
#define ComAowagieTextPdfBaseFont_FONT_TYPE_CJK 2
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, FONT_TYPE_CJK, jint)

/*!
 @brief The font is True Type with a Unicode encoding.
 */
inline jint ComAowagieTextPdfBaseFont_get_FONT_TYPE_TTUNI(void);
#define ComAowagieTextPdfBaseFont_FONT_TYPE_TTUNI 3
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, FONT_TYPE_TTUNI, jint)

/*!
 @brief A font already inside the document.
 */
inline jint ComAowagieTextPdfBaseFont_get_FONT_TYPE_DOCUMENT(void);
#define ComAowagieTextPdfBaseFont_FONT_TYPE_DOCUMENT 4
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, FONT_TYPE_DOCUMENT, jint)

/*!
 @brief A Type3 font.
 */
inline jint ComAowagieTextPdfBaseFont_get_FONT_TYPE_T3(void);
#define ComAowagieTextPdfBaseFont_FONT_TYPE_T3 5
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, FONT_TYPE_T3, jint)

/*!
 @brief The Unicode encoding with horizontal writing.
 */
inline NSString *ComAowagieTextPdfBaseFont_get_IDENTITY_H(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_IDENTITY_H;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, IDENTITY_H, NSString *)

/*!
 @brief The Unicode encoding with vertical writing.
 */
inline NSString *ComAowagieTextPdfBaseFont_get_IDENTITY_V(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_IDENTITY_V;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, IDENTITY_V, NSString *)

/*!
 @brief A possible encoding.
 */
inline NSString *ComAowagieTextPdfBaseFont_get_CP1250(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_CP1250;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, CP1250, NSString *)

/*!
 @brief A possible encoding.
 */
inline NSString *ComAowagieTextPdfBaseFont_get_CP1252(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_CP1252;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, CP1252, NSString *)

/*!
 @brief A possible encoding.
 */
inline NSString *ComAowagieTextPdfBaseFont_get_CP1257(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_CP1257;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, CP1257, NSString *)

/*!
 @brief A possible encoding.
 */
inline NSString *ComAowagieTextPdfBaseFont_get_WINANSI(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_WINANSI;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, WINANSI, NSString *)

/*!
 @brief A possible encoding.
 */
inline NSString *ComAowagieTextPdfBaseFont_get_MACROMAN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_MACROMAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, MACROMAN, NSString *)

inline IOSIntArray *ComAowagieTextPdfBaseFont_get_CHAR_RANGE_LATIN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *ComAowagieTextPdfBaseFont_CHAR_RANGE_LATIN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, CHAR_RANGE_LATIN, IOSIntArray *)

inline IOSIntArray *ComAowagieTextPdfBaseFont_get_CHAR_RANGE_ARABIC(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *ComAowagieTextPdfBaseFont_CHAR_RANGE_ARABIC;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, CHAR_RANGE_ARABIC, IOSIntArray *)

inline IOSIntArray *ComAowagieTextPdfBaseFont_get_CHAR_RANGE_HEBREW(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *ComAowagieTextPdfBaseFont_CHAR_RANGE_HEBREW;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, CHAR_RANGE_HEBREW, IOSIntArray *)

inline IOSIntArray *ComAowagieTextPdfBaseFont_get_CHAR_RANGE_CYRILLIC(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSIntArray *ComAowagieTextPdfBaseFont_CHAR_RANGE_CYRILLIC;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, CHAR_RANGE_CYRILLIC, IOSIntArray *)

/*!
 @brief if the font has to be embedded
 */
inline jboolean ComAowagieTextPdfBaseFont_get_EMBEDDED(void);
#define ComAowagieTextPdfBaseFont_EMBEDDED true
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, EMBEDDED, jboolean)

/*!
 @brief if the font doesn't have to be embedded
 */
inline jboolean ComAowagieTextPdfBaseFont_get_NOT_EMBEDDED(void);
#define ComAowagieTextPdfBaseFont_NOT_EMBEDDED false
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, NOT_EMBEDDED, jboolean)

/*!
 @brief if the font has to be cached
 */
inline jboolean ComAowagieTextPdfBaseFont_get_CACHED(void);
#define ComAowagieTextPdfBaseFont_CACHED true
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, CACHED, jboolean)

/*!
 @brief if the font doesn't have to be cached
 */
inline jboolean ComAowagieTextPdfBaseFont_get_NOT_CACHED(void);
#define ComAowagieTextPdfBaseFont_NOT_CACHED false
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, NOT_CACHED, jboolean)

/*!
 @brief The path to the font resources.
 */
inline NSString *ComAowagieTextPdfBaseFont_get_RESOURCE_PATH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_RESOURCE_PATH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, RESOURCE_PATH, NSString *)

/*!
 @brief The fake CID code that represents a newline.
 */
inline jchar ComAowagieTextPdfBaseFont_get_CID_NEWLINE(void);
#define ComAowagieTextPdfBaseFont_CID_NEWLINE 0x7fff
J2OBJC_STATIC_FIELD_CONSTANT(ComAowagieTextPdfBaseFont, CID_NEWLINE, jchar)

/*!
 @brief a not defined character in a custom PDF encoding
 */
inline NSString *ComAowagieTextPdfBaseFont_get_notdef(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_notdef;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, notdef, NSString *)

/*!
 @brief cache for the fonts already used.
 */
inline JavaUtilHashMap *ComAowagieTextPdfBaseFont_get_fontCache(void);
inline JavaUtilHashMap *ComAowagieTextPdfBaseFont_set_fontCache(JavaUtilHashMap *value);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilHashMap *ComAowagieTextPdfBaseFont_fontCache;
J2OBJC_STATIC_FIELD_OBJ(ComAowagieTextPdfBaseFont, fontCache, JavaUtilHashMap *)

/*!
 @brief list of the 14 built in fonts.
 */
inline JavaUtilHashMap *ComAowagieTextPdfBaseFont_get_BuiltinFonts14(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilHashMap *ComAowagieTextPdfBaseFont_BuiltinFonts14;
J2OBJC_STATIC_FIELD_OBJ_FINAL(ComAowagieTextPdfBaseFont, BuiltinFonts14, JavaUtilHashMap *)

FOUNDATION_EXPORT void ComAowagieTextPdfBaseFont_init(ComAowagieTextPdfBaseFont *self);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont *ComAowagieTextPdfBaseFont_createFont(void);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont *ComAowagieTextPdfBaseFont_createFontWithNSString_withNSString_withBoolean_(NSString *name, NSString *encoding, jboolean embedded);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont *ComAowagieTextPdfBaseFont_createFontWithNSString_withNSString_withBoolean_withBoolean_(NSString *name, NSString *encoding, jboolean embedded, jboolean forceRead);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont *ComAowagieTextPdfBaseFont_createFontWithNSString_withNSString_withBoolean_withBoolean_withByteArray_withByteArray_(NSString *name, NSString *encoding, jboolean embedded, jboolean cached, IOSByteArray *ttfAfm, IOSByteArray *pfb);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont *ComAowagieTextPdfBaseFont_createFontWithNSString_withNSString_withBoolean_withBoolean_withByteArray_withByteArray_withBoolean_(NSString *name, NSString *encoding, jboolean embedded, jboolean cached, IOSByteArray *ttfAfm, IOSByteArray *pfb, jboolean noThrow);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont *ComAowagieTextPdfBaseFont_createFontWithNSString_withNSString_withBoolean_withBoolean_withByteArray_withByteArray_withBoolean_withBoolean_(NSString *name, NSString *encoding, jboolean embedded, jboolean cached, IOSByteArray *ttfAfm, IOSByteArray *pfb, jboolean noThrow, jboolean forceRead);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont *ComAowagieTextPdfBaseFont_createFontWithComAowagieTextPdfPRIndirectReference_(ComAowagieTextPdfPRIndirectReference *fontRef);

FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_getBaseNameWithNSString_(NSString *name);

FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_normalizeEncodingWithNSString_(NSString *enc);

FOUNDATION_EXPORT NSString *ComAowagieTextPdfBaseFont_createSubsetPrefix(void);

FOUNDATION_EXPORT IOSObjectArray *ComAowagieTextPdfBaseFont_getFullFontNameWithNSString_withNSString_withByteArray_(NSString *name, NSString *encoding, IOSByteArray *ttfAfm);

FOUNDATION_EXPORT IOSObjectArray *ComAowagieTextPdfBaseFont_getAllFontNamesWithNSString_withNSString_withByteArray_(NSString *name, NSString *encoding, IOSByteArray *ttfAfm);

FOUNDATION_EXPORT IOSObjectArray *ComAowagieTextPdfBaseFont_getAllNameEntriesWithNSString_withNSString_withByteArray_(NSString *name, NSString *encoding, IOSByteArray *ttfAfm);

FOUNDATION_EXPORT IOSObjectArray *ComAowagieTextPdfBaseFont_enumerateTTCNamesWithNSString_(NSString *ttcFile);

FOUNDATION_EXPORT IOSObjectArray *ComAowagieTextPdfBaseFont_enumerateTTCNamesWithByteArray_(IOSByteArray *ttcArray);

FOUNDATION_EXPORT JavaIoInputStream *ComAowagieTextPdfBaseFont_getResourceStreamWithNSString_(NSString *key);

FOUNDATION_EXPORT JavaIoInputStream *ComAowagieTextPdfBaseFont_getResourceStreamWithNSString_withJavaLangClassLoader_(NSString *key, JavaLangClassLoader *loader);

FOUNDATION_EXPORT JavaUtilArrayList *ComAowagieTextPdfBaseFont_getDocumentFontsWithComAowagieTextPdfPdfReader_(ComAowagieTextPdfPdfReader *reader);

FOUNDATION_EXPORT JavaUtilArrayList *ComAowagieTextPdfBaseFont_getDocumentFontsWithComAowagieTextPdfPdfReader_withInt_(ComAowagieTextPdfPdfReader *reader, jint page);

J2OBJC_TYPE_LITERAL_HEADER(ComAowagieTextPdfBaseFont)

#endif

#if !defined (ComAowagieTextPdfBaseFont_StreamFont_) && (INCLUDE_ALL_BaseFont || defined(INCLUDE_ComAowagieTextPdfBaseFont_StreamFont))
#define ComAowagieTextPdfBaseFont_StreamFont_

#define RESTRICT_PdfStream 1
#define INCLUDE_ComAowagieTextPdfPdfStream 1
#include "PdfStream.h"

@class ComAowagieTextPdfPdfWriter;
@class IOSByteArray;
@class IOSIntArray;
@class JavaIoInputStream;

/*!
 @brief Generates the PDF stream with the Type1 and Truetype fonts returning
  a PdfStream.
 */
@interface ComAowagieTextPdfBaseFont_StreamFont : ComAowagieTextPdfPdfStream

#pragma mark Public

/*!
 @brief Generates the PDF stream with the Type1 and Truetype fonts returning
  a PdfStream.
 @param contents the content of the stream
 @param lengths an array of int that describes the several lengths of each part of the font
 @param compressionLevel the compression level of the Stream
 @throw DocumentExceptionerror in the stream compression
 @since 2.1.3 (replaces the constructor without param compressionLevel)
 */
- (instancetype)initWithByteArray:(IOSByteArray *)contents
                     withIntArray:(IOSIntArray *)lengths
                          withInt:(jint)compressionLevel;

/*!
 @brief Generates the PDF stream for a font.
 @param contents the content of a stream
 @param subType the subtype of the font.
 @param compressionLevel the compression level of the Stream
 @throw DocumentExceptionerror in the stream compression
 @since 2.1.3 (replaces the constructor without param compressionLevel)
 */
- (instancetype)initWithByteArray:(IOSByteArray *)contents
                     withNSString:(NSString *)subType
                          withInt:(jint)compressionLevel;

// Disallowed inherited constructors, do not use.

- (instancetype)init NS_UNAVAILABLE;

- (instancetype)initWithByteArray:(IOSByteArray *)arg0 NS_UNAVAILABLE;

- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)arg0
           withComAowagieTextPdfPdfWriter:(ComAowagieTextPdfPdfWriter *)arg1 NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComAowagieTextPdfBaseFont_StreamFont)

FOUNDATION_EXPORT void ComAowagieTextPdfBaseFont_StreamFont_initWithByteArray_withIntArray_withInt_(ComAowagieTextPdfBaseFont_StreamFont *self, IOSByteArray *contents, IOSIntArray *lengths, jint compressionLevel);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont_StreamFont *new_ComAowagieTextPdfBaseFont_StreamFont_initWithByteArray_withIntArray_withInt_(IOSByteArray *contents, IOSIntArray *lengths, jint compressionLevel) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont_StreamFont *create_ComAowagieTextPdfBaseFont_StreamFont_initWithByteArray_withIntArray_withInt_(IOSByteArray *contents, IOSIntArray *lengths, jint compressionLevel);

FOUNDATION_EXPORT void ComAowagieTextPdfBaseFont_StreamFont_initWithByteArray_withNSString_withInt_(ComAowagieTextPdfBaseFont_StreamFont *self, IOSByteArray *contents, NSString *subType, jint compressionLevel);

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont_StreamFont *new_ComAowagieTextPdfBaseFont_StreamFont_initWithByteArray_withNSString_withInt_(IOSByteArray *contents, NSString *subType, jint compressionLevel) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComAowagieTextPdfBaseFont_StreamFont *create_ComAowagieTextPdfBaseFont_StreamFont_initWithByteArray_withNSString_withInt_(IOSByteArray *contents, NSString *subType, jint compressionLevel);

J2OBJC_TYPE_LITERAL_HEADER(ComAowagieTextPdfBaseFont_StreamFont)

#endif

#pragma pop_macro("INCLUDE_ALL_BaseFont")
